{"ast":null,"code":"'use strict';\n\n/**\r\n * @module symbol-tree\r\n * @author Joris van der Wel <joris@jorisvanderwel.com>\r\n */\nconst SymbolTreeNode = require('./SymbolTreeNode');\nconst TreePosition = require('./TreePosition');\nconst TreeIterator = require('./TreeIterator');\nfunction returnTrue() {\n  return true;\n}\nfunction reverseArrayIndex(array, reverseIndex) {\n  return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\n}\n\nclass SymbolTree {\n  /**\r\n   * @constructor\r\n   * @alias module:symbol-tree\r\n   * @param {string} [description='SymbolTree data'] Description used for the Symbol\r\n   */\n  constructor(description) {\n    this.symbol = Symbol(description || 'SymbolTree data');\n  }\n\n  /**\r\n   * You can use this function to (optionally) initialize an object right after its creation,\r\n   * to take advantage of V8's fast properties. Also useful if you would like to\r\n   * freeze your object.\r\n   *\r\n   * `O(1)`\r\n   *\r\n   * @method\r\n   * @alias module:symbol-tree#initialize\r\n   * @param {Object} object\r\n   * @return {Object} object\r\n   */\n  initialize(object) {\n    this._node(object);\n    return object;\n  }\n  _node(object) {\n    if (!object) {\n      return null;\n    }\n    const node = object[this.symbol];\n    if (node) {\n      return node;\n    }\n    return object[this.symbol] = new SymbolTreeNode();\n  }\n\n  /**\r\n   * Returns `true` if the object has any children. Otherwise it returns `false`.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method hasChildren\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Boolean}\r\n   */\n  hasChildren(object) {\n    return this._node(object).hasChildren;\n  }\n\n  /**\r\n   * Returns the first child of the given object.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method firstChild\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n  firstChild(object) {\n    return this._node(object).firstChild;\n  }\n\n  /**\r\n   * Returns the last child of the given object.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method lastChild\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n  lastChild(object) {\n    return this._node(object).lastChild;\n  }\n\n  /**\r\n   * Returns the previous sibling of the given object.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method previousSibling\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n  previousSibling(object) {\n    return this._node(object).previousSibling;\n  }\n\n  /**\r\n   * Returns the next sibling of the given object.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method nextSibling\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n  nextSibling(object) {\n    return this._node(object).nextSibling;\n  }\n\n  /**\r\n   * Return the parent of the given object.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method parent\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n  parent(object) {\n    return this._node(object).parent;\n  }\n\n  /**\r\n   * Find the inclusive descendant that is last in tree order of the given object.\r\n   *\r\n   * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\r\n   *\r\n   * @method lastInclusiveDescendant\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object}\r\n   */\n  lastInclusiveDescendant(object) {\n    let lastChild;\n    let current = object;\n    while (lastChild = this._node(current).lastChild) {\n      current = lastChild;\n    }\n    return current;\n  }\n\n  /**\r\n   * Find the preceding object (A) of the given object (B).\r\n   * An object A is preceding an object B if A and B are in the same tree\r\n   * and A comes before B in tree order.\r\n   *\r\n   * * `O(n)` (worst case)\r\n   * * `O(1)` (amortized when walking the entire tree)\r\n   *\r\n   * @method preceding\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @param {Object} [options]\r\n   * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\r\n   *        of the return value (or else null is returned). This check _assumes_\r\n   *        that `root` is also an inclusive ancestor of the given `object`\r\n   * @return {?Object}\r\n   */\n  preceding(object, options) {\n    const treeRoot = options && options.root;\n    if (object === treeRoot) {\n      return null;\n    }\n    const previousSibling = this._node(object).previousSibling;\n    if (previousSibling) {\n      return this.lastInclusiveDescendant(previousSibling);\n    }\n\n    // if there is no previous sibling return the parent (might be null)\n    return this._node(object).parent;\n  }\n\n  /**\r\n   * Find the following object (A) of the given object (B).\r\n   * An object A is following an object B if A and B are in the same tree\r\n   * and A comes after B in tree order.\r\n   *\r\n   * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\r\n   * * `O(1)` (amortized when walking the entire tree)\r\n   *\r\n   * @method following\r\n   * @memberOf module:symbol-tree#\r\n   * @param {!Object} object\r\n   * @param {Object} [options]\r\n   * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\r\n   *        of the return value (or else null is returned). This check _assumes_\r\n   *        that `root` is also an inclusive ancestor of the given `object`\r\n   * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\r\n   * @return {?Object}\r\n   */\n  following(object, options) {\n    const treeRoot = options && options.root;\n    const skipChildren = options && options.skipChildren;\n    const firstChild = !skipChildren && this._node(object).firstChild;\n    if (firstChild) {\n      return firstChild;\n    }\n    let current = object;\n    do {\n      if (current === treeRoot) {\n        return null;\n      }\n      const nextSibling = this._node(current).nextSibling;\n      if (nextSibling) {\n        return nextSibling;\n      }\n      current = this._node(current).parent;\n    } while (current);\n    return null;\n  }\n\n  /**\r\n   * Append all children of the given object to an array.\r\n   *\r\n   * * `O(n)` where `n` is the amount of children of the given `parent`\r\n   *\r\n   * @method childrenToArray\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} parent\r\n   * @param {Object} [options]\r\n   * @param {Object[]} [options.array=[]]\r\n   * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n   *                            Invoked with arguments (object). Should return `true` if an object\r\n   *                            is to be included.\r\n   * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n   * @return {Object[]}\r\n   */\n  childrenToArray(parent, options) {\n    const array = options && options.array || [];\n    const filter = options && options.filter || returnTrue;\n    const thisArg = options && options.thisArg || undefined;\n    const parentNode = this._node(parent);\n    let object = parentNode.firstChild;\n    let index = 0;\n    while (object) {\n      const node = this._node(object);\n      node.setCachedIndex(parentNode, index);\n      if (filter.call(thisArg, object)) {\n        array.push(object);\n      }\n      object = node.nextSibling;\n      ++index;\n    }\n    return array;\n  }\n\n  /**\r\n   * Append all inclusive ancestors of the given object to an array.\r\n   *\r\n   * * `O(n)` where `n` is the amount of ancestors of the given `object`\r\n   *\r\n   * @method ancestorsToArray\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @param {Object} [options]\r\n   * @param {Object[]} [options.array=[]]\r\n   * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n   *                            Invoked with arguments (object). Should return `true` if an object\r\n   *                            is to be included.\r\n   * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n   * @return {Object[]}\r\n   */\n  ancestorsToArray(object, options) {\n    const array = options && options.array || [];\n    const filter = options && options.filter || returnTrue;\n    const thisArg = options && options.thisArg || undefined;\n    let ancestor = object;\n    while (ancestor) {\n      if (filter.call(thisArg, ancestor)) {\n        array.push(ancestor);\n      }\n      ancestor = this._node(ancestor).parent;\n    }\n    return array;\n  }\n\n  /**\r\n   * Append all descendants of the given object to an array (in tree order).\r\n   *\r\n   * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\r\n   *\r\n   * @method treeToArray\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} root\r\n   * @param {Object} [options]\r\n   * @param {Object[]} [options.array=[]]\r\n   * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n   *                            Invoked with arguments (object). Should return `true` if an object\r\n   *                            is to be included.\r\n   * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n   * @return {Object[]}\r\n   */\n  treeToArray(root, options) {\n    const array = options && options.array || [];\n    const filter = options && options.filter || returnTrue;\n    const thisArg = options && options.thisArg || undefined;\n    let object = root;\n    while (object) {\n      if (filter.call(thisArg, object)) {\n        array.push(object);\n      }\n      object = this.following(object, {\n        root: root\n      });\n    }\n    return array;\n  }\n\n  /**\r\n   * Iterate over all children of the given object\r\n   *\r\n   * * `O(1)` for a single iteration\r\n   *\r\n   * @method childrenIterator\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} parent\r\n   * @param {Object} [options]\r\n   * @param {Boolean} [options.reverse=false]\r\n   * @return {Object} An iterable iterator (ES6)\r\n   */\n  childrenIterator(parent, options) {\n    const reverse = options && options.reverse;\n    const parentNode = this._node(parent);\n    return new TreeIterator(this, parent, reverse ? parentNode.lastChild : parentNode.firstChild, reverse ? TreeIterator.PREV : TreeIterator.NEXT);\n  }\n\n  /**\r\n   * Iterate over all the previous siblings of the given object. (in reverse tree order)\r\n   *\r\n   * * `O(1)` for a single iteration\r\n   *\r\n   * @method previousSiblingsIterator\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object} An iterable iterator (ES6)\r\n   */\n  previousSiblingsIterator(object) {\n    return new TreeIterator(this, object, this._node(object).previousSibling, TreeIterator.PREV);\n  }\n\n  /**\r\n   * Iterate over all the next siblings of the given object. (in tree order)\r\n   *\r\n   * * `O(1)` for a single iteration\r\n   *\r\n   * @method nextSiblingsIterator\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object} An iterable iterator (ES6)\r\n   */\n  nextSiblingsIterator(object) {\n    return new TreeIterator(this, object, this._node(object).nextSibling, TreeIterator.NEXT);\n  }\n\n  /**\r\n   * Iterate over all inclusive ancestors of the given object\r\n   *\r\n   * * `O(1)` for a single iteration\r\n   *\r\n   * @method ancestorsIterator\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} object\r\n   * @return {Object} An iterable iterator (ES6)\r\n   */\n  ancestorsIterator(object) {\n    return new TreeIterator(this, object, object, TreeIterator.PARENT);\n  }\n\n  /**\r\n   * Iterate over all descendants of the given object (in tree order).\r\n   *\r\n   * Where `n` is the amount of objects in the sub-tree of the given `root`:\r\n   *\r\n   * * `O(n)` (worst case for a single iteration)\r\n   * * `O(n)` (amortized, when completing the iterator)\r\n   *\r\n   * @method treeIterator\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} root\r\n   * @param {Object} options\r\n   * @param {Boolean} [options.reverse=false]\r\n   * @return {Object} An iterable iterator (ES6)\r\n   */\n  treeIterator(root, options) {\n    const reverse = options && options.reverse;\n    return new TreeIterator(this, root, reverse ? this.lastInclusiveDescendant(root) : root, reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING);\n  }\n\n  /**\r\n   * Find the index of the given object (the number of preceding siblings).\r\n   *\r\n   * * `O(n)` where `n` is the amount of preceding siblings\r\n   * * `O(1)` (amortized, if the tree is not modified)\r\n   *\r\n   * @method index\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} child\r\n   * @return {Number} The number of preceding siblings, or -1 if the object has no parent\r\n   */\n  index(child) {\n    const childNode = this._node(child);\n    const parentNode = this._node(childNode.parent);\n    if (!parentNode) {\n      // In principal, you could also find out the number of preceding siblings\n      // for objects that do not have a parent. This method limits itself only to\n      // objects that have a parent because that lets us optimize more.\n      return -1;\n    }\n    let currentIndex = childNode.getCachedIndex(parentNode);\n    if (currentIndex >= 0) {\n      return currentIndex;\n    }\n    currentIndex = 0;\n    let object = parentNode.firstChild;\n    if (parentNode.childIndexCachedUpTo) {\n      const cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\n      object = cachedUpToNode.nextSibling;\n      currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\n    }\n    while (object) {\n      const node = this._node(object);\n      node.setCachedIndex(parentNode, currentIndex);\n      if (object === child) {\n        break;\n      }\n      ++currentIndex;\n      object = node.nextSibling;\n    }\n    parentNode.childIndexCachedUpTo = child;\n    return currentIndex;\n  }\n\n  /**\r\n   * Calculate the number of children.\r\n   *\r\n   * * `O(n)` where `n` is the amount of children\r\n   * * `O(1)` (amortized, if the tree is not modified)\r\n   *\r\n   * @method childrenCount\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} parent\r\n   * @return {Number}\r\n   */\n  childrenCount(parent) {\n    const parentNode = this._node(parent);\n    if (!parentNode.lastChild) {\n      return 0;\n    }\n    return this.index(parentNode.lastChild) + 1;\n  }\n\n  /**\r\n   * Compare the position of an object relative to another object. A bit set is returned:\r\n   *\r\n   * <ul>\r\n   *     <li>DISCONNECTED : 1</li>\r\n   *     <li>PRECEDING : 2</li>\r\n   *     <li>FOLLOWING : 4</li>\r\n   *     <li>CONTAINS : 8</li>\r\n   *     <li>CONTAINED_BY : 16</li>\r\n   * </ul>\r\n   *\r\n   * The semantics are the same as compareDocumentPosition in DOM, with the exception that\r\n   * DISCONNECTED never occurs with any other bit.\r\n   *\r\n   * where `n` and `m` are the amount of ancestors of `left` and `right`;\r\n   * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\r\n   *\r\n   * * `O(n + m + o)` (worst case)\r\n   * * `O(n + m)` (amortized, if the tree is not modified)\r\n   *\r\n   * @method compareTreePosition\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} left\r\n   * @param {Object} right\r\n   * @return {Number}\r\n   */\n  compareTreePosition(left, right) {\n    // In DOM terms:\n    // left = reference / context object\n    // right = other\n\n    if (left === right) {\n      return 0;\n    }\n\n    /* jshint -W016 */\n\n    const leftAncestors = [];\n    {\n      // inclusive\n      let leftAncestor = left;\n      while (leftAncestor) {\n        if (leftAncestor === right) {\n          return TreePosition.CONTAINS | TreePosition.PRECEDING;\n          // other is ancestor of reference\n        }\n\n        leftAncestors.push(leftAncestor);\n        leftAncestor = this.parent(leftAncestor);\n      }\n    }\n    const rightAncestors = [];\n    {\n      let rightAncestor = right;\n      while (rightAncestor) {\n        if (rightAncestor === left) {\n          return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\n        }\n        rightAncestors.push(rightAncestor);\n        rightAncestor = this.parent(rightAncestor);\n      }\n    }\n    const root = reverseArrayIndex(leftAncestors, 0);\n    if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\n      // note: unlike DOM, preceding / following is not set here\n      return TreePosition.DISCONNECTED;\n    }\n\n    // find the lowest common ancestor\n    let commonAncestorIndex = 0;\n    const ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\n    for (let i = 0; i < ancestorsMinLength; ++i) {\n      const leftAncestor = reverseArrayIndex(leftAncestors, i);\n      const rightAncestor = reverseArrayIndex(rightAncestors, i);\n      if (leftAncestor !== rightAncestor) {\n        break;\n      }\n      commonAncestorIndex = i;\n    }\n\n    // indexes within the common ancestor\n    const leftIndex = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\n    const rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\n    return rightIndex < leftIndex ? TreePosition.PRECEDING : TreePosition.FOLLOWING;\n  }\n\n  /**\r\n   * Remove the object from this tree.\r\n   * Has no effect if already removed.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method remove\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} removeObject\r\n   * @return {Object} removeObject\r\n   */\n  remove(removeObject) {\n    const removeNode = this._node(removeObject);\n    const parentNode = this._node(removeNode.parent);\n    const prevNode = this._node(removeNode.previousSibling);\n    const nextNode = this._node(removeNode.nextSibling);\n    if (parentNode) {\n      if (parentNode.firstChild === removeObject) {\n        parentNode.firstChild = removeNode.nextSibling;\n      }\n      if (parentNode.lastChild === removeObject) {\n        parentNode.lastChild = removeNode.previousSibling;\n      }\n    }\n    if (prevNode) {\n      prevNode.nextSibling = removeNode.nextSibling;\n    }\n    if (nextNode) {\n      nextNode.previousSibling = removeNode.previousSibling;\n    }\n    removeNode.parent = null;\n    removeNode.previousSibling = null;\n    removeNode.nextSibling = null;\n    removeNode.cachedIndex = -1;\n    removeNode.cachedIndexVersion = NaN;\n    if (parentNode) {\n      parentNode.childrenChanged();\n    }\n    return removeObject;\n  }\n\n  /**\r\n   * Insert the given object before the reference object.\r\n   * `newObject` is now the previous sibling of `referenceObject`.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method insertBefore\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} referenceObject\r\n   * @param {Object} newObject\r\n   * @throws {Error} If the newObject is already present in this SymbolTree\r\n   * @return {Object} newObject\r\n   */\n  insertBefore(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n    const prevNode = this._node(referenceNode.previousSibling);\n    const newNode = this._node(newObject);\n    const parentNode = this._node(referenceNode.parent);\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n    newNode.parent = referenceNode.parent;\n    newNode.previousSibling = referenceNode.previousSibling;\n    newNode.nextSibling = referenceObject;\n    referenceNode.previousSibling = newObject;\n    if (prevNode) {\n      prevNode.nextSibling = newObject;\n    }\n    if (parentNode && parentNode.firstChild === referenceObject) {\n      parentNode.firstChild = newObject;\n    }\n    if (parentNode) {\n      parentNode.childrenChanged();\n    }\n    return newObject;\n  }\n\n  /**\r\n   * Insert the given object after the reference object.\r\n   * `newObject` is now the next sibling of `referenceObject`.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method insertAfter\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} referenceObject\r\n   * @param {Object} newObject\r\n   * @throws {Error} If the newObject is already present in this SymbolTree\r\n   * @return {Object} newObject\r\n   */\n  insertAfter(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n    const nextNode = this._node(referenceNode.nextSibling);\n    const newNode = this._node(newObject);\n    const parentNode = this._node(referenceNode.parent);\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n    newNode.parent = referenceNode.parent;\n    newNode.previousSibling = referenceObject;\n    newNode.nextSibling = referenceNode.nextSibling;\n    referenceNode.nextSibling = newObject;\n    if (nextNode) {\n      nextNode.previousSibling = newObject;\n    }\n    if (parentNode && parentNode.lastChild === referenceObject) {\n      parentNode.lastChild = newObject;\n    }\n    if (parentNode) {\n      parentNode.childrenChanged();\n    }\n    return newObject;\n  }\n\n  /**\r\n   * Insert the given object as the first child of the given reference object.\r\n   * `newObject` is now the first child of `referenceObject`.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method prependChild\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} referenceObject\r\n   * @param {Object} newObject\r\n   * @throws {Error} If the newObject is already present in this SymbolTree\r\n   * @return {Object} newObject\r\n   */\n  prependChild(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n    const newNode = this._node(newObject);\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n    if (referenceNode.hasChildren) {\n      this.insertBefore(referenceNode.firstChild, newObject);\n    } else {\n      newNode.parent = referenceObject;\n      referenceNode.firstChild = newObject;\n      referenceNode.lastChild = newObject;\n      referenceNode.childrenChanged();\n    }\n    return newObject;\n  }\n\n  /**\r\n   * Insert the given object as the last child of the given reference object.\r\n   * `newObject` is now the last child of `referenceObject`.\r\n   *\r\n   * * `O(1)`\r\n   *\r\n   * @method appendChild\r\n   * @memberOf module:symbol-tree#\r\n   * @param {Object} referenceObject\r\n   * @param {Object} newObject\r\n   * @throws {Error} If the newObject is already present in this SymbolTree\r\n   * @return {Object} newObject\r\n   */\n  appendChild(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n    const newNode = this._node(newObject);\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n    if (referenceNode.hasChildren) {\n      this.insertAfter(referenceNode.lastChild, newObject);\n    } else {\n      newNode.parent = referenceObject;\n      referenceNode.firstChild = newObject;\n      referenceNode.lastChild = newObject;\n      referenceNode.childrenChanged();\n    }\n    return newObject;\n  }\n}\nmodule.exports = SymbolTree;\nSymbolTree.TreePosition = TreePosition;","map":{"version":3,"names":["SymbolTreeNode","require","TreePosition","TreeIterator","returnTrue","reverseArrayIndex","array","reverseIndex","length","SymbolTree","constructor","description","symbol","Symbol","initialize","object","_node","node","hasChildren","firstChild","lastChild","previousSibling","nextSibling","parent","lastInclusiveDescendant","current","preceding","options","treeRoot","root","following","skipChildren","childrenToArray","filter","thisArg","undefined","parentNode","index","setCachedIndex","call","push","ancestorsToArray","ancestor","treeToArray","childrenIterator","reverse","PREV","NEXT","previousSiblingsIterator","nextSiblingsIterator","ancestorsIterator","PARENT","treeIterator","PRECEDING","FOLLOWING","child","childNode","currentIndex","getCachedIndex","childIndexCachedUpTo","cachedUpToNode","childrenCount","compareTreePosition","left","right","leftAncestors","leftAncestor","CONTAINS","rightAncestors","rightAncestor","CONTAINED_BY","DISCONNECTED","commonAncestorIndex","ancestorsMinLength","Math","min","i","leftIndex","rightIndex","remove","removeObject","removeNode","prevNode","nextNode","cachedIndex","cachedIndexVersion","NaN","childrenChanged","insertBefore","referenceObject","newObject","referenceNode","newNode","isAttached","Error","insertAfter","prependChild","appendChild","module","exports"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/symbol-tree/lib/SymbolTree.js"],"sourcesContent":["'use strict';\r\n\r\n/**\r\n * @module symbol-tree\r\n * @author Joris van der Wel <joris@jorisvanderwel.com>\r\n */\r\n\r\nconst SymbolTreeNode = require('./SymbolTreeNode');\r\nconst TreePosition = require('./TreePosition');\r\nconst TreeIterator = require('./TreeIterator');\r\n\r\nfunction returnTrue() {\r\n        return true;\r\n}\r\n\r\nfunction reverseArrayIndex(array, reverseIndex) {\r\n        return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\r\n}\r\n\r\nclass SymbolTree {\r\n\r\n        /**\r\n         * @constructor\r\n         * @alias module:symbol-tree\r\n         * @param {string} [description='SymbolTree data'] Description used for the Symbol\r\n         */\r\n        constructor(description) {\r\n                this.symbol = Symbol(description || 'SymbolTree data');\r\n        }\r\n\r\n        /**\r\n         * You can use this function to (optionally) initialize an object right after its creation,\r\n         * to take advantage of V8's fast properties. Also useful if you would like to\r\n         * freeze your object.\r\n         *\r\n         * `O(1)`\r\n         *\r\n         * @method\r\n         * @alias module:symbol-tree#initialize\r\n         * @param {Object} object\r\n         * @return {Object} object\r\n         */\r\n        initialize(object) {\r\n                this._node(object);\r\n\r\n                return object;\r\n        }\r\n\r\n        _node(object) {\r\n                if (!object) {\r\n                        return null;\r\n                }\r\n\r\n                const node = object[this.symbol];\r\n\r\n                if (node) {\r\n                        return node;\r\n                }\r\n\r\n                return (object[this.symbol] = new SymbolTreeNode());\r\n        }\r\n\r\n        /**\r\n         * Returns `true` if the object has any children. Otherwise it returns `false`.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method hasChildren\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Boolean}\r\n         */\r\n        hasChildren(object) {\r\n                return this._node(object).hasChildren;\r\n        }\r\n\r\n        /**\r\n         * Returns the first child of the given object.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method firstChild\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        firstChild(object) {\r\n                return this._node(object).firstChild;\r\n        }\r\n\r\n        /**\r\n         * Returns the last child of the given object.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method lastChild\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        lastChild(object) {\r\n                return this._node(object).lastChild;\r\n        }\r\n\r\n        /**\r\n         * Returns the previous sibling of the given object.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method previousSibling\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        previousSibling(object) {\r\n                return this._node(object).previousSibling;\r\n        }\r\n\r\n        /**\r\n         * Returns the next sibling of the given object.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method nextSibling\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        nextSibling(object) {\r\n                return this._node(object).nextSibling;\r\n        }\r\n\r\n        /**\r\n         * Return the parent of the given object.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method parent\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        parent(object) {\r\n                return this._node(object).parent;\r\n        }\r\n\r\n        /**\r\n         * Find the inclusive descendant that is last in tree order of the given object.\r\n         *\r\n         * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\r\n         *\r\n         * @method lastInclusiveDescendant\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object}\r\n         */\r\n        lastInclusiveDescendant(object) {\r\n                let lastChild;\r\n                let current = object;\r\n\r\n                while ((lastChild = this._node(current).lastChild)) {\r\n                        current = lastChild;\r\n                }\r\n\r\n                return current;\r\n        }\r\n\r\n        /**\r\n         * Find the preceding object (A) of the given object (B).\r\n         * An object A is preceding an object B if A and B are in the same tree\r\n         * and A comes before B in tree order.\r\n         *\r\n         * * `O(n)` (worst case)\r\n         * * `O(1)` (amortized when walking the entire tree)\r\n         *\r\n         * @method preceding\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @param {Object} [options]\r\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\r\n         *        of the return value (or else null is returned). This check _assumes_\r\n         *        that `root` is also an inclusive ancestor of the given `object`\r\n         * @return {?Object}\r\n         */\r\n        preceding(object, options) {\r\n                const treeRoot = options && options.root;\r\n\r\n                if (object === treeRoot) {\r\n                        return null;\r\n                }\r\n\r\n                const previousSibling = this._node(object).previousSibling;\r\n\r\n                if (previousSibling) {\r\n                        return this.lastInclusiveDescendant(previousSibling);\r\n                }\r\n\r\n                // if there is no previous sibling return the parent (might be null)\r\n                return this._node(object).parent;\r\n        }\r\n\r\n        /**\r\n         * Find the following object (A) of the given object (B).\r\n         * An object A is following an object B if A and B are in the same tree\r\n         * and A comes after B in tree order.\r\n         *\r\n         * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\r\n         * * `O(1)` (amortized when walking the entire tree)\r\n         *\r\n         * @method following\r\n         * @memberOf module:symbol-tree#\r\n         * @param {!Object} object\r\n         * @param {Object} [options]\r\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\r\n         *        of the return value (or else null is returned). This check _assumes_\r\n         *        that `root` is also an inclusive ancestor of the given `object`\r\n         * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\r\n         * @return {?Object}\r\n         */\r\n        following(object, options) {\r\n                const treeRoot = options && options.root;\r\n                const skipChildren = options && options.skipChildren;\r\n\r\n                const firstChild = !skipChildren && this._node(object).firstChild;\r\n\r\n                if (firstChild) {\r\n                        return firstChild;\r\n                }\r\n\r\n                let current = object;\r\n\r\n                do {\r\n                        if (current === treeRoot) {\r\n                                return null;\r\n                        }\r\n\r\n                        const nextSibling = this._node(current).nextSibling;\r\n\r\n                        if (nextSibling) {\r\n                                return nextSibling;\r\n                        }\r\n\r\n                        current = this._node(current).parent;\r\n                } while (current);\r\n\r\n                return null;\r\n        }\r\n\r\n        /**\r\n         * Append all children of the given object to an array.\r\n         *\r\n         * * `O(n)` where `n` is the amount of children of the given `parent`\r\n         *\r\n         * @method childrenToArray\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} parent\r\n         * @param {Object} [options]\r\n         * @param {Object[]} [options.array=[]]\r\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n         *                            Invoked with arguments (object). Should return `true` if an object\r\n         *                            is to be included.\r\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n         * @return {Object[]}\r\n         */\r\n        childrenToArray(parent, options) {\r\n                const array   = (options && options.array) || [];\r\n                const filter  = (options && options.filter) || returnTrue;\r\n                const thisArg = (options && options.thisArg) || undefined;\r\n\r\n                const parentNode = this._node(parent);\r\n                let object = parentNode.firstChild;\r\n                let index = 0;\r\n\r\n                while (object) {\r\n                        const node = this._node(object);\r\n                        node.setCachedIndex(parentNode, index);\r\n\r\n                        if (filter.call(thisArg, object)) {\r\n                                array.push(object);\r\n                        }\r\n\r\n                        object = node.nextSibling;\r\n                        ++index;\r\n                }\r\n\r\n                return array;\r\n        }\r\n\r\n        /**\r\n         * Append all inclusive ancestors of the given object to an array.\r\n         *\r\n         * * `O(n)` where `n` is the amount of ancestors of the given `object`\r\n         *\r\n         * @method ancestorsToArray\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @param {Object} [options]\r\n         * @param {Object[]} [options.array=[]]\r\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n         *                            Invoked with arguments (object). Should return `true` if an object\r\n         *                            is to be included.\r\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n         * @return {Object[]}\r\n         */\r\n        ancestorsToArray(object, options) {\r\n                const array   = (options && options.array) || [];\r\n                const filter  = (options && options.filter) || returnTrue;\r\n                const thisArg = (options && options.thisArg) || undefined;\r\n\r\n                let ancestor = object;\r\n\r\n                while (ancestor) {\r\n                        if (filter.call(thisArg, ancestor)) {\r\n                                array.push(ancestor);\r\n                        }\r\n                        ancestor = this._node(ancestor).parent;\r\n                }\r\n\r\n                return array;\r\n        }\r\n\r\n        /**\r\n         * Append all descendants of the given object to an array (in tree order).\r\n         *\r\n         * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\r\n         *\r\n         * @method treeToArray\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} root\r\n         * @param {Object} [options]\r\n         * @param {Object[]} [options.array=[]]\r\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\r\n         *                            Invoked with arguments (object). Should return `true` if an object\r\n         *                            is to be included.\r\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\r\n         * @return {Object[]}\r\n         */\r\n        treeToArray(root, options) {\r\n                const array   = (options && options.array) || [];\r\n                const filter  = (options && options.filter) || returnTrue;\r\n                const thisArg = (options && options.thisArg) || undefined;\r\n\r\n                let object = root;\r\n\r\n                while (object) {\r\n                        if (filter.call(thisArg, object)) {\r\n                                array.push(object);\r\n                        }\r\n                        object = this.following(object, {root: root});\r\n                }\r\n\r\n                return array;\r\n        }\r\n\r\n        /**\r\n         * Iterate over all children of the given object\r\n         *\r\n         * * `O(1)` for a single iteration\r\n         *\r\n         * @method childrenIterator\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} parent\r\n         * @param {Object} [options]\r\n         * @param {Boolean} [options.reverse=false]\r\n         * @return {Object} An iterable iterator (ES6)\r\n         */\r\n        childrenIterator(parent, options) {\r\n                const reverse = options && options.reverse;\r\n                const parentNode = this._node(parent);\r\n\r\n                return new TreeIterator(\r\n                        this,\r\n                        parent,\r\n                        reverse ? parentNode.lastChild : parentNode.firstChild,\r\n                        reverse ? TreeIterator.PREV : TreeIterator.NEXT\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Iterate over all the previous siblings of the given object. (in reverse tree order)\r\n         *\r\n         * * `O(1)` for a single iteration\r\n         *\r\n         * @method previousSiblingsIterator\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object} An iterable iterator (ES6)\r\n         */\r\n        previousSiblingsIterator(object) {\r\n                return new TreeIterator(\r\n                        this,\r\n                        object,\r\n                        this._node(object).previousSibling,\r\n                        TreeIterator.PREV\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Iterate over all the next siblings of the given object. (in tree order)\r\n         *\r\n         * * `O(1)` for a single iteration\r\n         *\r\n         * @method nextSiblingsIterator\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object} An iterable iterator (ES6)\r\n         */\r\n        nextSiblingsIterator(object) {\r\n                return new TreeIterator(\r\n                        this,\r\n                        object,\r\n                        this._node(object).nextSibling,\r\n                        TreeIterator.NEXT\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Iterate over all inclusive ancestors of the given object\r\n         *\r\n         * * `O(1)` for a single iteration\r\n         *\r\n         * @method ancestorsIterator\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} object\r\n         * @return {Object} An iterable iterator (ES6)\r\n         */\r\n        ancestorsIterator(object) {\r\n                return new TreeIterator(\r\n                        this,\r\n                        object,\r\n                        object,\r\n                        TreeIterator.PARENT\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Iterate over all descendants of the given object (in tree order).\r\n         *\r\n         * Where `n` is the amount of objects in the sub-tree of the given `root`:\r\n         *\r\n         * * `O(n)` (worst case for a single iteration)\r\n         * * `O(n)` (amortized, when completing the iterator)\r\n         *\r\n         * @method treeIterator\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} root\r\n         * @param {Object} options\r\n         * @param {Boolean} [options.reverse=false]\r\n         * @return {Object} An iterable iterator (ES6)\r\n         */\r\n        treeIterator(root, options) {\r\n                const reverse = options && options.reverse;\r\n\r\n                return new TreeIterator(\r\n                        this,\r\n                        root,\r\n                        reverse ? this.lastInclusiveDescendant(root) : root,\r\n                        reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Find the index of the given object (the number of preceding siblings).\r\n         *\r\n         * * `O(n)` where `n` is the amount of preceding siblings\r\n         * * `O(1)` (amortized, if the tree is not modified)\r\n         *\r\n         * @method index\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} child\r\n         * @return {Number} The number of preceding siblings, or -1 if the object has no parent\r\n         */\r\n        index(child) {\r\n                const childNode = this._node(child);\r\n                const parentNode = this._node(childNode.parent);\r\n\r\n                if (!parentNode) {\r\n                        // In principal, you could also find out the number of preceding siblings\r\n                        // for objects that do not have a parent. This method limits itself only to\r\n                        // objects that have a parent because that lets us optimize more.\r\n                        return -1;\r\n                }\r\n\r\n                let currentIndex = childNode.getCachedIndex(parentNode);\r\n\r\n                if (currentIndex >= 0) {\r\n                        return currentIndex;\r\n                }\r\n\r\n                currentIndex = 0;\r\n                let object = parentNode.firstChild;\r\n\r\n                if (parentNode.childIndexCachedUpTo) {\r\n                        const cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\r\n                        object = cachedUpToNode.nextSibling;\r\n                        currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\r\n                }\r\n\r\n                while (object) {\r\n                        const node = this._node(object);\r\n                        node.setCachedIndex(parentNode, currentIndex);\r\n\r\n                        if (object === child) {\r\n                                break;\r\n                        }\r\n\r\n                        ++currentIndex;\r\n                        object = node.nextSibling;\r\n                }\r\n\r\n                parentNode.childIndexCachedUpTo = child;\r\n\r\n                return currentIndex;\r\n        }\r\n\r\n        /**\r\n         * Calculate the number of children.\r\n         *\r\n         * * `O(n)` where `n` is the amount of children\r\n         * * `O(1)` (amortized, if the tree is not modified)\r\n         *\r\n         * @method childrenCount\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} parent\r\n         * @return {Number}\r\n         */\r\n        childrenCount(parent) {\r\n                const parentNode = this._node(parent);\r\n\r\n                if (!parentNode.lastChild) {\r\n                        return 0;\r\n                }\r\n\r\n                return this.index(parentNode.lastChild) + 1;\r\n        }\r\n\r\n        /**\r\n         * Compare the position of an object relative to another object. A bit set is returned:\r\n         *\r\n         * <ul>\r\n         *     <li>DISCONNECTED : 1</li>\r\n         *     <li>PRECEDING : 2</li>\r\n         *     <li>FOLLOWING : 4</li>\r\n         *     <li>CONTAINS : 8</li>\r\n         *     <li>CONTAINED_BY : 16</li>\r\n         * </ul>\r\n         *\r\n         * The semantics are the same as compareDocumentPosition in DOM, with the exception that\r\n         * DISCONNECTED never occurs with any other bit.\r\n         *\r\n         * where `n` and `m` are the amount of ancestors of `left` and `right`;\r\n         * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\r\n         *\r\n         * * `O(n + m + o)` (worst case)\r\n         * * `O(n + m)` (amortized, if the tree is not modified)\r\n         *\r\n         * @method compareTreePosition\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} left\r\n         * @param {Object} right\r\n         * @return {Number}\r\n         */\r\n        compareTreePosition(left, right) {\r\n                // In DOM terms:\r\n                // left = reference / context object\r\n                // right = other\r\n\r\n                if (left === right) {\r\n                        return 0;\r\n                }\r\n\r\n                /* jshint -W016 */\r\n\r\n                const leftAncestors = []; { // inclusive\r\n                        let leftAncestor = left;\r\n\r\n                        while (leftAncestor) {\r\n                                if (leftAncestor === right) {\r\n                                        return TreePosition.CONTAINS | TreePosition.PRECEDING;\r\n                                        // other is ancestor of reference\r\n                                }\r\n\r\n                                leftAncestors.push(leftAncestor);\r\n                                leftAncestor = this.parent(leftAncestor);\r\n                        }\r\n                }\r\n\r\n\r\n                const rightAncestors = []; {\r\n                        let rightAncestor = right;\r\n\r\n                        while (rightAncestor) {\r\n                                if (rightAncestor === left) {\r\n                                        return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\r\n                                }\r\n\r\n                                rightAncestors.push(rightAncestor);\r\n                                rightAncestor = this.parent(rightAncestor);\r\n                        }\r\n                }\r\n\r\n\r\n                const root = reverseArrayIndex(leftAncestors, 0);\r\n\r\n                if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\r\n                        // note: unlike DOM, preceding / following is not set here\r\n                        return TreePosition.DISCONNECTED;\r\n                }\r\n\r\n                // find the lowest common ancestor\r\n                let commonAncestorIndex = 0;\r\n                const ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\r\n\r\n                for (let i = 0; i < ancestorsMinLength; ++i) {\r\n                        const leftAncestor  = reverseArrayIndex(leftAncestors, i);\r\n                        const rightAncestor = reverseArrayIndex(rightAncestors, i);\r\n\r\n                        if (leftAncestor !== rightAncestor) {\r\n                                break;\r\n                        }\r\n\r\n                        commonAncestorIndex = i;\r\n                }\r\n\r\n                // indexes within the common ancestor\r\n                const leftIndex  = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\r\n                const rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\r\n\r\n                return rightIndex < leftIndex\r\n                        ? TreePosition.PRECEDING\r\n                        : TreePosition.FOLLOWING;\r\n        }\r\n\r\n        /**\r\n         * Remove the object from this tree.\r\n         * Has no effect if already removed.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method remove\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} removeObject\r\n         * @return {Object} removeObject\r\n         */\r\n        remove(removeObject) {\r\n                const removeNode = this._node(removeObject);\r\n                const parentNode = this._node(removeNode.parent);\r\n                const prevNode = this._node(removeNode.previousSibling);\r\n                const nextNode = this._node(removeNode.nextSibling);\r\n\r\n                if (parentNode) {\r\n                        if (parentNode.firstChild === removeObject) {\r\n                                parentNode.firstChild = removeNode.nextSibling;\r\n                        }\r\n\r\n                        if (parentNode.lastChild === removeObject) {\r\n                                parentNode.lastChild = removeNode.previousSibling;\r\n                        }\r\n                }\r\n\r\n                if (prevNode) {\r\n                        prevNode.nextSibling = removeNode.nextSibling;\r\n                }\r\n\r\n                if (nextNode) {\r\n                        nextNode.previousSibling = removeNode.previousSibling;\r\n                }\r\n\r\n                removeNode.parent = null;\r\n                removeNode.previousSibling = null;\r\n                removeNode.nextSibling = null;\r\n                removeNode.cachedIndex = -1;\r\n                removeNode.cachedIndexVersion = NaN;\r\n\r\n                if (parentNode) {\r\n                        parentNode.childrenChanged();\r\n                }\r\n\r\n                return removeObject;\r\n        }\r\n\r\n        /**\r\n         * Insert the given object before the reference object.\r\n         * `newObject` is now the previous sibling of `referenceObject`.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method insertBefore\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} referenceObject\r\n         * @param {Object} newObject\r\n         * @throws {Error} If the newObject is already present in this SymbolTree\r\n         * @return {Object} newObject\r\n         */\r\n        insertBefore(referenceObject, newObject) {\r\n                const referenceNode = this._node(referenceObject);\r\n                const prevNode = this._node(referenceNode.previousSibling);\r\n                const newNode = this._node(newObject);\r\n                const parentNode = this._node(referenceNode.parent);\r\n\r\n                if (newNode.isAttached) {\r\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\r\n                }\r\n\r\n                newNode.parent = referenceNode.parent;\r\n                newNode.previousSibling = referenceNode.previousSibling;\r\n                newNode.nextSibling = referenceObject;\r\n                referenceNode.previousSibling = newObject;\r\n\r\n                if (prevNode) {\r\n                        prevNode.nextSibling = newObject;\r\n                }\r\n\r\n                if (parentNode && parentNode.firstChild === referenceObject) {\r\n                        parentNode.firstChild = newObject;\r\n                }\r\n\r\n                if (parentNode) {\r\n                        parentNode.childrenChanged();\r\n                }\r\n\r\n                return newObject;\r\n        }\r\n\r\n        /**\r\n         * Insert the given object after the reference object.\r\n         * `newObject` is now the next sibling of `referenceObject`.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method insertAfter\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} referenceObject\r\n         * @param {Object} newObject\r\n         * @throws {Error} If the newObject is already present in this SymbolTree\r\n         * @return {Object} newObject\r\n         */\r\n        insertAfter(referenceObject, newObject) {\r\n                const referenceNode = this._node(referenceObject);\r\n                const nextNode = this._node(referenceNode.nextSibling);\r\n                const newNode = this._node(newObject);\r\n                const parentNode = this._node(referenceNode.parent);\r\n\r\n                if (newNode.isAttached) {\r\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\r\n                }\r\n\r\n                newNode.parent = referenceNode.parent;\r\n                newNode.previousSibling = referenceObject;\r\n                newNode.nextSibling = referenceNode.nextSibling;\r\n                referenceNode.nextSibling = newObject;\r\n\r\n                if (nextNode) {\r\n                        nextNode.previousSibling = newObject;\r\n                }\r\n\r\n                if (parentNode && parentNode.lastChild === referenceObject) {\r\n                        parentNode.lastChild = newObject;\r\n                }\r\n\r\n                if (parentNode) {\r\n                        parentNode.childrenChanged();\r\n                }\r\n\r\n                return newObject;\r\n        }\r\n\r\n        /**\r\n         * Insert the given object as the first child of the given reference object.\r\n         * `newObject` is now the first child of `referenceObject`.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method prependChild\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} referenceObject\r\n         * @param {Object} newObject\r\n         * @throws {Error} If the newObject is already present in this SymbolTree\r\n         * @return {Object} newObject\r\n         */\r\n        prependChild(referenceObject, newObject) {\r\n                const referenceNode = this._node(referenceObject);\r\n                const newNode = this._node(newObject);\r\n\r\n                if (newNode.isAttached) {\r\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\r\n                }\r\n\r\n                if (referenceNode.hasChildren) {\r\n                        this.insertBefore(referenceNode.firstChild, newObject);\r\n                }\r\n                else {\r\n                        newNode.parent = referenceObject;\r\n                        referenceNode.firstChild = newObject;\r\n                        referenceNode.lastChild = newObject;\r\n                        referenceNode.childrenChanged();\r\n                }\r\n\r\n                return newObject;\r\n        }\r\n\r\n        /**\r\n         * Insert the given object as the last child of the given reference object.\r\n         * `newObject` is now the last child of `referenceObject`.\r\n         *\r\n         * * `O(1)`\r\n         *\r\n         * @method appendChild\r\n         * @memberOf module:symbol-tree#\r\n         * @param {Object} referenceObject\r\n         * @param {Object} newObject\r\n         * @throws {Error} If the newObject is already present in this SymbolTree\r\n         * @return {Object} newObject\r\n         */\r\n        appendChild(referenceObject, newObject) {\r\n                const referenceNode = this._node(referenceObject);\r\n                const newNode = this._node(newObject);\r\n\r\n                if (newNode.isAttached) {\r\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\r\n                }\r\n\r\n                if (referenceNode.hasChildren) {\r\n                        this.insertAfter(referenceNode.lastChild, newObject);\r\n                }\r\n                else {\r\n                        newNode.parent = referenceObject;\r\n                        referenceNode.firstChild = newObject;\r\n                        referenceNode.lastChild = newObject;\r\n                        referenceNode.childrenChanged();\r\n                }\r\n\r\n                return newObject;\r\n        }\r\n}\r\n\r\nmodule.exports = SymbolTree;\r\nSymbolTree.TreePosition = TreePosition;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}