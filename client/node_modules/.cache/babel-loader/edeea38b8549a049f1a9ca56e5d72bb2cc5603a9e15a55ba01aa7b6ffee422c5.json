{"ast":null,"code":"/*\r\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\r\n  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>\r\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\r\n  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\r\n  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>\r\n  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>\r\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\r\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\r\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\r\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\r\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\r\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\r\n\r\n  Redistribution and use in source and binary forms, with or without\r\n  modification, are permitted provided that the following conditions are met:\r\n\r\n    * Redistributions of source code must retain the above copyright\r\n      notice, this list of conditions and the following disclaimer.\r\n    * Redistributions in binary form must reproduce the above copyright\r\n      notice, this list of conditions and the following disclaimer in the\r\n      documentation and/or other materials provided with the distribution.\r\n\r\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\n\n/*global exports:true, require:true, global:true*/\n(function () {\n  'use strict';\n\n  var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;\n  estraverse = require('estraverse');\n  esutils = require('esutils');\n  Syntax = estraverse.Syntax;\n\n  // Generation is done by generateExpression.\n  function isExpression(node) {\n    return CodeGenerator.Expression.hasOwnProperty(node.type);\n  }\n\n  // Generation is done by generateStatement.\n  function isStatement(node) {\n    return CodeGenerator.Statement.hasOwnProperty(node.type);\n  }\n  Precedence = {\n    Sequence: 0,\n    Yield: 1,\n    Assignment: 1,\n    Conditional: 2,\n    ArrowFunction: 2,\n    LogicalOR: 3,\n    LogicalAND: 4,\n    BitwiseOR: 5,\n    BitwiseXOR: 6,\n    BitwiseAND: 7,\n    Equality: 8,\n    Relational: 9,\n    BitwiseSHIFT: 10,\n    Additive: 11,\n    Multiplicative: 12,\n    Exponentiation: 13,\n    Await: 14,\n    Unary: 14,\n    Postfix: 15,\n    OptionalChaining: 16,\n    Call: 17,\n    New: 18,\n    TaggedTemplate: 19,\n    Member: 20,\n    Primary: 21\n  };\n  BinaryPrecedence = {\n    '||': Precedence.LogicalOR,\n    '&&': Precedence.LogicalAND,\n    '|': Precedence.BitwiseOR,\n    '^': Precedence.BitwiseXOR,\n    '&': Precedence.BitwiseAND,\n    '==': Precedence.Equality,\n    '!=': Precedence.Equality,\n    '===': Precedence.Equality,\n    '!==': Precedence.Equality,\n    'is': Precedence.Equality,\n    'isnt': Precedence.Equality,\n    '<': Precedence.Relational,\n    '>': Precedence.Relational,\n    '<=': Precedence.Relational,\n    '>=': Precedence.Relational,\n    'in': Precedence.Relational,\n    'instanceof': Precedence.Relational,\n    '<<': Precedence.BitwiseSHIFT,\n    '>>': Precedence.BitwiseSHIFT,\n    '>>>': Precedence.BitwiseSHIFT,\n    '+': Precedence.Additive,\n    '-': Precedence.Additive,\n    '*': Precedence.Multiplicative,\n    '%': Precedence.Multiplicative,\n    '/': Precedence.Multiplicative,\n    '**': Precedence.Exponentiation\n  };\n\n  //Flags\n  var F_ALLOW_IN = 1,\n    F_ALLOW_CALL = 1 << 1,\n    F_ALLOW_UNPARATH_NEW = 1 << 2,\n    F_FUNC_BODY = 1 << 3,\n    F_DIRECTIVE_CTX = 1 << 4,\n    F_SEMICOLON_OPT = 1 << 5;\n\n  //Expression flag sets\n  //NOTE: Flag order:\n  // F_ALLOW_IN\n  // F_ALLOW_CALL\n  // F_ALLOW_UNPARATH_NEW\n  var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n    E_TTF = F_ALLOW_IN | F_ALLOW_CALL,\n    E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n    E_TFF = F_ALLOW_IN,\n    E_FFT = F_ALLOW_UNPARATH_NEW,\n    E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;\n\n  //Statement flag sets\n  //NOTE: Flag order:\n  // F_ALLOW_IN\n  // F_FUNC_BODY\n  // F_DIRECTIVE_CTX\n  // F_SEMICOLON_OPT\n  var S_TFFF = F_ALLOW_IN,\n    S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,\n    S_FFFF = 0x00,\n    S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,\n    S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\n  function getDefaultOptions() {\n    // default options\n    return {\n      indent: null,\n      base: null,\n      parse: null,\n      comment: false,\n      format: {\n        indent: {\n          style: '    ',\n          base: 0,\n          adjustMultilineComment: false\n        },\n        newline: '\\n',\n        space: ' ',\n        json: false,\n        renumber: false,\n        hexadecimal: false,\n        quotes: 'single',\n        escapeless: false,\n        compact: false,\n        parentheses: true,\n        semicolons: true,\n        safeConcatenation: false,\n        preserveBlankLines: false\n      },\n      moz: {\n        comprehensionExpressionStartsWithAssignment: false,\n        starlessGenerator: false\n      },\n      sourceMap: null,\n      sourceMapRoot: null,\n      sourceMapWithCode: false,\n      directive: false,\n      raw: true,\n      verbatim: null,\n      sourceCode: null\n    };\n  }\n  function stringRepeat(str, num) {\n    var result = '';\n    for (num |= 0; num > 0; num >>>= 1, str += str) {\n      if (num & 1) {\n        result += str;\n      }\n    }\n    return result;\n  }\n  function hasLineTerminator(str) {\n    return /[\\r\\n]/g.test(str);\n  }\n  function endsWithLineTerminator(str) {\n    var len = str.length;\n    return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\n  }\n  function merge(target, override) {\n    var key;\n    for (key in override) {\n      if (override.hasOwnProperty(key)) {\n        target[key] = override[key];\n      }\n    }\n    return target;\n  }\n  function updateDeeply(target, override) {\n    var key, val;\n    function isHashObject(target) {\n      return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);\n    }\n    for (key in override) {\n      if (override.hasOwnProperty(key)) {\n        val = override[key];\n        if (isHashObject(val)) {\n          if (isHashObject(target[key])) {\n            updateDeeply(target[key], val);\n          } else {\n            target[key] = updateDeeply({}, val);\n          }\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n    return target;\n  }\n  function generateNumber(value) {\n    var result, point, temp, exponent, pos;\n    if (value !== value) {\n      throw new Error('Numeric literal whose value is NaN');\n    }\n    if (value < 0 || value === 0 && 1 / value < 0) {\n      throw new Error('Numeric literal whose value is negative');\n    }\n    if (value === 1 / 0) {\n      return json ? 'null' : renumber ? '1e400' : '1e+400';\n    }\n    result = '' + value;\n    if (!renumber || result.length < 3) {\n      return result;\n    }\n    point = result.indexOf('.');\n    if (!json && result.charCodeAt(0) === 0x30 /* 0 */ && point === 1) {\n      point = 0;\n      result = result.slice(1);\n    }\n    temp = result;\n    result = result.replace('e+', 'e');\n    exponent = 0;\n    if ((pos = temp.indexOf('e')) > 0) {\n      exponent = +temp.slice(pos + 1);\n      temp = temp.slice(0, pos);\n    }\n    if (point >= 0) {\n      exponent -= temp.length - point - 1;\n      temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';\n    }\n    pos = 0;\n    while (temp.charCodeAt(temp.length + pos - 1) === 0x30 /* 0 */) {\n      --pos;\n    }\n    if (pos !== 0) {\n      exponent -= pos;\n      temp = temp.slice(0, pos);\n    }\n    if (exponent !== 0) {\n      temp += 'e' + exponent;\n    }\n    if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value) {\n      result = temp;\n    }\n    return result;\n  }\n\n  // Generate valid RegExp expression.\n  // This function is based on https://github.com/Constellation/iv Engine\n\n  function escapeRegExpCharacter(ch, previousIsBackslash) {\n    // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n    if ((ch & ~1) === 0x2028) {\n      return (previousIsBackslash ? 'u' : '\\\\u') + (ch === 0x2028 ? '2028' : '2029');\n    } else if (ch === 10 || ch === 13) {\n      // \\n, \\r\n      return (previousIsBackslash ? '' : '\\\\') + (ch === 10 ? 'n' : 'r');\n    }\n    return String.fromCharCode(ch);\n  }\n  function generateRegExp(reg) {\n    var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n    result = reg.toString();\n    if (reg.source) {\n      // extract flag from toString result\n      match = result.match(/\\/([^/]*)$/);\n      if (!match) {\n        return result;\n      }\n      flags = match[1];\n      result = '';\n      characterInBrack = false;\n      previousIsBackslash = false;\n      for (i = 0, iz = reg.source.length; i < iz; ++i) {\n        ch = reg.source.charCodeAt(i);\n        if (!previousIsBackslash) {\n          if (characterInBrack) {\n            if (ch === 93) {\n              // ]\n              characterInBrack = false;\n            }\n          } else {\n            if (ch === 47) {\n              // /\n              result += '\\\\';\n            } else if (ch === 91) {\n              // [\n              characterInBrack = true;\n            }\n          }\n          result += escapeRegExpCharacter(ch, previousIsBackslash);\n          previousIsBackslash = ch === 92; // \\\n        } else {\n          // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n          result += escapeRegExpCharacter(ch, previousIsBackslash);\n          // prevent like /\\\\[/]/\n          previousIsBackslash = false;\n        }\n      }\n      return '/' + result + '/' + flags;\n    }\n    return result;\n  }\n  function escapeAllowedCharacter(code, next) {\n    var hex;\n    if (code === 0x08 /* \\b */) {\n      return '\\\\b';\n    }\n    if (code === 0x0C /* \\f */) {\n      return '\\\\f';\n    }\n    if (code === 0x09 /* \\t */) {\n      return '\\\\t';\n    }\n    hex = code.toString(16).toUpperCase();\n    if (json || code > 0xFF) {\n      return '\\\\u' + '0000'.slice(hex.length) + hex;\n    } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {\n      return '\\\\0';\n    } else if (code === 0x000B /* \\v */) {\n      // '\\v'\n      return '\\\\x0B';\n    } else {\n      return '\\\\x' + '00'.slice(hex.length) + hex;\n    }\n  }\n  function escapeDisallowedCharacter(code) {\n    if (code === 0x5C /* \\ */) {\n      return '\\\\\\\\';\n    }\n    if (code === 0x0A /* \\n */) {\n      return '\\\\n';\n    }\n    if (code === 0x0D /* \\r */) {\n      return '\\\\r';\n    }\n    if (code === 0x2028) {\n      return '\\\\u2028';\n    }\n    if (code === 0x2029) {\n      return '\\\\u2029';\n    }\n    throw new Error('Incorrectly classified character');\n  }\n  function escapeDirective(str) {\n    var i, iz, code, quote;\n    quote = quotes === 'double' ? '\"' : '\\'';\n    for (i = 0, iz = str.length; i < iz; ++i) {\n      code = str.charCodeAt(i);\n      if (code === 0x27 /* ' */) {\n        quote = '\"';\n        break;\n      } else if (code === 0x22 /* \" */) {\n        quote = '\\'';\n        break;\n      } else if (code === 0x5C /* \\ */) {\n        ++i;\n      }\n    }\n    return quote + str + quote;\n  }\n  function escapeString(str) {\n    var result = '',\n      i,\n      len,\n      code,\n      singleQuotes = 0,\n      doubleQuotes = 0,\n      single,\n      quote;\n    for (i = 0, len = str.length; i < len; ++i) {\n      code = str.charCodeAt(i);\n      if (code === 0x27 /* ' */) {\n        ++singleQuotes;\n      } else if (code === 0x22 /* \" */) {\n        ++doubleQuotes;\n      } else if (code === 0x2F /* / */ && json) {\n        result += '\\\\';\n      } else if (esutils.code.isLineTerminator(code) || code === 0x5C /* \\ */) {\n        result += escapeDisallowedCharacter(code);\n        continue;\n      } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20 /* SP */ || !json && !escapeless && (code < 0x20 /* SP */ || code > 0x7E /* ~ */))) {\n        result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\n        continue;\n      }\n      result += String.fromCharCode(code);\n    }\n    single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);\n    quote = single ? '\\'' : '\"';\n    if (!(single ? singleQuotes : doubleQuotes)) {\n      return quote + result + quote;\n    }\n    str = result;\n    result = quote;\n    for (i = 0, len = str.length; i < len; ++i) {\n      code = str.charCodeAt(i);\n      if (code === 0x27 /* ' */ && single || code === 0x22 /* \" */ && !single) {\n        result += '\\\\';\n      }\n      result += String.fromCharCode(code);\n    }\n    return result + quote;\n  }\n\n  /**\r\n   * flatten an array to a string, where the array can contain\r\n   * either strings or nested arrays\r\n   */\n  function flattenToString(arr) {\n    var i,\n      iz,\n      elem,\n      result = '';\n    for (i = 0, iz = arr.length; i < iz; ++i) {\n      elem = arr[i];\n      result += Array.isArray(elem) ? flattenToString(elem) : elem;\n    }\n    return result;\n  }\n\n  /**\r\n   * convert generated to a SourceNode when source maps are enabled.\r\n   */\n  function toSourceNodeWhenNeeded(generated, node) {\n    if (!sourceMap) {\n      // with no source maps, generated is either an\n      // array or a string.  if an array, flatten it.\n      // if a string, just return it\n      if (Array.isArray(generated)) {\n        return flattenToString(generated);\n      } else {\n        return generated;\n      }\n    }\n    if (node == null) {\n      if (generated instanceof SourceNode) {\n        return generated;\n      } else {\n        node = {};\n      }\n    }\n    if (node.loc == null) {\n      return new SourceNode(null, null, sourceMap, generated, node.name || null);\n    }\n    return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);\n  }\n  function noEmptySpace() {\n    return space ? space : ' ';\n  }\n  function join(left, right) {\n    var leftSource, rightSource, leftCharCode, rightCharCode;\n    leftSource = toSourceNodeWhenNeeded(left).toString();\n    if (leftSource.length === 0) {\n      return [right];\n    }\n    rightSource = toSourceNodeWhenNeeded(right).toString();\n    if (rightSource.length === 0) {\n      return [left];\n    }\n    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n    rightCharCode = rightSource.charCodeAt(0);\n    if ((leftCharCode === 0x2B /* + */ || leftCharCode === 0x2D /* - */) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 0x2F /* / */ && rightCharCode === 0x69 /* i */) {\n      // infix word operators all start with `i`\n      return [left, noEmptySpace(), right];\n    } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {\n      return [left, right];\n    }\n    return [left, space, right];\n  }\n  function addIndent(stmt) {\n    return [base, stmt];\n  }\n  function withIndent(fn) {\n    var previousBase;\n    previousBase = base;\n    base += indent;\n    fn(base);\n    base = previousBase;\n  }\n  function calculateSpaces(str) {\n    var i;\n    for (i = str.length - 1; i >= 0; --i) {\n      if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\n        break;\n      }\n    }\n    return str.length - 1 - i;\n  }\n  function adjustMultilineComment(value, specialBase) {\n    var array, i, len, line, j, spaces, previousBase, sn;\n    array = value.split(/\\r\\n|[\\r\\n]/);\n    spaces = Number.MAX_VALUE;\n\n    // first line doesn't have indentation\n    for (i = 1, len = array.length; i < len; ++i) {\n      line = array[i];\n      j = 0;\n      while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {\n        ++j;\n      }\n      if (spaces > j) {\n        spaces = j;\n      }\n    }\n    if (typeof specialBase !== 'undefined') {\n      // pattern like\n      // {\n      //   var t = 20;  /*\n      //                 * this is comment\n      //                 */\n      // }\n      previousBase = base;\n      if (array[1][spaces] === '*') {\n        specialBase += ' ';\n      }\n      base = specialBase;\n    } else {\n      if (spaces & 1) {\n        // /*\n        //  *\n        //  */\n        // If spaces are odd number, above pattern is considered.\n        // We waste 1 space.\n        --spaces;\n      }\n      previousBase = base;\n    }\n    for (i = 1, len = array.length; i < len; ++i) {\n      sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\n      array[i] = sourceMap ? sn.join('') : sn;\n    }\n    base = previousBase;\n    return array.join('\\n');\n  }\n  function generateComment(comment, specialBase) {\n    if (comment.type === 'Line') {\n      if (endsWithLineTerminator(comment.value)) {\n        return '//' + comment.value;\n      } else {\n        // Always use LineTerminator\n        var result = '//' + comment.value;\n        if (!preserveBlankLines) {\n          result += '\\n';\n        }\n        return result;\n      }\n    }\n    if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n      return adjustMultilineComment('/*' + comment.value + '*/', specialBase);\n    }\n    return '/*' + comment.value + '*/';\n  }\n  function addComments(stmt, result) {\n    var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix, infix, suffix, count;\n    if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n      save = result;\n      if (preserveBlankLines) {\n        comment = stmt.leadingComments[0];\n        result = [];\n        extRange = comment.extendedRange;\n        range = comment.range;\n        prefix = sourceCode.substring(extRange[0], range[0]);\n        count = (prefix.match(/\\n/g) || []).length;\n        if (count > 0) {\n          result.push(stringRepeat('\\n', count));\n          result.push(addIndent(generateComment(comment)));\n        } else {\n          result.push(prefix);\n          result.push(generateComment(comment));\n        }\n        prevRange = range;\n        for (i = 1, len = stmt.leadingComments.length; i < len; i++) {\n          comment = stmt.leadingComments[i];\n          range = comment.range;\n          infix = sourceCode.substring(prevRange[1], range[0]);\n          count = (infix.match(/\\n/g) || []).length;\n          result.push(stringRepeat('\\n', count));\n          result.push(addIndent(generateComment(comment)));\n          prevRange = range;\n        }\n        suffix = sourceCode.substring(range[1], extRange[1]);\n        count = (suffix.match(/\\n/g) || []).length;\n        result.push(stringRepeat('\\n', count));\n      } else {\n        comment = stmt.leadingComments[0];\n        result = [];\n        if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n          result.push('\\n');\n        }\n        result.push(generateComment(comment));\n        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n          result.push('\\n');\n        }\n        for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {\n          comment = stmt.leadingComments[i];\n          fragment = [generateComment(comment)];\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            fragment.push('\\n');\n          }\n          result.push(addIndent(fragment));\n        }\n      }\n      result.push(addIndent(save));\n    }\n    if (stmt.trailingComments) {\n      if (preserveBlankLines) {\n        comment = stmt.trailingComments[0];\n        extRange = comment.extendedRange;\n        range = comment.range;\n        prefix = sourceCode.substring(extRange[0], range[0]);\n        count = (prefix.match(/\\n/g) || []).length;\n        if (count > 0) {\n          result.push(stringRepeat('\\n', count));\n          result.push(addIndent(generateComment(comment)));\n        } else {\n          result.push(prefix);\n          result.push(generateComment(comment));\n        }\n      } else {\n        tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n        specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));\n        for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {\n          comment = stmt.trailingComments[i];\n          if (tailingToStatement) {\n            // We assume target like following script\n            //\n            // var t = 20;  /**\n            //               * This is comment of t\n            //               */\n            if (i === 0) {\n              // first case\n              result = [result, indent];\n            } else {\n              result = [result, specialBase];\n            }\n            result.push(generateComment(comment, specialBase));\n          } else {\n            result = [result, addIndent(generateComment(comment))];\n          }\n          if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result = [result, '\\n'];\n          }\n        }\n      }\n    }\n    return result;\n  }\n  function generateBlankLines(start, end, result) {\n    var j,\n      newlineCount = 0;\n    for (j = start; j < end; j++) {\n      if (sourceCode[j] === '\\n') {\n        newlineCount++;\n      }\n    }\n    for (j = 1; j < newlineCount; j++) {\n      result.push(newline);\n    }\n  }\n  function parenthesize(text, current, should) {\n    if (current < should) {\n      return ['(', text, ')'];\n    }\n    return text;\n  }\n  function generateVerbatimString(string) {\n    var i, iz, result;\n    result = string.split(/\\r\\n|\\n/);\n    for (i = 1, iz = result.length; i < iz; i++) {\n      result[i] = newline + base + result[i];\n    }\n    return result;\n  }\n  function generateVerbatim(expr, precedence) {\n    var verbatim, result, prec;\n    verbatim = expr[extra.verbatim];\n    if (typeof verbatim === 'string') {\n      result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);\n    } else {\n      // verbatim is object\n      result = generateVerbatimString(verbatim.content);\n      prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;\n      result = parenthesize(result, prec, precedence);\n    }\n    return toSourceNodeWhenNeeded(result, expr);\n  }\n  function CodeGenerator() {}\n\n  // Helpers.\n\n  CodeGenerator.prototype.maybeBlock = function (stmt, flags) {\n    var result,\n      noLeadingComment,\n      that = this;\n    noLeadingComment = !extra.comment || !stmt.leadingComments;\n    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n      return [space, this.generateStatement(stmt, flags)];\n    }\n    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n      return ';';\n    }\n    withIndent(function () {\n      result = [newline, addIndent(that.generateStatement(stmt, flags))];\n    });\n    return result;\n  };\n  CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {\n    var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n    if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n      return [result, space];\n    }\n    if (ends) {\n      return [result, base];\n    }\n    return [result, newline, base];\n  };\n  function generateIdentifier(node) {\n    return toSourceNodeWhenNeeded(node.name, node);\n  }\n  function generateAsyncPrefix(node, spaceRequired) {\n    return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';\n  }\n  function generateStarSuffix(node) {\n    var isGenerator = node.generator && !extra.moz.starlessGenerator;\n    return isGenerator ? '*' + space : '';\n  }\n  function generateMethodPrefix(prop) {\n    var func = prop.value,\n      prefix = '';\n    if (func.async) {\n      prefix += generateAsyncPrefix(func, !prop.computed);\n    }\n    if (func.generator) {\n      // avoid space before method name\n      prefix += generateStarSuffix(func) ? '*' : '';\n    }\n    return prefix;\n  }\n  CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {\n    if (node.type === Syntax.Identifier) {\n      return generateIdentifier(node);\n    }\n    return this.generateExpression(node, precedence, flags);\n  };\n  CodeGenerator.prototype.generateFunctionParams = function (node) {\n    var i, iz, result, hasDefault;\n    hasDefault = false;\n    if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {\n      // arg => { } case\n      result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];\n    } else {\n      result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];\n      result.push('(');\n      if (node.defaults) {\n        hasDefault = true;\n      }\n      for (i = 0, iz = node.params.length; i < iz; ++i) {\n        if (hasDefault && node.defaults[i]) {\n          // Handle default values.\n          result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));\n        } else {\n          result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));\n        }\n        if (i + 1 < iz) {\n          result.push(',' + space);\n        }\n      }\n      if (node.rest) {\n        if (node.params.length) {\n          result.push(',' + space);\n        }\n        result.push('...');\n        result.push(generateIdentifier(node.rest));\n      }\n      result.push(')');\n    }\n    return result;\n  };\n  CodeGenerator.prototype.generateFunctionBody = function (node) {\n    var result, expr;\n    result = this.generateFunctionParams(node);\n    if (node.type === Syntax.ArrowFunctionExpression) {\n      result.push(space);\n      result.push('=>');\n    }\n    if (node.expression) {\n      result.push(space);\n      expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\n      if (expr.toString().charAt(0) === '{') {\n        expr = ['(', expr, ')'];\n      }\n      result.push(expr);\n    } else {\n      result.push(this.maybeBlock(node.body, S_TTFF));\n    }\n    return result;\n  };\n  CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {\n    var result = ['for' + (stmt.await ? noEmptySpace() + 'await' : '') + space + '('],\n      that = this;\n    withIndent(function () {\n      if (stmt.left.type === Syntax.VariableDeclaration) {\n        withIndent(function () {\n          result.push(stmt.left.kind + noEmptySpace());\n          result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));\n        });\n      } else {\n        result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\n      }\n      result = join(result, operator);\n      result = [join(result, that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)), ')'];\n    });\n    result.push(this.maybeBlock(stmt.body, flags));\n    return result;\n  };\n  CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {\n    var result = [];\n    if (computed) {\n      result.push('[');\n    }\n    result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));\n    if (computed) {\n      result.push(']');\n    }\n    return result;\n  };\n  CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {\n    if (Precedence.Assignment < precedence) {\n      flags |= F_ALLOW_IN;\n    }\n    return parenthesize([this.generateExpression(left, Precedence.Call, flags), space + operator + space, this.generateExpression(right, Precedence.Assignment, flags)], Precedence.Assignment, precedence);\n  };\n  CodeGenerator.prototype.semicolon = function (flags) {\n    if (!semicolons && flags & F_SEMICOLON_OPT) {\n      return '';\n    }\n    return ';';\n  };\n\n  // Statements.\n\n  CodeGenerator.Statement = {\n    BlockStatement: function (stmt, flags) {\n      var range,\n        content,\n        result = ['{', newline],\n        that = this;\n      withIndent(function () {\n        // handle functions without any code\n        if (stmt.body.length === 0 && preserveBlankLines) {\n          range = stmt.range;\n          if (range[1] - range[0] > 2) {\n            content = sourceCode.substring(range[0] + 1, range[1] - 1);\n            if (content[0] === '\\n') {\n              result = ['{'];\n            }\n            result.push(content);\n          }\n        }\n        var i, iz, fragment, bodyFlags;\n        bodyFlags = S_TFFF;\n        if (flags & F_FUNC_BODY) {\n          bodyFlags |= F_DIRECTIVE_CTX;\n        }\n        for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n          if (preserveBlankLines) {\n            // handle spaces before the first line\n            if (i === 0) {\n              if (stmt.body[0].leadingComments) {\n                range = stmt.body[0].leadingComments[0].extendedRange;\n                content = sourceCode.substring(range[0], range[1]);\n                if (content[0] === '\\n') {\n                  result = ['{'];\n                }\n              }\n              if (!stmt.body[0].leadingComments) {\n                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);\n              }\n            }\n\n            // handle spaces between lines\n            if (i > 0) {\n              if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n              }\n            }\n          }\n          if (i === iz - 1) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n          if (stmt.body[i].leadingComments && preserveBlankLines) {\n            fragment = that.generateStatement(stmt.body[i], bodyFlags);\n          } else {\n            fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));\n          }\n          result.push(fragment);\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            if (preserveBlankLines && i < iz - 1) {\n              // don't add a new line if there are leading coments\n              // in the next statement\n              if (!stmt.body[i + 1].leadingComments) {\n                result.push(newline);\n              }\n            } else {\n              result.push(newline);\n            }\n          }\n          if (preserveBlankLines) {\n            // handle spaces after the last line\n            if (i === iz - 1) {\n              if (!stmt.body[i].trailingComments) {\n                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n              }\n            }\n          }\n        }\n      });\n      result.push(addIndent('}'));\n      return result;\n    },\n    BreakStatement: function (stmt, flags) {\n      if (stmt.label) {\n        return 'break ' + stmt.label.name + this.semicolon(flags);\n      }\n      return 'break' + this.semicolon(flags);\n    },\n    ContinueStatement: function (stmt, flags) {\n      if (stmt.label) {\n        return 'continue ' + stmt.label.name + this.semicolon(flags);\n      }\n      return 'continue' + this.semicolon(flags);\n    },\n    ClassBody: function (stmt, flags) {\n      var result = ['{', newline],\n        that = this;\n      withIndent(function (indent) {\n        var i, iz;\n        for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n          result.push(indent);\n          result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));\n          if (i + 1 < iz) {\n            result.push(newline);\n          }\n        }\n      });\n      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n      result.push(base);\n      result.push('}');\n      return result;\n    },\n    ClassDeclaration: function (stmt, flags) {\n      var result, fragment;\n      result = ['class'];\n      if (stmt.id) {\n        result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));\n      }\n      if (stmt.superClass) {\n        fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));\n        result = join(result, fragment);\n      }\n      result.push(space);\n      result.push(this.generateStatement(stmt.body, S_TFFT));\n      return result;\n    },\n    DirectiveStatement: function (stmt, flags) {\n      if (extra.raw && stmt.raw) {\n        return stmt.raw + this.semicolon(flags);\n      }\n      return escapeDirective(stmt.directive) + this.semicolon(flags);\n    },\n    DoWhileStatement: function (stmt, flags) {\n      // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n      var result = join('do', this.maybeBlock(stmt.body, S_TFFF));\n      result = this.maybeBlockSuffix(stmt.body, result);\n      return join(result, ['while' + space + '(', this.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')' + this.semicolon(flags)]);\n    },\n    CatchClause: function (stmt, flags) {\n      var result,\n        that = this;\n      withIndent(function () {\n        var guard;\n        if (stmt.param) {\n          result = ['catch' + space + '(', that.generateExpression(stmt.param, Precedence.Sequence, E_TTT), ')'];\n          if (stmt.guard) {\n            guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);\n            result.splice(2, 0, ' if ', guard);\n          }\n        } else {\n          result = ['catch'];\n        }\n      });\n      result.push(this.maybeBlock(stmt.body, S_TFFF));\n      return result;\n    },\n    DebuggerStatement: function (stmt, flags) {\n      return 'debugger' + this.semicolon(flags);\n    },\n    EmptyStatement: function (stmt, flags) {\n      return ';';\n    },\n    ExportDefaultDeclaration: function (stmt, flags) {\n      var result = ['export'],\n        bodyFlags;\n      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;\n\n      // export default HoistableDeclaration[Default]\n      // export default AssignmentExpression[In] ;\n      result = join(result, 'default');\n      if (isStatement(stmt.declaration)) {\n        result = join(result, this.generateStatement(stmt.declaration, bodyFlags));\n      } else {\n        result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));\n      }\n      return result;\n    },\n    ExportNamedDeclaration: function (stmt, flags) {\n      var result = ['export'],\n        bodyFlags,\n        that = this;\n      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;\n\n      // export VariableStatement\n      // export Declaration[Default]\n      if (stmt.declaration) {\n        return join(result, this.generateStatement(stmt.declaration, bodyFlags));\n      }\n\n      // export ExportClause[NoReference] FromClause ;\n      // export ExportClause ;\n      if (stmt.specifiers) {\n        if (stmt.specifiers.length === 0) {\n          result = join(result, '{' + space + '}');\n        } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\n          result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));\n        } else {\n          result = join(result, '{');\n          withIndent(function (indent) {\n            var i, iz;\n            result.push(newline);\n            for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {\n              result.push(indent);\n              result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n              if (i + 1 < iz) {\n                result.push(',' + newline);\n              }\n            }\n          });\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result.push(newline);\n          }\n          result.push(base + '}');\n        }\n        if (stmt.source) {\n          result = join(result, ['from' + space,\n          // ModuleSpecifier\n          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);\n        } else {\n          result.push(this.semicolon(flags));\n        }\n      }\n      return result;\n    },\n    ExportAllDeclaration: function (stmt, flags) {\n      // export * FromClause ;\n      return ['export' + space, '*' + space, 'from' + space,\n      // ModuleSpecifier\n      this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];\n    },\n    ExpressionStatement: function (stmt, flags) {\n      var result, fragment;\n      function isClassPrefixed(fragment) {\n        var code;\n        if (fragment.slice(0, 5) !== 'class') {\n          return false;\n        }\n        code = fragment.charCodeAt(5);\n        return code === 0x7B /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);\n      }\n      function isFunctionPrefixed(fragment) {\n        var code;\n        if (fragment.slice(0, 8) !== 'function') {\n          return false;\n        }\n        code = fragment.charCodeAt(8);\n        return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A /* '*' */ || esutils.code.isLineTerminator(code);\n      }\n      function isAsyncPrefixed(fragment) {\n        var code, i, iz;\n        if (fragment.slice(0, 5) !== 'async') {\n          return false;\n        }\n        if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {\n          return false;\n        }\n        for (i = 6, iz = fragment.length; i < iz; ++i) {\n          if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {\n            break;\n          }\n        }\n        if (i === iz) {\n          return false;\n        }\n        if (fragment.slice(i, i + 8) !== 'function') {\n          return false;\n        }\n        code = fragment.charCodeAt(i + 8);\n        return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A /* '*' */ || esutils.code.isLineTerminator(code);\n      }\n      result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];\n      // 12.4 '{', 'function', 'class' is not allowed in this position.\n      // wrap expression with parentheses\n      fragment = toSourceNodeWhenNeeded(result).toString();\n      if (fragment.charCodeAt(0) === 0x7B /* '{' */ ||\n      // ObjectExpression\n      isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string') {\n        result = ['(', result, ')' + this.semicolon(flags)];\n      } else {\n        result.push(this.semicolon(flags));\n      }\n      return result;\n    },\n    ImportDeclaration: function (stmt, flags) {\n      // ES6: 15.2.1 valid import declarations:\n      //     - import ImportClause FromClause ;\n      //     - import ModuleSpecifier ;\n      var result,\n        cursor,\n        that = this;\n\n      // If no ImportClause is present,\n      // this should be `import ModuleSpecifier` so skip `from`\n      // ModuleSpecifier is StringLiteral.\n      if (stmt.specifiers.length === 0) {\n        // import ModuleSpecifier ;\n        return ['import', space,\n        // ModuleSpecifier\n        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];\n      }\n\n      // import ImportClause FromClause ;\n      result = ['import'];\n      cursor = 0;\n\n      // ImportedBinding\n      if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\n        result = join(result, [this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);\n        ++cursor;\n      }\n      if (stmt.specifiers[cursor]) {\n        if (cursor !== 0) {\n          result.push(',');\n        }\n        if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\n          // NameSpaceImport\n          result = join(result, [space, this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);\n        } else {\n          // NamedImports\n          result.push(space + '{');\n          if (stmt.specifiers.length - cursor === 1) {\n            // import { ... } from \"...\";\n            result.push(space);\n            result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));\n            result.push(space + '}' + space);\n          } else {\n            // import {\n            //    ...,\n            //    ...,\n            // } from \"...\";\n            withIndent(function (indent) {\n              var i, iz;\n              result.push(newline);\n              for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {\n                result.push(indent);\n                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                if (i + 1 < iz) {\n                  result.push(',' + newline);\n                }\n              }\n            });\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n              result.push(newline);\n            }\n            result.push(base + '}' + space);\n          }\n        }\n      }\n      result = join(result, ['from' + space,\n      // ModuleSpecifier\n      this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);\n      return result;\n    },\n    VariableDeclarator: function (stmt, flags) {\n      var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;\n      if (stmt.init) {\n        return [this.generateExpression(stmt.id, Precedence.Assignment, itemFlags), space, '=', space, this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)];\n      }\n      return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\n    },\n    VariableDeclaration: function (stmt, flags) {\n      // VariableDeclarator is typed as Statement,\n      // but joined with comma (not LineTerminator).\n      // So if comment is attached to target node, we should specialize.\n      var result,\n        i,\n        iz,\n        node,\n        bodyFlags,\n        that = this;\n      result = [stmt.kind];\n      bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;\n      function block() {\n        node = stmt.declarations[0];\n        if (extra.comment && node.leadingComments) {\n          result.push('\\n');\n          result.push(addIndent(that.generateStatement(node, bodyFlags)));\n        } else {\n          result.push(noEmptySpace());\n          result.push(that.generateStatement(node, bodyFlags));\n        }\n        for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {\n          node = stmt.declarations[i];\n          if (extra.comment && node.leadingComments) {\n            result.push(',' + newline);\n            result.push(addIndent(that.generateStatement(node, bodyFlags)));\n          } else {\n            result.push(',' + space);\n            result.push(that.generateStatement(node, bodyFlags));\n          }\n        }\n      }\n      if (stmt.declarations.length > 1) {\n        withIndent(block);\n      } else {\n        block();\n      }\n      result.push(this.semicolon(flags));\n      return result;\n    },\n    ThrowStatement: function (stmt, flags) {\n      return [join('throw', this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];\n    },\n    TryStatement: function (stmt, flags) {\n      var result, i, iz, guardedHandlers;\n      result = ['try', this.maybeBlock(stmt.block, S_TFFF)];\n      result = this.maybeBlockSuffix(stmt.block, result);\n      if (stmt.handlers) {\n        // old interface\n        for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {\n          result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));\n          if (stmt.finalizer || i + 1 !== iz) {\n            result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\n          }\n        }\n      } else {\n        guardedHandlers = stmt.guardedHandlers || [];\n        for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {\n          result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));\n          if (stmt.finalizer || i + 1 !== iz) {\n            result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\n          }\n        }\n\n        // new interface\n        if (stmt.handler) {\n          if (Array.isArray(stmt.handler)) {\n            for (i = 0, iz = stmt.handler.length; i < iz; ++i) {\n              result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));\n              if (stmt.finalizer || i + 1 !== iz) {\n                result = this.maybeBlockSuffix(stmt.handler[i].body, result);\n              }\n            }\n          } else {\n            result = join(result, this.generateStatement(stmt.handler, S_TFFF));\n            if (stmt.finalizer) {\n              result = this.maybeBlockSuffix(stmt.handler.body, result);\n            }\n          }\n        }\n      }\n      if (stmt.finalizer) {\n        result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);\n      }\n      return result;\n    },\n    SwitchStatement: function (stmt, flags) {\n      var result,\n        fragment,\n        i,\n        iz,\n        bodyFlags,\n        that = this;\n      withIndent(function () {\n        result = ['switch' + space + '(', that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT), ')' + space + '{' + newline];\n      });\n      if (stmt.cases) {\n        bodyFlags = S_TFFF;\n        for (i = 0, iz = stmt.cases.length; i < iz; ++i) {\n          if (i === iz - 1) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n          fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));\n          result.push(fragment);\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            result.push(newline);\n          }\n        }\n      }\n      result.push(addIndent('}'));\n      return result;\n    },\n    SwitchCase: function (stmt, flags) {\n      var result,\n        fragment,\n        i,\n        iz,\n        bodyFlags,\n        that = this;\n      withIndent(function () {\n        if (stmt.test) {\n          result = [join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)), ':'];\n        } else {\n          result = ['default:'];\n        }\n        i = 0;\n        iz = stmt.consequent.length;\n        if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\n          fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\n          result.push(fragment);\n          i = 1;\n        }\n        if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n          result.push(newline);\n        }\n        bodyFlags = S_TFFF;\n        for (; i < iz; ++i) {\n          if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n          fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));\n          result.push(fragment);\n          if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            result.push(newline);\n          }\n        }\n      });\n      return result;\n    },\n    IfStatement: function (stmt, flags) {\n      var result,\n        bodyFlags,\n        semicolonOptional,\n        that = this;\n      withIndent(function () {\n        result = ['if' + space + '(', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')'];\n      });\n      semicolonOptional = flags & F_SEMICOLON_OPT;\n      bodyFlags = S_TFFF;\n      if (semicolonOptional) {\n        bodyFlags |= F_SEMICOLON_OPT;\n      }\n      if (stmt.alternate) {\n        result.push(this.maybeBlock(stmt.consequent, S_TFFF));\n        result = this.maybeBlockSuffix(stmt.consequent, result);\n        if (stmt.alternate.type === Syntax.IfStatement) {\n          result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);\n        } else {\n          result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));\n        }\n      } else {\n        result.push(this.maybeBlock(stmt.consequent, bodyFlags));\n      }\n      return result;\n    },\n    ForStatement: function (stmt, flags) {\n      var result,\n        that = this;\n      withIndent(function () {\n        result = ['for' + space + '('];\n        if (stmt.init) {\n          if (stmt.init.type === Syntax.VariableDeclaration) {\n            result.push(that.generateStatement(stmt.init, S_FFFF));\n          } else {\n            // F_ALLOW_IN becomes false.\n            result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));\n            result.push(';');\n          }\n        } else {\n          result.push(';');\n        }\n        if (stmt.test) {\n          result.push(space);\n          result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));\n          result.push(';');\n        } else {\n          result.push(';');\n        }\n        if (stmt.update) {\n          result.push(space);\n          result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));\n          result.push(')');\n        } else {\n          result.push(')');\n        }\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    },\n    ForInStatement: function (stmt, flags) {\n      return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n    },\n    ForOfStatement: function (stmt, flags) {\n      return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n    },\n    LabeledStatement: function (stmt, flags) {\n      return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];\n    },\n    Program: function (stmt, flags) {\n      var result, fragment, i, iz, bodyFlags;\n      iz = stmt.body.length;\n      result = [safeConcatenation && iz > 0 ? '\\n' : ''];\n      bodyFlags = S_TFTF;\n      for (i = 0; i < iz; ++i) {\n        if (!safeConcatenation && i === iz - 1) {\n          bodyFlags |= F_SEMICOLON_OPT;\n        }\n        if (preserveBlankLines) {\n          // handle spaces before the first line\n          if (i === 0) {\n            if (!stmt.body[0].leadingComments) {\n              generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);\n            }\n          }\n\n          // handle spaces between lines\n          if (i > 0) {\n            if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n              generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n            }\n          }\n        }\n        fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\n        result.push(fragment);\n        if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n          if (preserveBlankLines) {\n            if (!stmt.body[i + 1].leadingComments) {\n              result.push(newline);\n            }\n          } else {\n            result.push(newline);\n          }\n        }\n        if (preserveBlankLines) {\n          // handle spaces after the last line\n          if (i === iz - 1) {\n            if (!stmt.body[i].trailingComments) {\n              generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n            }\n          }\n        }\n      }\n      return result;\n    },\n    FunctionDeclaration: function (stmt, flags) {\n      return [generateAsyncPrefix(stmt, true), 'function', generateStarSuffix(stmt) || noEmptySpace(), stmt.id ? generateIdentifier(stmt.id) : '', this.generateFunctionBody(stmt)];\n    },\n    ReturnStatement: function (stmt, flags) {\n      if (stmt.argument) {\n        return [join('return', this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];\n      }\n      return ['return' + this.semicolon(flags)];\n    },\n    WhileStatement: function (stmt, flags) {\n      var result,\n        that = this;\n      withIndent(function () {\n        result = ['while' + space + '(', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')'];\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    },\n    WithStatement: function (stmt, flags) {\n      var result,\n        that = this;\n      withIndent(function () {\n        result = ['with' + space + '(', that.generateExpression(stmt.object, Precedence.Sequence, E_TTT), ')'];\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    }\n  };\n  merge(CodeGenerator.prototype, CodeGenerator.Statement);\n\n  // Expressions.\n\n  CodeGenerator.Expression = {\n    SequenceExpression: function (expr, precedence, flags) {\n      var result, i, iz;\n      if (Precedence.Sequence < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n      result = [];\n      for (i = 0, iz = expr.expressions.length; i < iz; ++i) {\n        result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));\n        if (i + 1 < iz) {\n          result.push(',' + space);\n        }\n      }\n      return parenthesize(result, Precedence.Sequence, precedence);\n    },\n    AssignmentExpression: function (expr, precedence, flags) {\n      return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);\n    },\n    ArrowFunctionExpression: function (expr, precedence, flags) {\n      return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);\n    },\n    ConditionalExpression: function (expr, precedence, flags) {\n      if (Precedence.Conditional < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n      return parenthesize([this.generateExpression(expr.test, Precedence.LogicalOR, flags), space + '?' + space, this.generateExpression(expr.consequent, Precedence.Assignment, flags), space + ':' + space, this.generateExpression(expr.alternate, Precedence.Assignment, flags)], Precedence.Conditional, precedence);\n    },\n    LogicalExpression: function (expr, precedence, flags) {\n      return this.BinaryExpression(expr, precedence, flags);\n    },\n    BinaryExpression: function (expr, precedence, flags) {\n      var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;\n      currentPrecedence = BinaryPrecedence[expr.operator];\n      leftPrecedence = expr.operator === '**' ? Precedence.Postfix : currentPrecedence;\n      rightPrecedence = expr.operator === '**' ? currentPrecedence : currentPrecedence + 1;\n      if (currentPrecedence < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n      fragment = this.generateExpression(expr.left, leftPrecedence, flags);\n      leftSource = fragment.toString();\n      if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {\n        result = [fragment, noEmptySpace(), expr.operator];\n      } else {\n        result = join(fragment, expr.operator);\n      }\n      fragment = this.generateExpression(expr.right, rightPrecedence, flags);\n      if (expr.operator === '/' && fragment.toString().charAt(0) === '/' || expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {\n        // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start\n        result.push(noEmptySpace());\n        result.push(fragment);\n      } else {\n        result = join(result, fragment);\n      }\n      if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {\n        return ['(', result, ')'];\n      }\n      return parenthesize(result, currentPrecedence, precedence);\n    },\n    CallExpression: function (expr, precedence, flags) {\n      var result, i, iz;\n\n      // F_ALLOW_UNPARATH_NEW becomes false.\n      result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];\n      if (expr.optional) {\n        result.push('?.');\n      }\n      result.push('(');\n      for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {\n        result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n        if (i + 1 < iz) {\n          result.push(',' + space);\n        }\n      }\n      result.push(')');\n      if (!(flags & F_ALLOW_CALL)) {\n        return ['(', result, ')'];\n      }\n      return parenthesize(result, Precedence.Call, precedence);\n    },\n    ChainExpression: function (expr, precedence, flags) {\n      if (Precedence.OptionalChaining < precedence) {\n        flags |= F_ALLOW_CALL;\n      }\n      var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);\n      return parenthesize(result, Precedence.OptionalChaining, precedence);\n    },\n    NewExpression: function (expr, precedence, flags) {\n      var result, length, i, iz, itemFlags;\n      length = expr['arguments'].length;\n\n      // F_ALLOW_CALL becomes false.\n      // F_ALLOW_UNPARATH_NEW may become false.\n      itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;\n      result = join('new', this.generateExpression(expr.callee, Precedence.New, itemFlags));\n      if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\n        result.push('(');\n        for (i = 0, iz = length; i < iz; ++i) {\n          result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n          if (i + 1 < iz) {\n            result.push(',' + space);\n          }\n        }\n        result.push(')');\n      }\n      return parenthesize(result, Precedence.New, precedence);\n    },\n    MemberExpression: function (expr, precedence, flags) {\n      var result, fragment;\n\n      // F_ALLOW_UNPARATH_NEW becomes false.\n      result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];\n      if (expr.computed) {\n        if (expr.optional) {\n          result.push('?.');\n        }\n        result.push('[');\n        result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));\n        result.push(']');\n      } else {\n        if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {\n          fragment = toSourceNodeWhenNeeded(result).toString();\n          // When the following conditions are all true,\n          //   1. No floating point\n          //   2. Don't have exponents\n          //   3. The last character is a decimal digit\n          //   4. Not hexadecimal OR octal number literal\n          // we should add a floating point.\n          if (fragment.indexOf('.') < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48) // '0'\n          ) {\n            result.push(' ');\n          }\n        }\n        result.push(expr.optional ? '?.' : '.');\n        result.push(generateIdentifier(expr.property));\n      }\n      return parenthesize(result, Precedence.Member, precedence);\n    },\n    MetaProperty: function (expr, precedence, flags) {\n      var result;\n      result = [];\n      result.push(typeof expr.meta === \"string\" ? expr.meta : generateIdentifier(expr.meta));\n      result.push('.');\n      result.push(typeof expr.property === \"string\" ? expr.property : generateIdentifier(expr.property));\n      return parenthesize(result, Precedence.Member, precedence);\n    },\n    UnaryExpression: function (expr, precedence, flags) {\n      var result, fragment, rightCharCode, leftSource, leftCharCode;\n      fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);\n      if (space === '') {\n        result = join(expr.operator, fragment);\n      } else {\n        result = [expr.operator];\n        if (expr.operator.length > 2) {\n          // delete, void, typeof\n          // get `typeof []`, not `typeof[]`\n          result = join(result, fragment);\n        } else {\n          // Prevent inserting spaces between operator and argument if it is unnecessary\n          // like, `!cond`\n          leftSource = toSourceNodeWhenNeeded(result).toString();\n          leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n          rightCharCode = fragment.toString().charCodeAt(0);\n          if ((leftCharCode === 0x2B /* + */ || leftCharCode === 0x2D /* - */) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {\n            result.push(noEmptySpace());\n            result.push(fragment);\n          } else {\n            result.push(fragment);\n          }\n        }\n      }\n      return parenthesize(result, Precedence.Unary, precedence);\n    },\n    YieldExpression: function (expr, precedence, flags) {\n      var result;\n      if (expr.delegate) {\n        result = 'yield*';\n      } else {\n        result = 'yield';\n      }\n      if (expr.argument) {\n        result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));\n      }\n      return parenthesize(result, Precedence.Yield, precedence);\n    },\n    AwaitExpression: function (expr, precedence, flags) {\n      var result = join(expr.all ? 'await*' : 'await', this.generateExpression(expr.argument, Precedence.Await, E_TTT));\n      return parenthesize(result, Precedence.Await, precedence);\n    },\n    UpdateExpression: function (expr, precedence, flags) {\n      if (expr.prefix) {\n        return parenthesize([expr.operator, this.generateExpression(expr.argument, Precedence.Unary, E_TTT)], Precedence.Unary, precedence);\n      }\n      return parenthesize([this.generateExpression(expr.argument, Precedence.Postfix, E_TTT), expr.operator], Precedence.Postfix, precedence);\n    },\n    FunctionExpression: function (expr, precedence, flags) {\n      var result = [generateAsyncPrefix(expr, true), 'function'];\n      if (expr.id) {\n        result.push(generateStarSuffix(expr) || noEmptySpace());\n        result.push(generateIdentifier(expr.id));\n      } else {\n        result.push(generateStarSuffix(expr) || space);\n      }\n      result.push(this.generateFunctionBody(expr));\n      return result;\n    },\n    ArrayPattern: function (expr, precedence, flags) {\n      return this.ArrayExpression(expr, precedence, flags, true);\n    },\n    ArrayExpression: function (expr, precedence, flags, isPattern) {\n      var result,\n        multiline,\n        that = this;\n      if (!expr.elements.length) {\n        return '[]';\n      }\n      multiline = isPattern ? false : expr.elements.length > 1;\n      result = ['[', multiline ? newline : ''];\n      withIndent(function (indent) {\n        var i, iz;\n        for (i = 0, iz = expr.elements.length; i < iz; ++i) {\n          if (!expr.elements[i]) {\n            if (multiline) {\n              result.push(indent);\n            }\n            if (i + 1 === iz) {\n              result.push(',');\n            }\n          } else {\n            result.push(multiline ? indent : '');\n            result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));\n          }\n          if (i + 1 < iz) {\n            result.push(',' + (multiline ? newline : space));\n          }\n        }\n      });\n      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n      result.push(multiline ? base : '');\n      result.push(']');\n      return result;\n    },\n    RestElement: function (expr, precedence, flags) {\n      return '...' + this.generatePattern(expr.argument);\n    },\n    ClassExpression: function (expr, precedence, flags) {\n      var result, fragment;\n      result = ['class'];\n      if (expr.id) {\n        result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));\n      }\n      if (expr.superClass) {\n        fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));\n        result = join(result, fragment);\n      }\n      result.push(space);\n      result.push(this.generateStatement(expr.body, S_TFFT));\n      return result;\n    },\n    MethodDefinition: function (expr, precedence, flags) {\n      var result, fragment;\n      if (expr['static']) {\n        result = ['static' + space];\n      } else {\n        result = [];\n      }\n      if (expr.kind === 'get' || expr.kind === 'set') {\n        fragment = [join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)), this.generateFunctionBody(expr.value)];\n      } else {\n        fragment = [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n      return join(result, fragment);\n    },\n    Property: function (expr, precedence, flags) {\n      if (expr.kind === 'get' || expr.kind === 'set') {\n        return [expr.kind, noEmptySpace(), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n      if (expr.shorthand) {\n        if (expr.value.type === \"AssignmentPattern\") {\n          return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);\n        }\n        return this.generatePropertyKey(expr.key, expr.computed);\n      }\n      if (expr.method) {\n        return [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n      return [this.generatePropertyKey(expr.key, expr.computed), ':' + space, this.generateExpression(expr.value, Precedence.Assignment, E_TTT)];\n    },\n    ObjectExpression: function (expr, precedence, flags) {\n      var multiline,\n        result,\n        fragment,\n        that = this;\n      if (!expr.properties.length) {\n        return '{}';\n      }\n      multiline = expr.properties.length > 1;\n      withIndent(function () {\n        fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);\n      });\n      if (!multiline) {\n        // issues 4\n        // Do not transform from\n        //   dejavu.Class.declare({\n        //       method2: function () {}\n        //   });\n        // to\n        //   dejavu.Class.declare({method2: function () {\n        //       }});\n        if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n          return ['{', space, fragment, space, '}'];\n        }\n      }\n      withIndent(function (indent) {\n        var i, iz;\n        result = ['{', newline, indent, fragment];\n        if (multiline) {\n          result.push(',' + newline);\n          for (i = 1, iz = expr.properties.length; i < iz; ++i) {\n            result.push(indent);\n            result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n            if (i + 1 < iz) {\n              result.push(',' + newline);\n            }\n          }\n        }\n      });\n      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n      result.push(base);\n      result.push('}');\n      return result;\n    },\n    AssignmentPattern: function (expr, precedence, flags) {\n      return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);\n    },\n    ObjectPattern: function (expr, precedence, flags) {\n      var result,\n        i,\n        iz,\n        multiline,\n        property,\n        that = this;\n      if (!expr.properties.length) {\n        return '{}';\n      }\n      multiline = false;\n      if (expr.properties.length === 1) {\n        property = expr.properties[0];\n        if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {\n          multiline = true;\n        }\n      } else {\n        for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n          property = expr.properties[i];\n          if (property.type === Syntax.Property && !property.shorthand) {\n            multiline = true;\n            break;\n          }\n        }\n      }\n      result = ['{', multiline ? newline : ''];\n      withIndent(function (indent) {\n        var i, iz;\n        for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n          result.push(multiline ? indent : '');\n          result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n          if (i + 1 < iz) {\n            result.push(',' + (multiline ? newline : space));\n          }\n        }\n      });\n      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n      result.push(multiline ? base : '');\n      result.push('}');\n      return result;\n    },\n    ThisExpression: function (expr, precedence, flags) {\n      return 'this';\n    },\n    Super: function (expr, precedence, flags) {\n      return 'super';\n    },\n    Identifier: function (expr, precedence, flags) {\n      return generateIdentifier(expr);\n    },\n    ImportDefaultSpecifier: function (expr, precedence, flags) {\n      return generateIdentifier(expr.id || expr.local);\n    },\n    ImportNamespaceSpecifier: function (expr, precedence, flags) {\n      var result = ['*'];\n      var id = expr.id || expr.local;\n      if (id) {\n        result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));\n      }\n      return result;\n    },\n    ImportSpecifier: function (expr, precedence, flags) {\n      var imported = expr.imported;\n      var result = [imported.name];\n      var local = expr.local;\n      if (local && local.name !== imported.name) {\n        result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));\n      }\n      return result;\n    },\n    ExportSpecifier: function (expr, precedence, flags) {\n      var local = expr.local;\n      var result = [local.name];\n      var exported = expr.exported;\n      if (exported && exported.name !== local.name) {\n        result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));\n      }\n      return result;\n    },\n    Literal: function (expr, precedence, flags) {\n      var raw;\n      if (expr.hasOwnProperty('raw') && parse && extra.raw) {\n        try {\n          raw = parse(expr.raw).body[0].expression;\n          if (raw.type === Syntax.Literal) {\n            if (raw.value === expr.value) {\n              return expr.raw;\n            }\n          }\n        } catch (e) {\n          // not use raw property\n        }\n      }\n      if (expr.regex) {\n        return '/' + expr.regex.pattern + '/' + expr.regex.flags;\n      }\n      if (expr.value === null) {\n        return 'null';\n      }\n      if (typeof expr.value === 'string') {\n        return escapeString(expr.value);\n      }\n      if (typeof expr.value === 'number') {\n        return generateNumber(expr.value);\n      }\n      if (typeof expr.value === 'boolean') {\n        return expr.value ? 'true' : 'false';\n      }\n      return generateRegExp(expr.value);\n    },\n    GeneratorExpression: function (expr, precedence, flags) {\n      return this.ComprehensionExpression(expr, precedence, flags);\n    },\n    ComprehensionExpression: function (expr, precedence, flags) {\n      // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]\n      // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6\n\n      var result,\n        i,\n        iz,\n        fragment,\n        that = this;\n      result = expr.type === Syntax.GeneratorExpression ? ['('] : ['['];\n      if (extra.moz.comprehensionExpressionStartsWithAssignment) {\n        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n        result.push(fragment);\n      }\n      if (expr.blocks) {\n        withIndent(function () {\n          for (i = 0, iz = expr.blocks.length; i < iz; ++i) {\n            fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);\n            if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {\n              result = join(result, fragment);\n            } else {\n              result.push(fragment);\n            }\n          }\n        });\n      }\n      if (expr.filter) {\n        result = join(result, 'if' + space);\n        fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);\n        result = join(result, ['(', fragment, ')']);\n      }\n      if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\n        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n        result = join(result, fragment);\n      }\n      result.push(expr.type === Syntax.GeneratorExpression ? ')' : ']');\n      return result;\n    },\n    ComprehensionBlock: function (expr, precedence, flags) {\n      var fragment;\n      if (expr.left.type === Syntax.VariableDeclaration) {\n        fragment = [expr.left.kind, noEmptySpace(), this.generateStatement(expr.left.declarations[0], S_FFFF)];\n      } else {\n        fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\n      }\n      fragment = join(fragment, expr.of ? 'of' : 'in');\n      fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));\n      return ['for' + space + '(', fragment, ')'];\n    },\n    SpreadElement: function (expr, precedence, flags) {\n      return ['...', this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)];\n    },\n    TaggedTemplateExpression: function (expr, precedence, flags) {\n      var itemFlags = E_TTF;\n      if (!(flags & F_ALLOW_CALL)) {\n        itemFlags = E_TFF;\n      }\n      var result = [this.generateExpression(expr.tag, Precedence.Call, itemFlags), this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)];\n      return parenthesize(result, Precedence.TaggedTemplate, precedence);\n    },\n    TemplateElement: function (expr, precedence, flags) {\n      // Don't use \"cooked\". Since tagged template can use raw template\n      // representation. So if we do so, it breaks the script semantics.\n      return expr.value.raw;\n    },\n    TemplateLiteral: function (expr, precedence, flags) {\n      var result, i, iz;\n      result = ['`'];\n      for (i = 0, iz = expr.quasis.length; i < iz; ++i) {\n        result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));\n        if (i + 1 < iz) {\n          result.push('${' + space);\n          result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));\n          result.push(space + '}');\n        }\n      }\n      result.push('`');\n      return result;\n    },\n    ModuleSpecifier: function (expr, precedence, flags) {\n      return this.Literal(expr, precedence, flags);\n    },\n    ImportExpression: function (expr, precedence, flag) {\n      return parenthesize(['import(', this.generateExpression(expr.source, Precedence.Assignment, E_TTT), ')'], Precedence.Call, precedence);\n    }\n  };\n  merge(CodeGenerator.prototype, CodeGenerator.Expression);\n  CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {\n    var result, type;\n    type = expr.type || Syntax.Property;\n    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n      return generateVerbatim(expr, precedence);\n    }\n    result = this[type](expr, precedence, flags);\n    if (extra.comment) {\n      result = addComments(expr, result);\n    }\n    return toSourceNodeWhenNeeded(result, expr);\n  };\n  CodeGenerator.prototype.generateStatement = function (stmt, flags) {\n    var result, fragment;\n    result = this[stmt.type](stmt, flags);\n\n    // Attach comments\n\n    if (extra.comment) {\n      result = addComments(stmt, result);\n    }\n    fragment = toSourceNodeWhenNeeded(result).toString();\n    if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' && fragment.charAt(fragment.length - 1) === '\\n') {\n      result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, '') : fragment.replace(/\\s+$/, '');\n    }\n    return toSourceNodeWhenNeeded(result, stmt);\n  };\n  function generateInternal(node) {\n    var codegen;\n    codegen = new CodeGenerator();\n    if (isStatement(node)) {\n      return codegen.generateStatement(node, S_TFFF);\n    }\n    if (isExpression(node)) {\n      return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\n    }\n    throw new Error('Unknown node type: ' + node.type);\n  }\n  function generate(node, options) {\n    var defaultOptions = getDefaultOptions(),\n      result,\n      pair;\n    if (options != null) {\n      // Obsolete options\n      //\n      //   `options.indent`\n      //   `options.base`\n      //\n      // Instead of them, we can use `option.format.indent`.\n      if (typeof options.indent === 'string') {\n        defaultOptions.format.indent.style = options.indent;\n      }\n      if (typeof options.base === 'number') {\n        defaultOptions.format.indent.base = options.base;\n      }\n      options = updateDeeply(defaultOptions, options);\n      indent = options.format.indent.style;\n      if (typeof options.base === 'string') {\n        base = options.base;\n      } else {\n        base = stringRepeat(indent, options.format.indent.base);\n      }\n    } else {\n      options = defaultOptions;\n      indent = options.format.indent.style;\n      base = stringRepeat(indent, options.format.indent.base);\n    }\n    json = options.format.json;\n    renumber = options.format.renumber;\n    hexadecimal = json ? false : options.format.hexadecimal;\n    quotes = json ? 'double' : options.format.quotes;\n    escapeless = options.format.escapeless;\n    newline = options.format.newline;\n    space = options.format.space;\n    if (options.format.compact) {\n      newline = space = indent = base = '';\n    }\n    parentheses = options.format.parentheses;\n    semicolons = options.format.semicolons;\n    safeConcatenation = options.format.safeConcatenation;\n    directive = options.directive;\n    parse = json ? null : options.parse;\n    sourceMap = options.sourceMap;\n    sourceCode = options.sourceCode;\n    preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;\n    extra = options;\n    if (sourceMap) {\n      if (!exports.browser) {\n        // We assume environment is node.js\n        // And prevent from including source-map by browserify\n        SourceNode = require('source-map').SourceNode;\n      } else {\n        SourceNode = global.sourceMap.SourceNode;\n      }\n    }\n    result = generateInternal(node);\n    if (!sourceMap) {\n      pair = {\n        code: result.toString(),\n        map: null\n      };\n      return options.sourceMapWithCode ? pair : pair.code;\n    }\n    pair = result.toStringWithSourceMap({\n      file: options.file,\n      sourceRoot: options.sourceMapRoot\n    });\n    if (options.sourceContent) {\n      pair.map.setSourceContent(options.sourceMap, options.sourceContent);\n    }\n    if (options.sourceMapWithCode) {\n      return pair;\n    }\n    return pair.map.toString();\n  }\n  FORMAT_MINIFY = {\n    indent: {\n      style: '',\n      base: 0\n    },\n    renumber: true,\n    hexadecimal: true,\n    quotes: 'auto',\n    escapeless: true,\n    compact: true,\n    parentheses: false,\n    semicolons: false\n  };\n  FORMAT_DEFAULTS = getDefaultOptions().format;\n  exports.version = require('./package.json').version;\n  exports.generate = generate;\n  exports.attachComments = estraverse.attachComments;\n  exports.Precedence = updateDeeply({}, Precedence);\n  exports.browser = false;\n  exports.FORMAT_MINIFY = FORMAT_MINIFY;\n  exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"names":["Syntax","Precedence","BinaryPrecedence","SourceNode","estraverse","esutils","base","indent","json","renumber","hexadecimal","quotes","escapeless","newline","space","parentheses","semicolons","safeConcatenation","directive","extra","parse","sourceMap","sourceCode","preserveBlankLines","FORMAT_MINIFY","FORMAT_DEFAULTS","require","isExpression","node","CodeGenerator","Expression","hasOwnProperty","type","isStatement","Statement","Sequence","Yield","Assignment","Conditional","ArrowFunction","LogicalOR","LogicalAND","BitwiseOR","BitwiseXOR","BitwiseAND","Equality","Relational","BitwiseSHIFT","Additive","Multiplicative","Exponentiation","Await","Unary","Postfix","OptionalChaining","Call","New","TaggedTemplate","Member","Primary","F_ALLOW_IN","F_ALLOW_CALL","F_ALLOW_UNPARATH_NEW","F_FUNC_BODY","F_DIRECTIVE_CTX","F_SEMICOLON_OPT","E_FTT","E_TTF","E_TTT","E_TFF","E_FFT","E_TFT","S_TFFF","S_TFFT","S_FFFF","S_TFTF","S_TTFF","getDefaultOptions","comment","format","style","adjustMultilineComment","compact","moz","comprehensionExpressionStartsWithAssignment","starlessGenerator","sourceMapRoot","sourceMapWithCode","raw","verbatim","stringRepeat","str","num","result","hasLineTerminator","test","endsWithLineTerminator","len","length","code","isLineTerminator","charCodeAt","merge","target","override","key","updateDeeply","val","isHashObject","Object","RegExp","generateNumber","value","point","temp","exponent","pos","Error","indexOf","slice","replace","Math","floor","toString","escapeRegExpCharacter","ch","previousIsBackslash","String","fromCharCode","generateRegExp","reg","match","flags","i","iz","characterInBrack","source","escapeAllowedCharacter","next","hex","toUpperCase","isDecimalDigit","escapeDisallowedCharacter","escapeDirective","quote","escapeString","singleQuotes","doubleQuotes","single","isIdentifierPartES5","flattenToString","arr","elem","Array","isArray","toSourceNodeWhenNeeded","generated","loc","name","start","line","column","noEmptySpace","join","left","right","leftSource","rightSource","leftCharCode","rightCharCode","isWhiteSpace","addIndent","stmt","withIndent","fn","previousBase","calculateSpaces","specialBase","array","j","spaces","sn","split","Number","MAX_VALUE","generateComment","addComments","save","tailingToStatement","fragment","extRange","range","prevRange","prefix","infix","suffix","count","leadingComments","extendedRange","substring","push","Program","body","trailingComments","generateBlankLines","end","newlineCount","parenthesize","text","current","should","generateVerbatimString","string","generateVerbatim","expr","precedence","prec","content","prototype","maybeBlock","noLeadingComment","that","BlockStatement","generateStatement","EmptyStatement","maybeBlockSuffix","ends","generateIdentifier","generateAsyncPrefix","spaceRequired","async","generateStarSuffix","isGenerator","generator","generateMethodPrefix","prop","func","computed","generatePattern","Identifier","generateExpression","generateFunctionParams","hasDefault","ArrowFunctionExpression","rest","defaults","params","generateAssignment","generateFunctionBody","expression","charAt","generateIterationForStatement","operator","await","VariableDeclaration","kind","declarations","generatePropertyKey","semicolon","bodyFlags","BreakStatement","label","ContinueStatement","ClassBody","ClassDeclaration","id","superClass","DirectiveStatement","DoWhileStatement","CatchClause","guard","param","splice","DebuggerStatement","ExportDefaultDeclaration","declaration","ExportNamedDeclaration","specifiers","ExportBatchSpecifier","ExportAllDeclaration","ExpressionStatement","isClassPrefixed","isFunctionPrefixed","isAsyncPrefixed","Literal","ImportDeclaration","cursor","ImportDefaultSpecifier","ImportNamespaceSpecifier","VariableDeclarator","itemFlags","init","block","ThrowStatement","argument","TryStatement","guardedHandlers","handlers","finalizer","handler","SwitchStatement","discriminant","cases","SwitchCase","consequent","IfStatement","semicolonOptional","alternate","ForStatement","update","ForInStatement","ForOfStatement","LabeledStatement","FunctionDeclaration","ReturnStatement","WhileStatement","WithStatement","object","SequenceExpression","expressions","AssignmentExpression","ConditionalExpression","LogicalExpression","BinaryExpression","leftPrecedence","rightPrecedence","currentPrecedence","CallExpression","callee","optional","ChainExpression","NewExpression","MemberExpression","property","MetaProperty","meta","UnaryExpression","YieldExpression","delegate","AwaitExpression","all","UpdateExpression","FunctionExpression","ArrayPattern","ArrayExpression","isPattern","multiline","elements","RestElement","ClassExpression","MethodDefinition","Property","shorthand","AssignmentPattern","method","ObjectExpression","properties","ObjectPattern","ThisExpression","Super","local","ImportSpecifier","imported","ExportSpecifier","exported","e","regex","pattern","GeneratorExpression","ComprehensionExpression","blocks","filter","ComprehensionBlock","of","SpreadElement","TaggedTemplateExpression","tag","quasi","TemplateElement","TemplateLiteral","quasis","ModuleSpecifier","ImportExpression","flag","replaceRight","generateInternal","codegen","generate","options","defaultOptions","pair","exports","browser","global","map","toStringWithSourceMap","file","sourceRoot","sourceContent","setSourceContent","version","attachComments"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/escodegen/escodegen.js"],"sourcesContent":["/*\r\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\r\n  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>\r\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\r\n  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\r\n  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>\r\n  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>\r\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\r\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\r\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\r\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\r\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\r\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\r\n\r\n  Redistribution and use in source and binary forms, with or without\r\n  modification, are permitted provided that the following conditions are met:\r\n\r\n    * Redistributions of source code must retain the above copyright\r\n      notice, this list of conditions and the following disclaimer.\r\n    * Redistributions in binary form must reproduce the above copyright\r\n      notice, this list of conditions and the following disclaimer in the\r\n      documentation and/or other materials provided with the distribution.\r\n\r\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n\r\n/*global exports:true, require:true, global:true*/\r\n(function () {\r\n    'use strict';\r\n\r\n    var Syntax,\r\n        Precedence,\r\n        BinaryPrecedence,\r\n        SourceNode,\r\n        estraverse,\r\n        esutils,\r\n        base,\r\n        indent,\r\n        json,\r\n        renumber,\r\n        hexadecimal,\r\n        quotes,\r\n        escapeless,\r\n        newline,\r\n        space,\r\n        parentheses,\r\n        semicolons,\r\n        safeConcatenation,\r\n        directive,\r\n        extra,\r\n        parse,\r\n        sourceMap,\r\n        sourceCode,\r\n        preserveBlankLines,\r\n        FORMAT_MINIFY,\r\n        FORMAT_DEFAULTS;\r\n\r\n    estraverse = require('estraverse');\r\n    esutils = require('esutils');\r\n\r\n    Syntax = estraverse.Syntax;\r\n\r\n    // Generation is done by generateExpression.\r\n    function isExpression(node) {\r\n        return CodeGenerator.Expression.hasOwnProperty(node.type);\r\n    }\r\n\r\n    // Generation is done by generateStatement.\r\n    function isStatement(node) {\r\n        return CodeGenerator.Statement.hasOwnProperty(node.type);\r\n    }\r\n\r\n    Precedence = {\r\n        Sequence: 0,\r\n        Yield: 1,\r\n        Assignment: 1,\r\n        Conditional: 2,\r\n        ArrowFunction: 2,\r\n        LogicalOR: 3,\r\n        LogicalAND: 4,\r\n        BitwiseOR: 5,\r\n        BitwiseXOR: 6,\r\n        BitwiseAND: 7,\r\n        Equality: 8,\r\n        Relational: 9,\r\n        BitwiseSHIFT: 10,\r\n        Additive: 11,\r\n        Multiplicative: 12,\r\n        Exponentiation: 13,\r\n        Await: 14,\r\n        Unary: 14,\r\n        Postfix: 15,\r\n        OptionalChaining: 16,\r\n        Call: 17,\r\n        New: 18,\r\n        TaggedTemplate: 19,\r\n        Member: 20,\r\n        Primary: 21\r\n    };\r\n\r\n    BinaryPrecedence = {\r\n        '||': Precedence.LogicalOR,\r\n        '&&': Precedence.LogicalAND,\r\n        '|': Precedence.BitwiseOR,\r\n        '^': Precedence.BitwiseXOR,\r\n        '&': Precedence.BitwiseAND,\r\n        '==': Precedence.Equality,\r\n        '!=': Precedence.Equality,\r\n        '===': Precedence.Equality,\r\n        '!==': Precedence.Equality,\r\n        'is': Precedence.Equality,\r\n        'isnt': Precedence.Equality,\r\n        '<': Precedence.Relational,\r\n        '>': Precedence.Relational,\r\n        '<=': Precedence.Relational,\r\n        '>=': Precedence.Relational,\r\n        'in': Precedence.Relational,\r\n        'instanceof': Precedence.Relational,\r\n        '<<': Precedence.BitwiseSHIFT,\r\n        '>>': Precedence.BitwiseSHIFT,\r\n        '>>>': Precedence.BitwiseSHIFT,\r\n        '+': Precedence.Additive,\r\n        '-': Precedence.Additive,\r\n        '*': Precedence.Multiplicative,\r\n        '%': Precedence.Multiplicative,\r\n        '/': Precedence.Multiplicative,\r\n        '**': Precedence.Exponentiation\r\n    };\r\n\r\n    //Flags\r\n    var F_ALLOW_IN = 1,\r\n        F_ALLOW_CALL = 1 << 1,\r\n        F_ALLOW_UNPARATH_NEW = 1 << 2,\r\n        F_FUNC_BODY = 1 << 3,\r\n        F_DIRECTIVE_CTX = 1 << 4,\r\n        F_SEMICOLON_OPT = 1 << 5;\r\n\r\n    //Expression flag sets\r\n    //NOTE: Flag order:\r\n    // F_ALLOW_IN\r\n    // F_ALLOW_CALL\r\n    // F_ALLOW_UNPARATH_NEW\r\n    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\r\n        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,\r\n        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\r\n        E_TFF = F_ALLOW_IN,\r\n        E_FFT = F_ALLOW_UNPARATH_NEW,\r\n        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;\r\n\r\n    //Statement flag sets\r\n    //NOTE: Flag order:\r\n    // F_ALLOW_IN\r\n    // F_FUNC_BODY\r\n    // F_DIRECTIVE_CTX\r\n    // F_SEMICOLON_OPT\r\n    var S_TFFF = F_ALLOW_IN,\r\n        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,\r\n        S_FFFF = 0x00,\r\n        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,\r\n        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\r\n\r\n    function getDefaultOptions() {\r\n        // default options\r\n        return {\r\n            indent: null,\r\n            base: null,\r\n            parse: null,\r\n            comment: false,\r\n            format: {\r\n                indent: {\r\n                    style: '    ',\r\n                    base: 0,\r\n                    adjustMultilineComment: false\r\n                },\r\n                newline: '\\n',\r\n                space: ' ',\r\n                json: false,\r\n                renumber: false,\r\n                hexadecimal: false,\r\n                quotes: 'single',\r\n                escapeless: false,\r\n                compact: false,\r\n                parentheses: true,\r\n                semicolons: true,\r\n                safeConcatenation: false,\r\n                preserveBlankLines: false\r\n            },\r\n            moz: {\r\n                comprehensionExpressionStartsWithAssignment: false,\r\n                starlessGenerator: false\r\n            },\r\n            sourceMap: null,\r\n            sourceMapRoot: null,\r\n            sourceMapWithCode: false,\r\n            directive: false,\r\n            raw: true,\r\n            verbatim: null,\r\n            sourceCode: null\r\n        };\r\n    }\r\n\r\n    function stringRepeat(str, num) {\r\n        var result = '';\r\n\r\n        for (num |= 0; num > 0; num >>>= 1, str += str) {\r\n            if (num & 1) {\r\n                result += str;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function hasLineTerminator(str) {\r\n        return (/[\\r\\n]/g).test(str);\r\n    }\r\n\r\n    function endsWithLineTerminator(str) {\r\n        var len = str.length;\r\n        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\r\n    }\r\n\r\n    function merge(target, override) {\r\n        var key;\r\n        for (key in override) {\r\n            if (override.hasOwnProperty(key)) {\r\n                target[key] = override[key];\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    function updateDeeply(target, override) {\r\n        var key, val;\r\n\r\n        function isHashObject(target) {\r\n            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);\r\n        }\r\n\r\n        for (key in override) {\r\n            if (override.hasOwnProperty(key)) {\r\n                val = override[key];\r\n                if (isHashObject(val)) {\r\n                    if (isHashObject(target[key])) {\r\n                        updateDeeply(target[key], val);\r\n                    } else {\r\n                        target[key] = updateDeeply({}, val);\r\n                    }\r\n                } else {\r\n                    target[key] = val;\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    function generateNumber(value) {\r\n        var result, point, temp, exponent, pos;\r\n\r\n        if (value !== value) {\r\n            throw new Error('Numeric literal whose value is NaN');\r\n        }\r\n        if (value < 0 || (value === 0 && 1 / value < 0)) {\r\n            throw new Error('Numeric literal whose value is negative');\r\n        }\r\n\r\n        if (value === 1 / 0) {\r\n            return json ? 'null' : renumber ? '1e400' : '1e+400';\r\n        }\r\n\r\n        result = '' + value;\r\n        if (!renumber || result.length < 3) {\r\n            return result;\r\n        }\r\n\r\n        point = result.indexOf('.');\r\n        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {\r\n            point = 0;\r\n            result = result.slice(1);\r\n        }\r\n        temp = result;\r\n        result = result.replace('e+', 'e');\r\n        exponent = 0;\r\n        if ((pos = temp.indexOf('e')) > 0) {\r\n            exponent = +temp.slice(pos + 1);\r\n            temp = temp.slice(0, pos);\r\n        }\r\n        if (point >= 0) {\r\n            exponent -= temp.length - point - 1;\r\n            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';\r\n        }\r\n        pos = 0;\r\n        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {\r\n            --pos;\r\n        }\r\n        if (pos !== 0) {\r\n            exponent -= pos;\r\n            temp = temp.slice(0, pos);\r\n        }\r\n        if (exponent !== 0) {\r\n            temp += 'e' + exponent;\r\n        }\r\n        if ((temp.length < result.length ||\r\n                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&\r\n                +temp === value) {\r\n            result = temp;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Generate valid RegExp expression.\r\n    // This function is based on https://github.com/Constellation/iv Engine\r\n\r\n    function escapeRegExpCharacter(ch, previousIsBackslash) {\r\n        // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\r\n        if ((ch & ~1) === 0x2028) {\r\n            return (previousIsBackslash ? 'u' : '\\\\u') + ((ch === 0x2028) ? '2028' : '2029');\r\n        } else if (ch === 10 || ch === 13) {  // \\n, \\r\r\n            return (previousIsBackslash ? '' : '\\\\') + ((ch === 10) ? 'n' : 'r');\r\n        }\r\n        return String.fromCharCode(ch);\r\n    }\r\n\r\n    function generateRegExp(reg) {\r\n        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\r\n\r\n        result = reg.toString();\r\n\r\n        if (reg.source) {\r\n            // extract flag from toString result\r\n            match = result.match(/\\/([^/]*)$/);\r\n            if (!match) {\r\n                return result;\r\n            }\r\n\r\n            flags = match[1];\r\n            result = '';\r\n\r\n            characterInBrack = false;\r\n            previousIsBackslash = false;\r\n            for (i = 0, iz = reg.source.length; i < iz; ++i) {\r\n                ch = reg.source.charCodeAt(i);\r\n\r\n                if (!previousIsBackslash) {\r\n                    if (characterInBrack) {\r\n                        if (ch === 93) {  // ]\r\n                            characterInBrack = false;\r\n                        }\r\n                    } else {\r\n                        if (ch === 47) {  // /\r\n                            result += '\\\\';\r\n                        } else if (ch === 91) {  // [\r\n                            characterInBrack = true;\r\n                        }\r\n                    }\r\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\r\n                    previousIsBackslash = ch === 92;  // \\\r\n                } else {\r\n                    // if new RegExp(\"\\\\\\n') is provided, create /\\n/\r\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\r\n                    // prevent like /\\\\[/]/\r\n                    previousIsBackslash = false;\r\n                }\r\n            }\r\n\r\n            return '/' + result + '/' + flags;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function escapeAllowedCharacter(code, next) {\r\n        var hex;\r\n\r\n        if (code === 0x08  /* \\b */) {\r\n            return '\\\\b';\r\n        }\r\n\r\n        if (code === 0x0C  /* \\f */) {\r\n            return '\\\\f';\r\n        }\r\n\r\n        if (code === 0x09  /* \\t */) {\r\n            return '\\\\t';\r\n        }\r\n\r\n        hex = code.toString(16).toUpperCase();\r\n        if (json || code > 0xFF) {\r\n            return '\\\\u' + '0000'.slice(hex.length) + hex;\r\n        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {\r\n            return '\\\\0';\r\n        } else if (code === 0x000B  /* \\v */) { // '\\v'\r\n            return '\\\\x0B';\r\n        } else {\r\n            return '\\\\x' + '00'.slice(hex.length) + hex;\r\n        }\r\n    }\r\n\r\n    function escapeDisallowedCharacter(code) {\r\n        if (code === 0x5C  /* \\ */) {\r\n            return '\\\\\\\\';\r\n        }\r\n\r\n        if (code === 0x0A  /* \\n */) {\r\n            return '\\\\n';\r\n        }\r\n\r\n        if (code === 0x0D  /* \\r */) {\r\n            return '\\\\r';\r\n        }\r\n\r\n        if (code === 0x2028) {\r\n            return '\\\\u2028';\r\n        }\r\n\r\n        if (code === 0x2029) {\r\n            return '\\\\u2029';\r\n        }\r\n\r\n        throw new Error('Incorrectly classified character');\r\n    }\r\n\r\n    function escapeDirective(str) {\r\n        var i, iz, code, quote;\r\n\r\n        quote = quotes === 'double' ? '\"' : '\\'';\r\n        for (i = 0, iz = str.length; i < iz; ++i) {\r\n            code = str.charCodeAt(i);\r\n            if (code === 0x27  /* ' */) {\r\n                quote = '\"';\r\n                break;\r\n            } else if (code === 0x22  /* \" */) {\r\n                quote = '\\'';\r\n                break;\r\n            } else if (code === 0x5C  /* \\ */) {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        return quote + str + quote;\r\n    }\r\n\r\n    function escapeString(str) {\r\n        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;\r\n\r\n        for (i = 0, len = str.length; i < len; ++i) {\r\n            code = str.charCodeAt(i);\r\n            if (code === 0x27  /* ' */) {\r\n                ++singleQuotes;\r\n            } else if (code === 0x22  /* \" */) {\r\n                ++doubleQuotes;\r\n            } else if (code === 0x2F  /* / */ && json) {\r\n                result += '\\\\';\r\n            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \\ */) {\r\n                result += escapeDisallowedCharacter(code);\r\n                continue;\r\n            } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20  /* SP */ || !json && !escapeless && (code < 0x20  /* SP */ || code > 0x7E  /* ~ */))) {\r\n                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\r\n                continue;\r\n            }\r\n            result += String.fromCharCode(code);\r\n        }\r\n\r\n        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));\r\n        quote = single ? '\\'' : '\"';\r\n\r\n        if (!(single ? singleQuotes : doubleQuotes)) {\r\n            return quote + result + quote;\r\n        }\r\n\r\n        str = result;\r\n        result = quote;\r\n\r\n        for (i = 0, len = str.length; i < len; ++i) {\r\n            code = str.charCodeAt(i);\r\n            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* \" */ && !single)) {\r\n                result += '\\\\';\r\n            }\r\n            result += String.fromCharCode(code);\r\n        }\r\n\r\n        return result + quote;\r\n    }\r\n\r\n    /**\r\n     * flatten an array to a string, where the array can contain\r\n     * either strings or nested arrays\r\n     */\r\n    function flattenToString(arr) {\r\n        var i, iz, elem, result = '';\r\n        for (i = 0, iz = arr.length; i < iz; ++i) {\r\n            elem = arr[i];\r\n            result += Array.isArray(elem) ? flattenToString(elem) : elem;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * convert generated to a SourceNode when source maps are enabled.\r\n     */\r\n    function toSourceNodeWhenNeeded(generated, node) {\r\n        if (!sourceMap) {\r\n            // with no source maps, generated is either an\r\n            // array or a string.  if an array, flatten it.\r\n            // if a string, just return it\r\n            if (Array.isArray(generated)) {\r\n                return flattenToString(generated);\r\n            } else {\r\n                return generated;\r\n            }\r\n        }\r\n        if (node == null) {\r\n            if (generated instanceof SourceNode) {\r\n                return generated;\r\n            } else {\r\n                node = {};\r\n            }\r\n        }\r\n        if (node.loc == null) {\r\n            return new SourceNode(null, null, sourceMap, generated, node.name || null);\r\n        }\r\n        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);\r\n    }\r\n\r\n    function noEmptySpace() {\r\n        return (space) ? space : ' ';\r\n    }\r\n\r\n    function join(left, right) {\r\n        var leftSource,\r\n            rightSource,\r\n            leftCharCode,\r\n            rightCharCode;\r\n\r\n        leftSource = toSourceNodeWhenNeeded(left).toString();\r\n        if (leftSource.length === 0) {\r\n            return [right];\r\n        }\r\n\r\n        rightSource = toSourceNodeWhenNeeded(right).toString();\r\n        if (rightSource.length === 0) {\r\n            return [left];\r\n        }\r\n\r\n        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\r\n        rightCharCode = rightSource.charCodeAt(0);\r\n\r\n        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||\r\n            esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) ||\r\n            leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`\r\n            return [left, noEmptySpace(), right];\r\n        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||\r\n                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {\r\n            return [left, right];\r\n        }\r\n        return [left, space, right];\r\n    }\r\n\r\n    function addIndent(stmt) {\r\n        return [base, stmt];\r\n    }\r\n\r\n    function withIndent(fn) {\r\n        var previousBase;\r\n        previousBase = base;\r\n        base += indent;\r\n        fn(base);\r\n        base = previousBase;\r\n    }\r\n\r\n    function calculateSpaces(str) {\r\n        var i;\r\n        for (i = str.length - 1; i >= 0; --i) {\r\n            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\r\n                break;\r\n            }\r\n        }\r\n        return (str.length - 1) - i;\r\n    }\r\n\r\n    function adjustMultilineComment(value, specialBase) {\r\n        var array, i, len, line, j, spaces, previousBase, sn;\r\n\r\n        array = value.split(/\\r\\n|[\\r\\n]/);\r\n        spaces = Number.MAX_VALUE;\r\n\r\n        // first line doesn't have indentation\r\n        for (i = 1, len = array.length; i < len; ++i) {\r\n            line = array[i];\r\n            j = 0;\r\n            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {\r\n                ++j;\r\n            }\r\n            if (spaces > j) {\r\n                spaces = j;\r\n            }\r\n        }\r\n\r\n        if (typeof specialBase !== 'undefined') {\r\n            // pattern like\r\n            // {\r\n            //   var t = 20;  /*\r\n            //                 * this is comment\r\n            //                 */\r\n            // }\r\n            previousBase = base;\r\n            if (array[1][spaces] === '*') {\r\n                specialBase += ' ';\r\n            }\r\n            base = specialBase;\r\n        } else {\r\n            if (spaces & 1) {\r\n                // /*\r\n                //  *\r\n                //  */\r\n                // If spaces are odd number, above pattern is considered.\r\n                // We waste 1 space.\r\n                --spaces;\r\n            }\r\n            previousBase = base;\r\n        }\r\n\r\n        for (i = 1, len = array.length; i < len; ++i) {\r\n            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\r\n            array[i] = sourceMap ? sn.join('') : sn;\r\n        }\r\n\r\n        base = previousBase;\r\n\r\n        return array.join('\\n');\r\n    }\r\n\r\n    function generateComment(comment, specialBase) {\r\n        if (comment.type === 'Line') {\r\n            if (endsWithLineTerminator(comment.value)) {\r\n                return '//' + comment.value;\r\n            } else {\r\n                // Always use LineTerminator\r\n                var result = '//' + comment.value;\r\n                if (!preserveBlankLines) {\r\n                    result += '\\n';\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\r\n            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);\r\n        }\r\n        return '/*' + comment.value + '*/';\r\n    }\r\n\r\n    function addComments(stmt, result) {\r\n        var i, len, comment, save, tailingToStatement, specialBase, fragment,\r\n            extRange, range, prevRange, prefix, infix, suffix, count;\r\n\r\n        if (stmt.leadingComments && stmt.leadingComments.length > 0) {\r\n            save = result;\r\n\r\n            if (preserveBlankLines) {\r\n                comment = stmt.leadingComments[0];\r\n                result = [];\r\n\r\n                extRange = comment.extendedRange;\r\n                range = comment.range;\r\n\r\n                prefix = sourceCode.substring(extRange[0], range[0]);\r\n                count = (prefix.match(/\\n/g) || []).length;\r\n                if (count > 0) {\r\n                    result.push(stringRepeat('\\n', count));\r\n                    result.push(addIndent(generateComment(comment)));\r\n                } else {\r\n                    result.push(prefix);\r\n                    result.push(generateComment(comment));\r\n                }\r\n\r\n                prevRange = range;\r\n\r\n                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {\r\n                    comment = stmt.leadingComments[i];\r\n                    range = comment.range;\r\n\r\n                    infix = sourceCode.substring(prevRange[1], range[0]);\r\n                    count = (infix.match(/\\n/g) || []).length;\r\n                    result.push(stringRepeat('\\n', count));\r\n                    result.push(addIndent(generateComment(comment)));\r\n\r\n                    prevRange = range;\r\n                }\r\n\r\n                suffix = sourceCode.substring(range[1], extRange[1]);\r\n                count = (suffix.match(/\\n/g) || []).length;\r\n                result.push(stringRepeat('\\n', count));\r\n            } else {\r\n                comment = stmt.leadingComments[0];\r\n                result = [];\r\n                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\r\n                    result.push('\\n');\r\n                }\r\n                result.push(generateComment(comment));\r\n                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\r\n                    result.push('\\n');\r\n                }\r\n\r\n                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {\r\n                    comment = stmt.leadingComments[i];\r\n                    fragment = [generateComment(comment)];\r\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\r\n                        fragment.push('\\n');\r\n                    }\r\n                    result.push(addIndent(fragment));\r\n                }\r\n            }\r\n\r\n            result.push(addIndent(save));\r\n        }\r\n\r\n        if (stmt.trailingComments) {\r\n\r\n            if (preserveBlankLines) {\r\n                comment = stmt.trailingComments[0];\r\n                extRange = comment.extendedRange;\r\n                range = comment.range;\r\n\r\n                prefix = sourceCode.substring(extRange[0], range[0]);\r\n                count = (prefix.match(/\\n/g) || []).length;\r\n\r\n                if (count > 0) {\r\n                    result.push(stringRepeat('\\n', count));\r\n                    result.push(addIndent(generateComment(comment)));\r\n                } else {\r\n                    result.push(prefix);\r\n                    result.push(generateComment(comment));\r\n                }\r\n            } else {\r\n                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\r\n                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));\r\n                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {\r\n                    comment = stmt.trailingComments[i];\r\n                    if (tailingToStatement) {\r\n                        // We assume target like following script\r\n                        //\r\n                        // var t = 20;  /**\r\n                        //               * This is comment of t\r\n                        //               */\r\n                        if (i === 0) {\r\n                            // first case\r\n                            result = [result, indent];\r\n                        } else {\r\n                            result = [result, specialBase];\r\n                        }\r\n                        result.push(generateComment(comment, specialBase));\r\n                    } else {\r\n                        result = [result, addIndent(generateComment(comment))];\r\n                    }\r\n                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\r\n                        result = [result, '\\n'];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function generateBlankLines(start, end, result) {\r\n        var j, newlineCount = 0;\r\n\r\n        for (j = start; j < end; j++) {\r\n            if (sourceCode[j] === '\\n') {\r\n                newlineCount++;\r\n            }\r\n        }\r\n\r\n        for (j = 1; j < newlineCount; j++) {\r\n            result.push(newline);\r\n        }\r\n    }\r\n\r\n    function parenthesize(text, current, should) {\r\n        if (current < should) {\r\n            return ['(', text, ')'];\r\n        }\r\n        return text;\r\n    }\r\n\r\n    function generateVerbatimString(string) {\r\n        var i, iz, result;\r\n        result = string.split(/\\r\\n|\\n/);\r\n        for (i = 1, iz = result.length; i < iz; i++) {\r\n            result[i] = newline + base + result[i];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function generateVerbatim(expr, precedence) {\r\n        var verbatim, result, prec;\r\n        verbatim = expr[extra.verbatim];\r\n\r\n        if (typeof verbatim === 'string') {\r\n            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);\r\n        } else {\r\n            // verbatim is object\r\n            result = generateVerbatimString(verbatim.content);\r\n            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;\r\n            result = parenthesize(result, prec, precedence);\r\n        }\r\n\r\n        return toSourceNodeWhenNeeded(result, expr);\r\n    }\r\n\r\n    function CodeGenerator() {\r\n    }\r\n\r\n    // Helpers.\r\n\r\n    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {\r\n        var result, noLeadingComment, that = this;\r\n\r\n        noLeadingComment = !extra.comment || !stmt.leadingComments;\r\n\r\n        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\r\n            return [space, this.generateStatement(stmt, flags)];\r\n        }\r\n\r\n        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\r\n            return ';';\r\n        }\r\n\r\n        withIndent(function () {\r\n            result = [\r\n                newline,\r\n                addIndent(that.generateStatement(stmt, flags))\r\n            ];\r\n        });\r\n\r\n        return result;\r\n    };\r\n\r\n    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {\r\n        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\r\n        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\r\n            return [result, space];\r\n        }\r\n        if (ends) {\r\n            return [result, base];\r\n        }\r\n        return [result, newline, base];\r\n    };\r\n\r\n    function generateIdentifier(node) {\r\n        return toSourceNodeWhenNeeded(node.name, node);\r\n    }\r\n\r\n    function generateAsyncPrefix(node, spaceRequired) {\r\n        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';\r\n    }\r\n\r\n    function generateStarSuffix(node) {\r\n        var isGenerator = node.generator && !extra.moz.starlessGenerator;\r\n        return isGenerator ? '*' + space : '';\r\n    }\r\n\r\n    function generateMethodPrefix(prop) {\r\n        var func = prop.value, prefix = '';\r\n        if (func.async) {\r\n            prefix += generateAsyncPrefix(func, !prop.computed);\r\n        }\r\n        if (func.generator) {\r\n            // avoid space before method name\r\n            prefix += generateStarSuffix(func) ? '*' : '';\r\n        }\r\n        return prefix;\r\n    }\r\n\r\n    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {\r\n        if (node.type === Syntax.Identifier) {\r\n            return generateIdentifier(node);\r\n        }\r\n        return this.generateExpression(node, precedence, flags);\r\n    };\r\n\r\n    CodeGenerator.prototype.generateFunctionParams = function (node) {\r\n        var i, iz, result, hasDefault;\r\n\r\n        hasDefault = false;\r\n\r\n        if (node.type === Syntax.ArrowFunctionExpression &&\r\n                !node.rest && (!node.defaults || node.defaults.length === 0) &&\r\n                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {\r\n            // arg => { } case\r\n            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];\r\n        } else {\r\n            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];\r\n            result.push('(');\r\n            if (node.defaults) {\r\n                hasDefault = true;\r\n            }\r\n            for (i = 0, iz = node.params.length; i < iz; ++i) {\r\n                if (hasDefault && node.defaults[i]) {\r\n                    // Handle default values.\r\n                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));\r\n                } else {\r\n                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));\r\n                }\r\n                if (i + 1 < iz) {\r\n                    result.push(',' + space);\r\n                }\r\n            }\r\n\r\n            if (node.rest) {\r\n                if (node.params.length) {\r\n                    result.push(',' + space);\r\n                }\r\n                result.push('...');\r\n                result.push(generateIdentifier(node.rest));\r\n            }\r\n\r\n            result.push(')');\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    CodeGenerator.prototype.generateFunctionBody = function (node) {\r\n        var result, expr;\r\n\r\n        result = this.generateFunctionParams(node);\r\n\r\n        if (node.type === Syntax.ArrowFunctionExpression) {\r\n            result.push(space);\r\n            result.push('=>');\r\n        }\r\n\r\n        if (node.expression) {\r\n            result.push(space);\r\n            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\r\n            if (expr.toString().charAt(0) === '{') {\r\n                expr = ['(', expr, ')'];\r\n            }\r\n            result.push(expr);\r\n        } else {\r\n            result.push(this.maybeBlock(node.body, S_TTFF));\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {\r\n        var result = ['for' + (stmt.await ? noEmptySpace() + 'await' : '') + space + '('], that = this;\r\n        withIndent(function () {\r\n            if (stmt.left.type === Syntax.VariableDeclaration) {\r\n                withIndent(function () {\r\n                    result.push(stmt.left.kind + noEmptySpace());\r\n                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));\r\n                });\r\n            } else {\r\n                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\r\n            }\r\n\r\n            result = join(result, operator);\r\n            result = [join(\r\n                result,\r\n                that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)\r\n            ), ')'];\r\n        });\r\n        result.push(this.maybeBlock(stmt.body, flags));\r\n        return result;\r\n    };\r\n\r\n    CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {\r\n        var result = [];\r\n\r\n        if (computed) {\r\n            result.push('[');\r\n        }\r\n\r\n        result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));\r\n\r\n        if (computed) {\r\n            result.push(']');\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {\r\n        if (Precedence.Assignment < precedence) {\r\n            flags |= F_ALLOW_IN;\r\n        }\r\n\r\n        return parenthesize(\r\n            [\r\n                this.generateExpression(left, Precedence.Call, flags),\r\n                space + operator + space,\r\n                this.generateExpression(right, Precedence.Assignment, flags)\r\n            ],\r\n            Precedence.Assignment,\r\n            precedence\r\n        );\r\n    };\r\n\r\n    CodeGenerator.prototype.semicolon = function (flags) {\r\n        if (!semicolons && flags & F_SEMICOLON_OPT) {\r\n            return '';\r\n        }\r\n        return ';';\r\n    };\r\n\r\n    // Statements.\r\n\r\n    CodeGenerator.Statement = {\r\n\r\n        BlockStatement: function (stmt, flags) {\r\n            var range, content, result = ['{', newline], that = this;\r\n\r\n            withIndent(function () {\r\n                // handle functions without any code\r\n                if (stmt.body.length === 0 && preserveBlankLines) {\r\n                    range = stmt.range;\r\n                    if (range[1] - range[0] > 2) {\r\n                        content = sourceCode.substring(range[0] + 1, range[1] - 1);\r\n                        if (content[0] === '\\n') {\r\n                            result = ['{'];\r\n                        }\r\n                        result.push(content);\r\n                    }\r\n                }\r\n\r\n                var i, iz, fragment, bodyFlags;\r\n                bodyFlags = S_TFFF;\r\n                if (flags & F_FUNC_BODY) {\r\n                    bodyFlags |= F_DIRECTIVE_CTX;\r\n                }\r\n\r\n                for (i = 0, iz = stmt.body.length; i < iz; ++i) {\r\n                    if (preserveBlankLines) {\r\n                        // handle spaces before the first line\r\n                        if (i === 0) {\r\n                            if (stmt.body[0].leadingComments) {\r\n                                range = stmt.body[0].leadingComments[0].extendedRange;\r\n                                content = sourceCode.substring(range[0], range[1]);\r\n                                if (content[0] === '\\n') {\r\n                                    result = ['{'];\r\n                                }\r\n                            }\r\n                            if (!stmt.body[0].leadingComments) {\r\n                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);\r\n                            }\r\n                        }\r\n\r\n                        // handle spaces between lines\r\n                        if (i > 0) {\r\n                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {\r\n                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (i === iz - 1) {\r\n                        bodyFlags |= F_SEMICOLON_OPT;\r\n                    }\r\n\r\n                    if (stmt.body[i].leadingComments && preserveBlankLines) {\r\n                        fragment = that.generateStatement(stmt.body[i], bodyFlags);\r\n                    } else {\r\n                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));\r\n                    }\r\n\r\n                    result.push(fragment);\r\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\r\n                        if (preserveBlankLines && i < iz - 1) {\r\n                            // don't add a new line if there are leading coments\r\n                            // in the next statement\r\n                            if (!stmt.body[i + 1].leadingComments) {\r\n                                result.push(newline);\r\n                            }\r\n                        } else {\r\n                            result.push(newline);\r\n                        }\r\n                    }\r\n\r\n                    if (preserveBlankLines) {\r\n                        // handle spaces after the last line\r\n                        if (i === iz - 1) {\r\n                            if (!stmt.body[i].trailingComments) {\r\n                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            result.push(addIndent('}'));\r\n            return result;\r\n        },\r\n\r\n        BreakStatement: function (stmt, flags) {\r\n            if (stmt.label) {\r\n                return 'break ' + stmt.label.name + this.semicolon(flags);\r\n            }\r\n            return 'break' + this.semicolon(flags);\r\n        },\r\n\r\n        ContinueStatement: function (stmt, flags) {\r\n            if (stmt.label) {\r\n                return 'continue ' + stmt.label.name + this.semicolon(flags);\r\n            }\r\n            return 'continue' + this.semicolon(flags);\r\n        },\r\n\r\n        ClassBody: function (stmt, flags) {\r\n            var result = [ '{', newline], that = this;\r\n\r\n            withIndent(function (indent) {\r\n                var i, iz;\r\n\r\n                for (i = 0, iz = stmt.body.length; i < iz; ++i) {\r\n                    result.push(indent);\r\n                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));\r\n                    if (i + 1 < iz) {\r\n                        result.push(newline);\r\n                    }\r\n                }\r\n            });\r\n\r\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\r\n                result.push(newline);\r\n            }\r\n            result.push(base);\r\n            result.push('}');\r\n            return result;\r\n        },\r\n\r\n        ClassDeclaration: function (stmt, flags) {\r\n            var result, fragment;\r\n            result  = ['class'];\r\n            if (stmt.id) {\r\n                result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));\r\n            }\r\n            if (stmt.superClass) {\r\n                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));\r\n                result = join(result, fragment);\r\n            }\r\n            result.push(space);\r\n            result.push(this.generateStatement(stmt.body, S_TFFT));\r\n            return result;\r\n        },\r\n\r\n        DirectiveStatement: function (stmt, flags) {\r\n            if (extra.raw && stmt.raw) {\r\n                return stmt.raw + this.semicolon(flags);\r\n            }\r\n            return escapeDirective(stmt.directive) + this.semicolon(flags);\r\n        },\r\n\r\n        DoWhileStatement: function (stmt, flags) {\r\n            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\r\n            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));\r\n            result = this.maybeBlockSuffix(stmt.body, result);\r\n            return join(result, [\r\n                'while' + space + '(',\r\n                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\r\n                ')' + this.semicolon(flags)\r\n            ]);\r\n        },\r\n\r\n        CatchClause: function (stmt, flags) {\r\n            var result, that = this;\r\n            withIndent(function () {\r\n                var guard;\r\n\r\n                if (stmt.param) {\r\n                    result = [\r\n                        'catch' + space + '(',\r\n                        that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),\r\n                        ')'\r\n                    ];\r\n\r\n                    if (stmt.guard) {\r\n                        guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);\r\n                        result.splice(2, 0, ' if ', guard);\r\n                    }\r\n                } else {\r\n                    result = ['catch'];\r\n                }\r\n            });\r\n            result.push(this.maybeBlock(stmt.body, S_TFFF));\r\n            return result;\r\n        },\r\n\r\n        DebuggerStatement: function (stmt, flags) {\r\n            return 'debugger' + this.semicolon(flags);\r\n        },\r\n\r\n        EmptyStatement: function (stmt, flags) {\r\n            return ';';\r\n        },\r\n\r\n        ExportDefaultDeclaration: function (stmt, flags) {\r\n            var result = [ 'export' ], bodyFlags;\r\n\r\n            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;\r\n\r\n            // export default HoistableDeclaration[Default]\r\n            // export default AssignmentExpression[In] ;\r\n            result = join(result, 'default');\r\n            if (isStatement(stmt.declaration)) {\r\n                result = join(result, this.generateStatement(stmt.declaration, bodyFlags));\r\n            } else {\r\n                result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));\r\n            }\r\n            return result;\r\n        },\r\n\r\n        ExportNamedDeclaration: function (stmt, flags) {\r\n            var result = [ 'export' ], bodyFlags, that = this;\r\n\r\n            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;\r\n\r\n            // export VariableStatement\r\n            // export Declaration[Default]\r\n            if (stmt.declaration) {\r\n                return join(result, this.generateStatement(stmt.declaration, bodyFlags));\r\n            }\r\n\r\n            // export ExportClause[NoReference] FromClause ;\r\n            // export ExportClause ;\r\n            if (stmt.specifiers) {\r\n                if (stmt.specifiers.length === 0) {\r\n                    result = join(result, '{' + space + '}');\r\n                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\r\n                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));\r\n                } else {\r\n                    result = join(result, '{');\r\n                    withIndent(function (indent) {\r\n                        var i, iz;\r\n                        result.push(newline);\r\n                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {\r\n                            result.push(indent);\r\n                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\r\n                            if (i + 1 < iz) {\r\n                                result.push(',' + newline);\r\n                            }\r\n                        }\r\n                    });\r\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\r\n                        result.push(newline);\r\n                    }\r\n                    result.push(base + '}');\r\n                }\r\n\r\n                if (stmt.source) {\r\n                    result = join(result, [\r\n                        'from' + space,\r\n                        // ModuleSpecifier\r\n                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\r\n                        this.semicolon(flags)\r\n                    ]);\r\n                } else {\r\n                    result.push(this.semicolon(flags));\r\n                }\r\n            }\r\n            return result;\r\n        },\r\n\r\n        ExportAllDeclaration: function (stmt, flags) {\r\n            // export * FromClause ;\r\n            return [\r\n                'export' + space,\r\n                '*' + space,\r\n                'from' + space,\r\n                // ModuleSpecifier\r\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\r\n                this.semicolon(flags)\r\n            ];\r\n        },\r\n\r\n        ExpressionStatement: function (stmt, flags) {\r\n            var result, fragment;\r\n\r\n            function isClassPrefixed(fragment) {\r\n                var code;\r\n                if (fragment.slice(0, 5) !== 'class') {\r\n                    return false;\r\n                }\r\n                code = fragment.charCodeAt(5);\r\n                return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);\r\n            }\r\n\r\n            function isFunctionPrefixed(fragment) {\r\n                var code;\r\n                if (fragment.slice(0, 8) !== 'function') {\r\n                    return false;\r\n                }\r\n                code = fragment.charCodeAt(8);\r\n                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);\r\n            }\r\n\r\n            function isAsyncPrefixed(fragment) {\r\n                var code, i, iz;\r\n                if (fragment.slice(0, 5) !== 'async') {\r\n                    return false;\r\n                }\r\n                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {\r\n                    return false;\r\n                }\r\n                for (i = 6, iz = fragment.length; i < iz; ++i) {\r\n                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (i === iz) {\r\n                    return false;\r\n                }\r\n                if (fragment.slice(i, i + 8) !== 'function') {\r\n                    return false;\r\n                }\r\n                code = fragment.charCodeAt(i + 8);\r\n                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);\r\n            }\r\n\r\n            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];\r\n            // 12.4 '{', 'function', 'class' is not allowed in this position.\r\n            // wrap expression with parentheses\r\n            fragment = toSourceNodeWhenNeeded(result).toString();\r\n            if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression\r\n                    isClassPrefixed(fragment) ||\r\n                    isFunctionPrefixed(fragment) ||\r\n                    isAsyncPrefixed(fragment) ||\r\n                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {\r\n                result = ['(', result, ')' + this.semicolon(flags)];\r\n            } else {\r\n                result.push(this.semicolon(flags));\r\n            }\r\n            return result;\r\n        },\r\n\r\n        ImportDeclaration: function (stmt, flags) {\r\n            // ES6: 15.2.1 valid import declarations:\r\n            //     - import ImportClause FromClause ;\r\n            //     - import ModuleSpecifier ;\r\n            var result, cursor, that = this;\r\n\r\n            // If no ImportClause is present,\r\n            // this should be `import ModuleSpecifier` so skip `from`\r\n            // ModuleSpecifier is StringLiteral.\r\n            if (stmt.specifiers.length === 0) {\r\n                // import ModuleSpecifier ;\r\n                return [\r\n                    'import',\r\n                    space,\r\n                    // ModuleSpecifier\r\n                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\r\n                    this.semicolon(flags)\r\n                ];\r\n            }\r\n\r\n            // import ImportClause FromClause ;\r\n            result = [\r\n                'import'\r\n            ];\r\n            cursor = 0;\r\n\r\n            // ImportedBinding\r\n            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\r\n                result = join(result, [\r\n                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\r\n                ]);\r\n                ++cursor;\r\n            }\r\n\r\n            if (stmt.specifiers[cursor]) {\r\n                if (cursor !== 0) {\r\n                    result.push(',');\r\n                }\r\n\r\n                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\r\n                    // NameSpaceImport\r\n                    result = join(result, [\r\n                            space,\r\n                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\r\n                    ]);\r\n                } else {\r\n                    // NamedImports\r\n                    result.push(space + '{');\r\n\r\n                    if ((stmt.specifiers.length - cursor) === 1) {\r\n                        // import { ... } from \"...\";\r\n                        result.push(space);\r\n                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));\r\n                        result.push(space + '}' + space);\r\n                    } else {\r\n                        // import {\r\n                        //    ...,\r\n                        //    ...,\r\n                        // } from \"...\";\r\n                        withIndent(function (indent) {\r\n                            var i, iz;\r\n                            result.push(newline);\r\n                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {\r\n                                result.push(indent);\r\n                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\r\n                                if (i + 1 < iz) {\r\n                                    result.push(',' + newline);\r\n                                }\r\n                            }\r\n                        });\r\n                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\r\n                            result.push(newline);\r\n                        }\r\n                        result.push(base + '}' + space);\r\n                    }\r\n                }\r\n            }\r\n\r\n            result = join(result, [\r\n                'from' + space,\r\n                // ModuleSpecifier\r\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\r\n                this.semicolon(flags)\r\n            ]);\r\n            return result;\r\n        },\r\n\r\n        VariableDeclarator: function (stmt, flags) {\r\n            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;\r\n            if (stmt.init) {\r\n                return [\r\n                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),\r\n                    space,\r\n                    '=',\r\n                    space,\r\n                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)\r\n                ];\r\n            }\r\n            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\r\n        },\r\n\r\n        VariableDeclaration: function (stmt, flags) {\r\n            // VariableDeclarator is typed as Statement,\r\n            // but joined with comma (not LineTerminator).\r\n            // So if comment is attached to target node, we should specialize.\r\n            var result, i, iz, node, bodyFlags, that = this;\r\n\r\n            result = [ stmt.kind ];\r\n\r\n            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;\r\n\r\n            function block() {\r\n                node = stmt.declarations[0];\r\n                if (extra.comment && node.leadingComments) {\r\n                    result.push('\\n');\r\n                    result.push(addIndent(that.generateStatement(node, bodyFlags)));\r\n                } else {\r\n                    result.push(noEmptySpace());\r\n                    result.push(that.generateStatement(node, bodyFlags));\r\n                }\r\n\r\n                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {\r\n                    node = stmt.declarations[i];\r\n                    if (extra.comment && node.leadingComments) {\r\n                        result.push(',' + newline);\r\n                        result.push(addIndent(that.generateStatement(node, bodyFlags)));\r\n                    } else {\r\n                        result.push(',' + space);\r\n                        result.push(that.generateStatement(node, bodyFlags));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (stmt.declarations.length > 1) {\r\n                withIndent(block);\r\n            } else {\r\n                block();\r\n            }\r\n\r\n            result.push(this.semicolon(flags));\r\n\r\n            return result;\r\n        },\r\n\r\n        ThrowStatement: function (stmt, flags) {\r\n            return [join(\r\n                'throw',\r\n                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)\r\n            ), this.semicolon(flags)];\r\n        },\r\n\r\n        TryStatement: function (stmt, flags) {\r\n            var result, i, iz, guardedHandlers;\r\n\r\n            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];\r\n            result = this.maybeBlockSuffix(stmt.block, result);\r\n\r\n            if (stmt.handlers) {\r\n                // old interface\r\n                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {\r\n                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));\r\n                    if (stmt.finalizer || i + 1 !== iz) {\r\n                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\r\n                    }\r\n                }\r\n            } else {\r\n                guardedHandlers = stmt.guardedHandlers || [];\r\n\r\n                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {\r\n                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));\r\n                    if (stmt.finalizer || i + 1 !== iz) {\r\n                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\r\n                    }\r\n                }\r\n\r\n                // new interface\r\n                if (stmt.handler) {\r\n                    if (Array.isArray(stmt.handler)) {\r\n                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {\r\n                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));\r\n                            if (stmt.finalizer || i + 1 !== iz) {\r\n                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));\r\n                        if (stmt.finalizer) {\r\n                            result = this.maybeBlockSuffix(stmt.handler.body, result);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (stmt.finalizer) {\r\n                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);\r\n            }\r\n            return result;\r\n        },\r\n\r\n        SwitchStatement: function (stmt, flags) {\r\n            var result, fragment, i, iz, bodyFlags, that = this;\r\n            withIndent(function () {\r\n                result = [\r\n                    'switch' + space + '(',\r\n                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),\r\n                    ')' + space + '{' + newline\r\n                ];\r\n            });\r\n            if (stmt.cases) {\r\n                bodyFlags = S_TFFF;\r\n                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {\r\n                    if (i === iz - 1) {\r\n                        bodyFlags |= F_SEMICOLON_OPT;\r\n                    }\r\n                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));\r\n                    result.push(fragment);\r\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\r\n                        result.push(newline);\r\n                    }\r\n                }\r\n            }\r\n            result.push(addIndent('}'));\r\n            return result;\r\n        },\r\n\r\n        SwitchCase: function (stmt, flags) {\r\n            var result, fragment, i, iz, bodyFlags, that = this;\r\n            withIndent(function () {\r\n                if (stmt.test) {\r\n                    result = [\r\n                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),\r\n                        ':'\r\n                    ];\r\n                } else {\r\n                    result = ['default:'];\r\n                }\r\n\r\n                i = 0;\r\n                iz = stmt.consequent.length;\r\n                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\r\n                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\r\n                    result.push(fragment);\r\n                    i = 1;\r\n                }\r\n\r\n                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\r\n                    result.push(newline);\r\n                }\r\n\r\n                bodyFlags = S_TFFF;\r\n                for (; i < iz; ++i) {\r\n                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\r\n                        bodyFlags |= F_SEMICOLON_OPT;\r\n                    }\r\n                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));\r\n                    result.push(fragment);\r\n                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\r\n                        result.push(newline);\r\n                    }\r\n                }\r\n            });\r\n            return result;\r\n        },\r\n\r\n        IfStatement: function (stmt, flags) {\r\n            var result, bodyFlags, semicolonOptional, that = this;\r\n            withIndent(function () {\r\n                result = [\r\n                    'if' + space + '(',\r\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\r\n                    ')'\r\n                ];\r\n            });\r\n            semicolonOptional = flags & F_SEMICOLON_OPT;\r\n            bodyFlags = S_TFFF;\r\n            if (semicolonOptional) {\r\n                bodyFlags |= F_SEMICOLON_OPT;\r\n            }\r\n            if (stmt.alternate) {\r\n                result.push(this.maybeBlock(stmt.consequent, S_TFFF));\r\n                result = this.maybeBlockSuffix(stmt.consequent, result);\r\n                if (stmt.alternate.type === Syntax.IfStatement) {\r\n                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);\r\n                } else {\r\n                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));\r\n                }\r\n            } else {\r\n                result.push(this.maybeBlock(stmt.consequent, bodyFlags));\r\n            }\r\n            return result;\r\n        },\r\n\r\n        ForStatement: function (stmt, flags) {\r\n            var result, that = this;\r\n            withIndent(function () {\r\n                result = ['for' + space + '('];\r\n                if (stmt.init) {\r\n                    if (stmt.init.type === Syntax.VariableDeclaration) {\r\n                        result.push(that.generateStatement(stmt.init, S_FFFF));\r\n                    } else {\r\n                        // F_ALLOW_IN becomes false.\r\n                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));\r\n                        result.push(';');\r\n                    }\r\n                } else {\r\n                    result.push(';');\r\n                }\r\n\r\n                if (stmt.test) {\r\n                    result.push(space);\r\n                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));\r\n                    result.push(';');\r\n                } else {\r\n                    result.push(';');\r\n                }\r\n\r\n                if (stmt.update) {\r\n                    result.push(space);\r\n                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));\r\n                    result.push(')');\r\n                } else {\r\n                    result.push(')');\r\n                }\r\n            });\r\n\r\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\r\n            return result;\r\n        },\r\n\r\n        ForInStatement: function (stmt, flags) {\r\n            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\r\n        },\r\n\r\n        ForOfStatement: function (stmt, flags) {\r\n            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\r\n        },\r\n\r\n        LabeledStatement: function (stmt, flags) {\r\n            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];\r\n        },\r\n\r\n        Program: function (stmt, flags) {\r\n            var result, fragment, i, iz, bodyFlags;\r\n            iz = stmt.body.length;\r\n            result = [safeConcatenation && iz > 0 ? '\\n' : ''];\r\n            bodyFlags = S_TFTF;\r\n            for (i = 0; i < iz; ++i) {\r\n                if (!safeConcatenation && i === iz - 1) {\r\n                    bodyFlags |= F_SEMICOLON_OPT;\r\n                }\r\n\r\n                if (preserveBlankLines) {\r\n                    // handle spaces before the first line\r\n                    if (i === 0) {\r\n                        if (!stmt.body[0].leadingComments) {\r\n                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);\r\n                        }\r\n                    }\r\n\r\n                    // handle spaces between lines\r\n                    if (i > 0) {\r\n                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\r\n                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\r\n                result.push(fragment);\r\n                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\r\n                    if (preserveBlankLines) {\r\n                        if (!stmt.body[i + 1].leadingComments) {\r\n                            result.push(newline);\r\n                        }\r\n                    } else {\r\n                        result.push(newline);\r\n                    }\r\n                }\r\n\r\n                if (preserveBlankLines) {\r\n                    // handle spaces after the last line\r\n                    if (i === iz - 1) {\r\n                        if (!stmt.body[i].trailingComments) {\r\n                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        },\r\n\r\n        FunctionDeclaration: function (stmt, flags) {\r\n            return [\r\n                generateAsyncPrefix(stmt, true),\r\n                'function',\r\n                generateStarSuffix(stmt) || noEmptySpace(),\r\n                stmt.id ? generateIdentifier(stmt.id) : '',\r\n                this.generateFunctionBody(stmt)\r\n            ];\r\n        },\r\n\r\n        ReturnStatement: function (stmt, flags) {\r\n            if (stmt.argument) {\r\n                return [join(\r\n                    'return',\r\n                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)\r\n                ), this.semicolon(flags)];\r\n            }\r\n            return ['return' + this.semicolon(flags)];\r\n        },\r\n\r\n        WhileStatement: function (stmt, flags) {\r\n            var result, that = this;\r\n            withIndent(function () {\r\n                result = [\r\n                    'while' + space + '(',\r\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\r\n                    ')'\r\n                ];\r\n            });\r\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\r\n            return result;\r\n        },\r\n\r\n        WithStatement: function (stmt, flags) {\r\n            var result, that = this;\r\n            withIndent(function () {\r\n                result = [\r\n                    'with' + space + '(',\r\n                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),\r\n                    ')'\r\n                ];\r\n            });\r\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\r\n            return result;\r\n        }\r\n\r\n    };\r\n\r\n    merge(CodeGenerator.prototype, CodeGenerator.Statement);\r\n\r\n    // Expressions.\r\n\r\n    CodeGenerator.Expression = {\r\n\r\n        SequenceExpression: function (expr, precedence, flags) {\r\n            var result, i, iz;\r\n            if (Precedence.Sequence < precedence) {\r\n                flags |= F_ALLOW_IN;\r\n            }\r\n            result = [];\r\n            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {\r\n                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));\r\n                if (i + 1 < iz) {\r\n                    result.push(',' + space);\r\n                }\r\n            }\r\n            return parenthesize(result, Precedence.Sequence, precedence);\r\n        },\r\n\r\n        AssignmentExpression: function (expr, precedence, flags) {\r\n            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);\r\n        },\r\n\r\n        ArrowFunctionExpression: function (expr, precedence, flags) {\r\n            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);\r\n        },\r\n\r\n        ConditionalExpression: function (expr, precedence, flags) {\r\n            if (Precedence.Conditional < precedence) {\r\n                flags |= F_ALLOW_IN;\r\n            }\r\n            return parenthesize(\r\n                [\r\n                    this.generateExpression(expr.test, Precedence.LogicalOR, flags),\r\n                    space + '?' + space,\r\n                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),\r\n                    space + ':' + space,\r\n                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)\r\n                ],\r\n                Precedence.Conditional,\r\n                precedence\r\n            );\r\n        },\r\n\r\n        LogicalExpression: function (expr, precedence, flags) {\r\n            return this.BinaryExpression(expr, precedence, flags);\r\n        },\r\n\r\n        BinaryExpression: function (expr, precedence, flags) {\r\n            var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;\r\n            currentPrecedence = BinaryPrecedence[expr.operator];\r\n            leftPrecedence = expr.operator === '**' ? Precedence.Postfix : currentPrecedence;\r\n            rightPrecedence = expr.operator === '**' ? currentPrecedence : currentPrecedence + 1;\r\n\r\n            if (currentPrecedence < precedence) {\r\n                flags |= F_ALLOW_IN;\r\n            }\r\n\r\n            fragment = this.generateExpression(expr.left, leftPrecedence, flags);\r\n\r\n            leftSource = fragment.toString();\r\n\r\n            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {\r\n                result = [fragment, noEmptySpace(), expr.operator];\r\n            } else {\r\n                result = join(fragment, expr.operator);\r\n            }\r\n\r\n            fragment = this.generateExpression(expr.right, rightPrecedence, flags);\r\n\r\n            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||\r\n            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {\r\n                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start\r\n                result.push(noEmptySpace());\r\n                result.push(fragment);\r\n            } else {\r\n                result = join(result, fragment);\r\n            }\r\n\r\n            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {\r\n                return ['(', result, ')'];\r\n            }\r\n            return parenthesize(result, currentPrecedence, precedence);\r\n        },\r\n\r\n        CallExpression: function (expr, precedence, flags) {\r\n            var result, i, iz;\r\n\r\n            // F_ALLOW_UNPARATH_NEW becomes false.\r\n            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];\r\n\r\n            if (expr.optional) {\r\n                result.push('?.');\r\n            }\r\n\r\n            result.push('(');\r\n            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {\r\n                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\r\n                if (i + 1 < iz) {\r\n                    result.push(',' + space);\r\n                }\r\n            }\r\n            result.push(')');\r\n\r\n            if (!(flags & F_ALLOW_CALL)) {\r\n                return ['(', result, ')'];\r\n            }\r\n\r\n            return parenthesize(result, Precedence.Call, precedence);\r\n        },\r\n\r\n        ChainExpression: function (expr, precedence, flags) {\r\n            if (Precedence.OptionalChaining < precedence) {\r\n                flags |= F_ALLOW_CALL;\r\n            }\r\n\r\n            var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);\r\n\r\n            return parenthesize(result, Precedence.OptionalChaining, precedence);\r\n        },\r\n\r\n        NewExpression: function (expr, precedence, flags) {\r\n            var result, length, i, iz, itemFlags;\r\n            length = expr['arguments'].length;\r\n\r\n            // F_ALLOW_CALL becomes false.\r\n            // F_ALLOW_UNPARATH_NEW may become false.\r\n            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;\r\n\r\n            result = join(\r\n                'new',\r\n                this.generateExpression(expr.callee, Precedence.New, itemFlags)\r\n            );\r\n\r\n            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\r\n                result.push('(');\r\n                for (i = 0, iz = length; i < iz; ++i) {\r\n                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\r\n                    if (i + 1 < iz) {\r\n                        result.push(',' + space);\r\n                    }\r\n                }\r\n                result.push(')');\r\n            }\r\n\r\n            return parenthesize(result, Precedence.New, precedence);\r\n        },\r\n\r\n        MemberExpression: function (expr, precedence, flags) {\r\n            var result, fragment;\r\n\r\n            // F_ALLOW_UNPARATH_NEW becomes false.\r\n            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];\r\n\r\n            if (expr.computed) {\r\n                if (expr.optional) {\r\n                    result.push('?.');\r\n                }\r\n\r\n                result.push('[');\r\n                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));\r\n                result.push(']');\r\n            } else {\r\n                if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {\r\n                    fragment = toSourceNodeWhenNeeded(result).toString();\r\n                    // When the following conditions are all true,\r\n                    //   1. No floating point\r\n                    //   2. Don't have exponents\r\n                    //   3. The last character is a decimal digit\r\n                    //   4. Not hexadecimal OR octal number literal\r\n                    // we should add a floating point.\r\n                    if (\r\n                            fragment.indexOf('.') < 0 &&\r\n                            !/[eExX]/.test(fragment) &&\r\n                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&\r\n                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'\r\n                            ) {\r\n                        result.push(' ');\r\n                    }\r\n                }\r\n                result.push(expr.optional ? '?.' : '.');\r\n                result.push(generateIdentifier(expr.property));\r\n            }\r\n\r\n            return parenthesize(result, Precedence.Member, precedence);\r\n        },\r\n\r\n        MetaProperty: function (expr, precedence, flags) {\r\n            var result;\r\n            result = [];\r\n            result.push(typeof expr.meta === \"string\" ? expr.meta : generateIdentifier(expr.meta));\r\n            result.push('.');\r\n            result.push(typeof expr.property === \"string\" ? expr.property : generateIdentifier(expr.property));\r\n            return parenthesize(result, Precedence.Member, precedence);\r\n        },\r\n\r\n        UnaryExpression: function (expr, precedence, flags) {\r\n            var result, fragment, rightCharCode, leftSource, leftCharCode;\r\n            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);\r\n\r\n            if (space === '') {\r\n                result = join(expr.operator, fragment);\r\n            } else {\r\n                result = [expr.operator];\r\n                if (expr.operator.length > 2) {\r\n                    // delete, void, typeof\r\n                    // get `typeof []`, not `typeof[]`\r\n                    result = join(result, fragment);\r\n                } else {\r\n                    // Prevent inserting spaces between operator and argument if it is unnecessary\r\n                    // like, `!cond`\r\n                    leftSource = toSourceNodeWhenNeeded(result).toString();\r\n                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\r\n                    rightCharCode = fragment.toString().charCodeAt(0);\r\n\r\n                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||\r\n                            (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {\r\n                        result.push(noEmptySpace());\r\n                        result.push(fragment);\r\n                    } else {\r\n                        result.push(fragment);\r\n                    }\r\n                }\r\n            }\r\n            return parenthesize(result, Precedence.Unary, precedence);\r\n        },\r\n\r\n        YieldExpression: function (expr, precedence, flags) {\r\n            var result;\r\n            if (expr.delegate) {\r\n                result = 'yield*';\r\n            } else {\r\n                result = 'yield';\r\n            }\r\n            if (expr.argument) {\r\n                result = join(\r\n                    result,\r\n                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)\r\n                );\r\n            }\r\n            return parenthesize(result, Precedence.Yield, precedence);\r\n        },\r\n\r\n        AwaitExpression: function (expr, precedence, flags) {\r\n            var result = join(\r\n                expr.all ? 'await*' : 'await',\r\n                this.generateExpression(expr.argument, Precedence.Await, E_TTT)\r\n            );\r\n            return parenthesize(result, Precedence.Await, precedence);\r\n        },\r\n\r\n        UpdateExpression: function (expr, precedence, flags) {\r\n            if (expr.prefix) {\r\n                return parenthesize(\r\n                    [\r\n                        expr.operator,\r\n                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)\r\n                    ],\r\n                    Precedence.Unary,\r\n                    precedence\r\n                );\r\n            }\r\n            return parenthesize(\r\n                [\r\n                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),\r\n                    expr.operator\r\n                ],\r\n                Precedence.Postfix,\r\n                precedence\r\n            );\r\n        },\r\n\r\n        FunctionExpression: function (expr, precedence, flags) {\r\n            var result = [\r\n                generateAsyncPrefix(expr, true),\r\n                'function'\r\n            ];\r\n            if (expr.id) {\r\n                result.push(generateStarSuffix(expr) || noEmptySpace());\r\n                result.push(generateIdentifier(expr.id));\r\n            } else {\r\n                result.push(generateStarSuffix(expr) || space);\r\n            }\r\n            result.push(this.generateFunctionBody(expr));\r\n            return result;\r\n        },\r\n\r\n        ArrayPattern: function (expr, precedence, flags) {\r\n            return this.ArrayExpression(expr, precedence, flags, true);\r\n        },\r\n\r\n        ArrayExpression: function (expr, precedence, flags, isPattern) {\r\n            var result, multiline, that = this;\r\n            if (!expr.elements.length) {\r\n                return '[]';\r\n            }\r\n            multiline = isPattern ? false : expr.elements.length > 1;\r\n            result = ['[', multiline ? newline : ''];\r\n            withIndent(function (indent) {\r\n                var i, iz;\r\n                for (i = 0, iz = expr.elements.length; i < iz; ++i) {\r\n                    if (!expr.elements[i]) {\r\n                        if (multiline) {\r\n                            result.push(indent);\r\n                        }\r\n                        if (i + 1 === iz) {\r\n                            result.push(',');\r\n                        }\r\n                    } else {\r\n                        result.push(multiline ? indent : '');\r\n                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));\r\n                    }\r\n                    if (i + 1 < iz) {\r\n                        result.push(',' + (multiline ? newline : space));\r\n                    }\r\n                }\r\n            });\r\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\r\n                result.push(newline);\r\n            }\r\n            result.push(multiline ? base : '');\r\n            result.push(']');\r\n            return result;\r\n        },\r\n\r\n        RestElement: function(expr, precedence, flags) {\r\n            return '...' + this.generatePattern(expr.argument);\r\n        },\r\n\r\n        ClassExpression: function (expr, precedence, flags) {\r\n            var result, fragment;\r\n            result = ['class'];\r\n            if (expr.id) {\r\n                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));\r\n            }\r\n            if (expr.superClass) {\r\n                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));\r\n                result = join(result, fragment);\r\n            }\r\n            result.push(space);\r\n            result.push(this.generateStatement(expr.body, S_TFFT));\r\n            return result;\r\n        },\r\n\r\n        MethodDefinition: function (expr, precedence, flags) {\r\n            var result, fragment;\r\n            if (expr['static']) {\r\n                result = ['static' + space];\r\n            } else {\r\n                result = [];\r\n            }\r\n            if (expr.kind === 'get' || expr.kind === 'set') {\r\n                fragment = [\r\n                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),\r\n                    this.generateFunctionBody(expr.value)\r\n                ];\r\n            } else {\r\n                fragment = [\r\n                    generateMethodPrefix(expr),\r\n                    this.generatePropertyKey(expr.key, expr.computed),\r\n                    this.generateFunctionBody(expr.value)\r\n                ];\r\n            }\r\n            return join(result, fragment);\r\n        },\r\n\r\n        Property: function (expr, precedence, flags) {\r\n            if (expr.kind === 'get' || expr.kind === 'set') {\r\n                return [\r\n                    expr.kind, noEmptySpace(),\r\n                    this.generatePropertyKey(expr.key, expr.computed),\r\n                    this.generateFunctionBody(expr.value)\r\n                ];\r\n            }\r\n\r\n            if (expr.shorthand) {\r\n                if (expr.value.type === \"AssignmentPattern\") {\r\n                    return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);\r\n                }\r\n                return this.generatePropertyKey(expr.key, expr.computed);\r\n            }\r\n\r\n            if (expr.method) {\r\n                return [\r\n                    generateMethodPrefix(expr),\r\n                    this.generatePropertyKey(expr.key, expr.computed),\r\n                    this.generateFunctionBody(expr.value)\r\n                ];\r\n            }\r\n\r\n            return [\r\n                this.generatePropertyKey(expr.key, expr.computed),\r\n                ':' + space,\r\n                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)\r\n            ];\r\n        },\r\n\r\n        ObjectExpression: function (expr, precedence, flags) {\r\n            var multiline, result, fragment, that = this;\r\n\r\n            if (!expr.properties.length) {\r\n                return '{}';\r\n            }\r\n            multiline = expr.properties.length > 1;\r\n\r\n            withIndent(function () {\r\n                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);\r\n            });\r\n\r\n            if (!multiline) {\r\n                // issues 4\r\n                // Do not transform from\r\n                //   dejavu.Class.declare({\r\n                //       method2: function () {}\r\n                //   });\r\n                // to\r\n                //   dejavu.Class.declare({method2: function () {\r\n                //       }});\r\n                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\r\n                    return [ '{', space, fragment, space, '}' ];\r\n                }\r\n            }\r\n\r\n            withIndent(function (indent) {\r\n                var i, iz;\r\n                result = [ '{', newline, indent, fragment ];\r\n\r\n                if (multiline) {\r\n                    result.push(',' + newline);\r\n                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {\r\n                        result.push(indent);\r\n                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\r\n                        if (i + 1 < iz) {\r\n                            result.push(',' + newline);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\r\n                result.push(newline);\r\n            }\r\n            result.push(base);\r\n            result.push('}');\r\n            return result;\r\n        },\r\n\r\n        AssignmentPattern: function(expr, precedence, flags) {\r\n            return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);\r\n        },\r\n\r\n        ObjectPattern: function (expr, precedence, flags) {\r\n            var result, i, iz, multiline, property, that = this;\r\n            if (!expr.properties.length) {\r\n                return '{}';\r\n            }\r\n\r\n            multiline = false;\r\n            if (expr.properties.length === 1) {\r\n                property = expr.properties[0];\r\n                if (\r\n                    property.type === Syntax.Property\r\n                    && property.value.type !== Syntax.Identifier\r\n                ) {\r\n                    multiline = true;\r\n                }\r\n            } else {\r\n                for (i = 0, iz = expr.properties.length; i < iz; ++i) {\r\n                    property = expr.properties[i];\r\n                    if (\r\n                        property.type === Syntax.Property\r\n                        && !property.shorthand\r\n                    ) {\r\n                        multiline = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            result = ['{', multiline ? newline : '' ];\r\n\r\n            withIndent(function (indent) {\r\n                var i, iz;\r\n                for (i = 0, iz = expr.properties.length; i < iz; ++i) {\r\n                    result.push(multiline ? indent : '');\r\n                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\r\n                    if (i + 1 < iz) {\r\n                        result.push(',' + (multiline ? newline : space));\r\n                    }\r\n                }\r\n            });\r\n\r\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\r\n                result.push(newline);\r\n            }\r\n            result.push(multiline ? base : '');\r\n            result.push('}');\r\n            return result;\r\n        },\r\n\r\n        ThisExpression: function (expr, precedence, flags) {\r\n            return 'this';\r\n        },\r\n\r\n        Super: function (expr, precedence, flags) {\r\n            return 'super';\r\n        },\r\n\r\n        Identifier: function (expr, precedence, flags) {\r\n            return generateIdentifier(expr);\r\n        },\r\n\r\n        ImportDefaultSpecifier: function (expr, precedence, flags) {\r\n            return generateIdentifier(expr.id || expr.local);\r\n        },\r\n\r\n        ImportNamespaceSpecifier: function (expr, precedence, flags) {\r\n            var result = ['*'];\r\n            var id = expr.id || expr.local;\r\n            if (id) {\r\n                result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));\r\n            }\r\n            return result;\r\n        },\r\n\r\n        ImportSpecifier: function (expr, precedence, flags) {\r\n            var imported = expr.imported;\r\n            var result = [ imported.name ];\r\n            var local = expr.local;\r\n            if (local && local.name !== imported.name) {\r\n                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));\r\n            }\r\n            return result;\r\n        },\r\n\r\n        ExportSpecifier: function (expr, precedence, flags) {\r\n            var local = expr.local;\r\n            var result = [ local.name ];\r\n            var exported = expr.exported;\r\n            if (exported && exported.name !== local.name) {\r\n                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));\r\n            }\r\n            return result;\r\n        },\r\n\r\n        Literal: function (expr, precedence, flags) {\r\n            var raw;\r\n            if (expr.hasOwnProperty('raw') && parse && extra.raw) {\r\n                try {\r\n                    raw = parse(expr.raw).body[0].expression;\r\n                    if (raw.type === Syntax.Literal) {\r\n                        if (raw.value === expr.value) {\r\n                            return expr.raw;\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    // not use raw property\r\n                }\r\n            }\r\n\r\n            if (expr.regex) {\r\n              return '/' + expr.regex.pattern + '/' + expr.regex.flags;\r\n            }\r\n\r\n            if (expr.value === null) {\r\n                return 'null';\r\n            }\r\n\r\n            if (typeof expr.value === 'string') {\r\n                return escapeString(expr.value);\r\n            }\r\n\r\n            if (typeof expr.value === 'number') {\r\n                return generateNumber(expr.value);\r\n            }\r\n\r\n            if (typeof expr.value === 'boolean') {\r\n                return expr.value ? 'true' : 'false';\r\n            }\r\n\r\n            return generateRegExp(expr.value);\r\n        },\r\n\r\n        GeneratorExpression: function (expr, precedence, flags) {\r\n            return this.ComprehensionExpression(expr, precedence, flags);\r\n        },\r\n\r\n        ComprehensionExpression: function (expr, precedence, flags) {\r\n            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]\r\n            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6\r\n\r\n            var result, i, iz, fragment, that = this;\r\n            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];\r\n\r\n            if (extra.moz.comprehensionExpressionStartsWithAssignment) {\r\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\r\n                result.push(fragment);\r\n            }\r\n\r\n            if (expr.blocks) {\r\n                withIndent(function () {\r\n                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {\r\n                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);\r\n                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {\r\n                            result = join(result, fragment);\r\n                        } else {\r\n                            result.push(fragment);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            if (expr.filter) {\r\n                result = join(result, 'if' + space);\r\n                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);\r\n                result = join(result, [ '(', fragment, ')' ]);\r\n            }\r\n\r\n            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\r\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\r\n\r\n                result = join(result, fragment);\r\n            }\r\n\r\n            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');\r\n            return result;\r\n        },\r\n\r\n        ComprehensionBlock: function (expr, precedence, flags) {\r\n            var fragment;\r\n            if (expr.left.type === Syntax.VariableDeclaration) {\r\n                fragment = [\r\n                    expr.left.kind, noEmptySpace(),\r\n                    this.generateStatement(expr.left.declarations[0], S_FFFF)\r\n                ];\r\n            } else {\r\n                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\r\n            }\r\n\r\n            fragment = join(fragment, expr.of ? 'of' : 'in');\r\n            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));\r\n\r\n            return [ 'for' + space + '(', fragment, ')' ];\r\n        },\r\n\r\n        SpreadElement: function (expr, precedence, flags) {\r\n            return [\r\n                '...',\r\n                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)\r\n            ];\r\n        },\r\n\r\n        TaggedTemplateExpression: function (expr, precedence, flags) {\r\n            var itemFlags = E_TTF;\r\n            if (!(flags & F_ALLOW_CALL)) {\r\n                itemFlags = E_TFF;\r\n            }\r\n            var result = [\r\n                this.generateExpression(expr.tag, Precedence.Call, itemFlags),\r\n                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)\r\n            ];\r\n            return parenthesize(result, Precedence.TaggedTemplate, precedence);\r\n        },\r\n\r\n        TemplateElement: function (expr, precedence, flags) {\r\n            // Don't use \"cooked\". Since tagged template can use raw template\r\n            // representation. So if we do so, it breaks the script semantics.\r\n            return expr.value.raw;\r\n        },\r\n\r\n        TemplateLiteral: function (expr, precedence, flags) {\r\n            var result, i, iz;\r\n            result = [ '`' ];\r\n            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {\r\n                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));\r\n                if (i + 1 < iz) {\r\n                    result.push('${' + space);\r\n                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));\r\n                    result.push(space + '}');\r\n                }\r\n            }\r\n            result.push('`');\r\n            return result;\r\n        },\r\n\r\n        ModuleSpecifier: function (expr, precedence, flags) {\r\n            return this.Literal(expr, precedence, flags);\r\n        },\r\n\r\n        ImportExpression: function(expr, precedence, flag) {\r\n            return parenthesize([\r\n                'import(',\r\n                this.generateExpression(expr.source, Precedence.Assignment, E_TTT),\r\n                ')'\r\n            ], Precedence.Call, precedence);\r\n        }\r\n    };\r\n\r\n    merge(CodeGenerator.prototype, CodeGenerator.Expression);\r\n\r\n    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {\r\n        var result, type;\r\n\r\n        type = expr.type || Syntax.Property;\r\n\r\n        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\r\n            return generateVerbatim(expr, precedence);\r\n        }\r\n\r\n        result = this[type](expr, precedence, flags);\r\n\r\n\r\n        if (extra.comment) {\r\n            result = addComments(expr, result);\r\n        }\r\n        return toSourceNodeWhenNeeded(result, expr);\r\n    };\r\n\r\n    CodeGenerator.prototype.generateStatement = function (stmt, flags) {\r\n        var result,\r\n            fragment;\r\n\r\n        result = this[stmt.type](stmt, flags);\r\n\r\n        // Attach comments\r\n\r\n        if (extra.comment) {\r\n            result = addComments(stmt, result);\r\n        }\r\n\r\n        fragment = toSourceNodeWhenNeeded(result).toString();\r\n        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\\n') {\r\n            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, '') : fragment.replace(/\\s+$/, '');\r\n        }\r\n\r\n        return toSourceNodeWhenNeeded(result, stmt);\r\n    };\r\n\r\n    function generateInternal(node) {\r\n        var codegen;\r\n\r\n        codegen = new CodeGenerator();\r\n        if (isStatement(node)) {\r\n            return codegen.generateStatement(node, S_TFFF);\r\n        }\r\n\r\n        if (isExpression(node)) {\r\n            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\r\n        }\r\n\r\n        throw new Error('Unknown node type: ' + node.type);\r\n    }\r\n\r\n    function generate(node, options) {\r\n        var defaultOptions = getDefaultOptions(), result, pair;\r\n\r\n        if (options != null) {\r\n            // Obsolete options\r\n            //\r\n            //   `options.indent`\r\n            //   `options.base`\r\n            //\r\n            // Instead of them, we can use `option.format.indent`.\r\n            if (typeof options.indent === 'string') {\r\n                defaultOptions.format.indent.style = options.indent;\r\n            }\r\n            if (typeof options.base === 'number') {\r\n                defaultOptions.format.indent.base = options.base;\r\n            }\r\n            options = updateDeeply(defaultOptions, options);\r\n            indent = options.format.indent.style;\r\n            if (typeof options.base === 'string') {\r\n                base = options.base;\r\n            } else {\r\n                base = stringRepeat(indent, options.format.indent.base);\r\n            }\r\n        } else {\r\n            options = defaultOptions;\r\n            indent = options.format.indent.style;\r\n            base = stringRepeat(indent, options.format.indent.base);\r\n        }\r\n        json = options.format.json;\r\n        renumber = options.format.renumber;\r\n        hexadecimal = json ? false : options.format.hexadecimal;\r\n        quotes = json ? 'double' : options.format.quotes;\r\n        escapeless = options.format.escapeless;\r\n        newline = options.format.newline;\r\n        space = options.format.space;\r\n        if (options.format.compact) {\r\n            newline = space = indent = base = '';\r\n        }\r\n        parentheses = options.format.parentheses;\r\n        semicolons = options.format.semicolons;\r\n        safeConcatenation = options.format.safeConcatenation;\r\n        directive = options.directive;\r\n        parse = json ? null : options.parse;\r\n        sourceMap = options.sourceMap;\r\n        sourceCode = options.sourceCode;\r\n        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;\r\n        extra = options;\r\n\r\n        if (sourceMap) {\r\n            if (!exports.browser) {\r\n                // We assume environment is node.js\r\n                // And prevent from including source-map by browserify\r\n                SourceNode = require('source-map').SourceNode;\r\n            } else {\r\n                SourceNode = global.sourceMap.SourceNode;\r\n            }\r\n        }\r\n\r\n        result = generateInternal(node);\r\n\r\n        if (!sourceMap) {\r\n            pair = {code: result.toString(), map: null};\r\n            return options.sourceMapWithCode ? pair : pair.code;\r\n        }\r\n\r\n\r\n        pair = result.toStringWithSourceMap({\r\n            file: options.file,\r\n            sourceRoot: options.sourceMapRoot\r\n        });\r\n\r\n        if (options.sourceContent) {\r\n            pair.map.setSourceContent(options.sourceMap,\r\n                                      options.sourceContent);\r\n        }\r\n\r\n        if (options.sourceMapWithCode) {\r\n            return pair;\r\n        }\r\n\r\n        return pair.map.toString();\r\n    }\r\n\r\n    FORMAT_MINIFY = {\r\n        indent: {\r\n            style: '',\r\n            base: 0\r\n        },\r\n        renumber: true,\r\n        hexadecimal: true,\r\n        quotes: 'auto',\r\n        escapeless: true,\r\n        compact: true,\r\n        parentheses: false,\r\n        semicolons: false\r\n    };\r\n\r\n    FORMAT_DEFAULTS = getDefaultOptions().format;\r\n\r\n    exports.version = require('./package.json').version;\r\n    exports.generate = generate;\r\n    exports.attachComments = estraverse.attachComments;\r\n    exports.Precedence = updateDeeply({}, Precedence);\r\n    exports.browser = false;\r\n    exports.FORMAT_MINIFY = FORMAT_MINIFY;\r\n    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\r\n}());\r\n/* vim: set sw=4 ts=4 et tw=80 : */\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}