{"ast":null,"code":"\"use strict\";\n\nconst xnv = require(\"xml-name-validator\");\nconst attributeUtils = require(\"./attributes\");\nconst {\n  NAMESPACES,\n  VOID_ELEMENTS,\n  NODE_TYPES\n} = require(\"./constants\");\nconst XML_CHAR = /^(\\x09|\\x0A|\\x0D|[\\x20-\\uD7FF]|[\\uE000-\\uFFFD]|(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]))*$/;\nconst PUBID_CHAR = /^(\\x20|\\x0D|\\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;\nfunction asciiCaseInsensitiveMatch(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction recordNamespaceInformation(element, map, prefixMap) {\n  let defaultNamespaceAttrValue = null;\n  for (let i = 0; i < element.attributes.length; ++i) {\n    const attr = element.attributes[i];\n    if (attr.namespaceURI === NAMESPACES.XMLNS) {\n      if (attr.prefix === null) {\n        defaultNamespaceAttrValue = attr.value;\n        continue;\n      }\n      let namespaceDefinition = attr.value;\n      if (namespaceDefinition === NAMESPACES.XML) {\n        continue;\n      }\n      // This is exactly the other way than the spec says, but that's intended.\n      // All the maps coalesce null to the empty string (explained in the\n      // spec), so instead of doing that every time, just do it once here.\n      if (namespaceDefinition === null) {\n        namespaceDefinition = \"\";\n      }\n      if (namespaceDefinition in map && map[namespaceDefinition].includes(attr.localName)) {\n        continue;\n      }\n      if (!(namespaceDefinition in map)) {\n        map[namespaceDefinition] = [];\n      }\n      map[namespaceDefinition].push(attr.localName);\n      prefixMap[attr.localName] = namespaceDefinition;\n    }\n  }\n  return defaultNamespaceAttrValue;\n}\nfunction serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {\n    throw new Error(\"Failed to serialize XML: document type node publicId is not well-formed.\");\n  }\n  if (requireWellFormed && (!XML_CHAR.test(node.systemId) || node.systemId.includes('\"') && node.systemId.includes(\"'\"))) {\n    throw new Error(\"Failed to serialize XML: document type node systemId is not well-formed.\");\n  }\n  let markup = `<!DOCTYPE ${node.name}`;\n  if (node.publicId !== \"\") {\n    markup += ` PUBLIC \"${node.publicId}\"`;\n  } else if (node.systemId !== \"\") {\n    markup += \" SYSTEM\";\n  }\n  if (node.systemId !== \"\") {\n    markup += ` \"${node.systemId}\"`;\n  }\n  return markup + \">\";\n}\nfunction serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && (node.target.includes(\":\") || asciiCaseInsensitiveMatch(node.target, \"xml\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node target is not well-formed.\");\n  }\n  if (requireWellFormed && (!XML_CHAR.test(node.data) || node.data.includes(\"?>\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node data is not well-formed.\");\n  }\n  return `<?${node.target} ${node.data}?>`;\n}\nfunction serializeDocument(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && node.documentElement === null) {\n    throw new Error(\"Failed to serialize XML: document does not have a document element.\");\n  }\n  let serializedDocument = \"\";\n  for (const child of node.childNodes) {\n    serializedDocument += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n  }\n  return serializedDocument;\n}\nfunction serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs) {\n  let markup = \"\";\n  for (const child of node.childNodes) {\n    markup += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n  }\n  return markup;\n}\nfunction serializeText(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: text node data is not well-formed.\");\n  }\n  return node.data.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nfunction serializeComment(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: comment node data is not well-formed.\");\n  }\n  if (requireWellFormed && (node.data.includes(\"--\") || node.data.endsWith(\"-\"))) {\n    throw new Error(\"Failed to serialize XML: found hyphens in illegal places in comment node data.\");\n  }\n  return `<!--${node.data}-->`;\n}\nfunction serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && (node.localName.includes(\":\") || !xnv.name(node.localName))) {\n    throw new Error(\"Failed to serialize XML: element node localName is not a valid XML name.\");\n  }\n  let markup = \"<\";\n  let qualifiedName = \"\";\n  let skipEndTag = false;\n  let ignoreNamespaceDefinitionAttr = false;\n  const map = Object.assign({}, prefixMap);\n  const localPrefixesMap = Object.create(null);\n  const localDefaultNamespace = recordNamespaceInformation(node, map, localPrefixesMap);\n  let inheritedNs = namespace;\n  const ns = node.namespaceURI;\n  if (inheritedNs === ns) {\n    if (localDefaultNamespace !== null) {\n      ignoreNamespaceDefinitionAttr = true;\n    }\n    if (ns === NAMESPACES.XML) {\n      qualifiedName = \"xml:\" + node.localName;\n    } else {\n      qualifiedName = node.localName;\n    }\n    markup += qualifiedName;\n  } else {\n    let {\n      prefix\n    } = node;\n    let candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);\n    if (prefix === \"xmlns\") {\n      if (requireWellFormed) {\n        throw new Error(\"Failed to serialize XML: element nodes can't have a prefix of \\\"xmlns\\\".\");\n      }\n      candidatePrefix = \"xmlns\";\n    }\n    if (candidatePrefix !== null) {\n      qualifiedName = candidatePrefix + \":\" + node.localName;\n      if (localDefaultNamespace !== null && localDefaultNamespace !== NAMESPACES.XML) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n      markup += qualifiedName;\n    } else if (prefix !== null) {\n      if (prefix in localPrefixesMap) {\n        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);\n      }\n      if (map[ns]) {\n        map[ns].push(prefix);\n      } else {\n        map[ns] = [prefix];\n      }\n      qualifiedName = prefix + \":\" + node.localName;\n      markup += `${qualifiedName} xmlns:${prefix}=\"${attributeUtils.serializeAttributeValue(ns, requireWellFormed)}\"`;\n      if (localDefaultNamespace !== null) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {\n      ignoreNamespaceDefinitionAttr = true;\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += `${qualifiedName} xmlns=\"${attributeUtils.serializeAttributeValue(ns, requireWellFormed)}\"`;\n    } else {\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += qualifiedName;\n    }\n  }\n  markup += attributeUtils.serializeAttributes(node, map, localPrefixesMap, ignoreNamespaceDefinitionAttr, requireWellFormed, refs);\n  if (ns === NAMESPACES.HTML && node.childNodes.length === 0 && VOID_ELEMENTS.has(node.localName)) {\n    markup += \" /\";\n    skipEndTag = true;\n  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {\n    markup += \"/\";\n    skipEndTag = true;\n  }\n  markup += \">\";\n  if (skipEndTag) {\n    return markup;\n  }\n  if (ns === NAMESPACES.HTML && node.localName === \"template\") {\n    markup += xmlSerialization(node.content, inheritedNs, map, requireWellFormed, refs);\n  } else {\n    for (const child of node.childNodes) {\n      markup += xmlSerialization(child, inheritedNs, map, requireWellFormed, refs);\n    }\n  }\n  markup += `</${qualifiedName}>`;\n  return markup;\n}\nfunction serializeCDATASection(node) {\n  return \"<![CDATA[\" + node.data + \"]]>\";\n}\n\n/**\r\n * @param {{prefixIndex: number}} refs\r\n */\nfunction xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {\n  switch (node.nodeType) {\n    case NODE_TYPES.ELEMENT_NODE:\n      return serializeElement(node, namespace, prefixMap, requireWellFormed, refs);\n    case NODE_TYPES.DOCUMENT_NODE:\n      return serializeDocument(node, namespace, prefixMap, requireWellFormed, refs);\n    case NODE_TYPES.COMMENT_NODE:\n      return serializeComment(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.TEXT_NODE:\n      return serializeText(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs);\n    case NODE_TYPES.DOCUMENT_TYPE_NODE:\n      return serializeDocumentType(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:\n      return serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.ATTRIBUTE_NODE:\n      return \"\";\n    case NODE_TYPES.CDATA_SECTION_NODE:\n      return serializeCDATASection(node);\n    default:\n      throw new TypeError(\"Failed to serialize XML: only Nodes can be serialized.\");\n  }\n}\nmodule.exports = function (root) {\n  let {\n    requireWellFormed = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const namespacePrefixMap = Object.create(null);\n  namespacePrefixMap[\"http://www.w3.org/XML/1998/namespace\"] = [\"xml\"];\n  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {\n    prefixIndex: 1\n  });\n};","map":{"version":3,"names":["xnv","require","attributeUtils","NAMESPACES","VOID_ELEMENTS","NODE_TYPES","XML_CHAR","PUBID_CHAR","asciiCaseInsensitiveMatch","a","b","length","i","charCodeAt","recordNamespaceInformation","element","map","prefixMap","defaultNamespaceAttrValue","attributes","attr","namespaceURI","XMLNS","prefix","value","namespaceDefinition","XML","includes","localName","push","serializeDocumentType","node","namespace","requireWellFormed","test","publicId","Error","systemId","markup","name","serializeProcessingInstruction","target","data","serializeDocument","refs","documentElement","serializedDocument","child","childNodes","xmlSerialization","serializeDocumentFragment","serializeText","replace","serializeComment","endsWith","serializeElement","qualifiedName","skipEndTag","ignoreNamespaceDefinitionAttr","Object","assign","localPrefixesMap","create","localDefaultNamespace","inheritedNs","ns","candidatePrefix","preferredPrefixString","generatePrefix","prefixIndex","serializeAttributeValue","serializeAttributes","HTML","has","content","serializeCDATASection","nodeType","ELEMENT_NODE","DOCUMENT_NODE","COMMENT_NODE","TEXT_NODE","DOCUMENT_FRAGMENT_NODE","DOCUMENT_TYPE_NODE","PROCESSING_INSTRUCTION_NODE","ATTRIBUTE_NODE","CDATA_SECTION_NODE","TypeError","module","exports","root","arguments","undefined","namespacePrefixMap"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/w3c-xmlserializer/lib/serialize.js"],"sourcesContent":["\"use strict\";\r\n\r\nconst xnv = require(\"xml-name-validator\");\r\n\r\nconst attributeUtils = require(\"./attributes\");\r\nconst { NAMESPACES, VOID_ELEMENTS, NODE_TYPES } = require(\"./constants\");\r\n\r\nconst XML_CHAR = /^(\\x09|\\x0A|\\x0D|[\\x20-\\uD7FF]|[\\uE000-\\uFFFD]|(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]))*$/;\r\nconst PUBID_CHAR = /^(\\x20|\\x0D|\\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;\r\n\r\nfunction asciiCaseInsensitiveMatch(a, b) {\r\n  if (a.length !== b.length) {\r\n    return false;\r\n  }\r\n\r\n  for (let i = 0; i < a.length; ++i) {\r\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction recordNamespaceInformation(element, map, prefixMap) {\r\n  let defaultNamespaceAttrValue = null;\r\n  for (let i = 0; i < element.attributes.length; ++i) {\r\n    const attr = element.attributes[i];\r\n    if (attr.namespaceURI === NAMESPACES.XMLNS) {\r\n      if (attr.prefix === null) {\r\n        defaultNamespaceAttrValue = attr.value;\r\n        continue;\r\n      }\r\n      let namespaceDefinition = attr.value;\r\n      if (namespaceDefinition === NAMESPACES.XML) {\r\n        continue;\r\n      }\r\n      // This is exactly the other way than the spec says, but that's intended.\r\n      // All the maps coalesce null to the empty string (explained in the\r\n      // spec), so instead of doing that every time, just do it once here.\r\n      if (namespaceDefinition === null) {\r\n        namespaceDefinition = \"\";\r\n      }\r\n\r\n      if (\r\n        namespaceDefinition in map &&\r\n        map[namespaceDefinition].includes(attr.localName)\r\n      ) {\r\n        continue;\r\n      }\r\n      if (!(namespaceDefinition in map)) {\r\n        map[namespaceDefinition] = [];\r\n      }\r\n      map[namespaceDefinition].push(attr.localName);\r\n      prefixMap[attr.localName] = namespaceDefinition;\r\n    }\r\n  }\r\n  return defaultNamespaceAttrValue;\r\n}\r\n\r\nfunction serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {\r\n  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {\r\n    throw new Error(\"Failed to serialize XML: document type node publicId is not well-formed.\");\r\n  }\r\n\r\n  if (\r\n    requireWellFormed &&\r\n    (!XML_CHAR.test(node.systemId) ||\r\n      (node.systemId.includes('\"') && node.systemId.includes(\"'\")))\r\n  ) {\r\n    throw new Error(\"Failed to serialize XML: document type node systemId is not well-formed.\");\r\n  }\r\n\r\n  let markup = `<!DOCTYPE ${node.name}`;\r\n  if (node.publicId !== \"\") {\r\n    markup += ` PUBLIC \"${node.publicId}\"`;\r\n  } else if (node.systemId !== \"\") {\r\n    markup += \" SYSTEM\";\r\n  }\r\n  if (node.systemId !== \"\") {\r\n    markup += ` \"${node.systemId}\"`;\r\n  }\r\n  return markup + \">\";\r\n}\r\n\r\nfunction serializeProcessingInstruction(\r\n  node,\r\n  namespace,\r\n  prefixMap,\r\n  requireWellFormed\r\n) {\r\n  if (\r\n    requireWellFormed &&\r\n    (node.target.includes(\":\") || asciiCaseInsensitiveMatch(node.target, \"xml\"))\r\n  ) {\r\n    throw new Error(\"Failed to serialize XML: processing instruction node target is not well-formed.\");\r\n  }\r\n  if (\r\n    requireWellFormed &&\r\n    (!XML_CHAR.test(node.data) || node.data.includes(\"?>\"))\r\n  ) {\r\n    throw new Error(\"Failed to serialize XML: processing instruction node data is not well-formed.\");\r\n  }\r\n  return `<?${node.target} ${node.data}?>`;\r\n}\r\n\r\nfunction serializeDocument(\r\n  node,\r\n  namespace,\r\n  prefixMap,\r\n  requireWellFormed,\r\n  refs\r\n) {\r\n  if (requireWellFormed && node.documentElement === null) {\r\n    throw new Error(\"Failed to serialize XML: document does not have a document element.\");\r\n  }\r\n  let serializedDocument = \"\";\r\n  for (const child of node.childNodes) {\r\n    serializedDocument += xmlSerialization(\r\n      child,\r\n      namespace,\r\n      prefixMap,\r\n      requireWellFormed,\r\n      refs\r\n    );\r\n  }\r\n  return serializedDocument;\r\n}\r\n\r\nfunction serializeDocumentFragment(\r\n  node,\r\n  namespace,\r\n  prefixMap,\r\n  requireWellFormed,\r\n  refs\r\n) {\r\n  let markup = \"\";\r\n  for (const child of node.childNodes) {\r\n    markup += xmlSerialization(\r\n      child,\r\n      namespace,\r\n      prefixMap,\r\n      requireWellFormed,\r\n      refs\r\n    );\r\n  }\r\n  return markup;\r\n}\r\n\r\nfunction serializeText(node, namespace, prefixMap, requireWellFormed) {\r\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\r\n    throw new Error(\"Failed to serialize XML: text node data is not well-formed.\");\r\n  }\r\n\r\n  return node.data\r\n    .replace(/&/g, \"&amp;\")\r\n    .replace(/</g, \"&lt;\")\r\n    .replace(/>/g, \"&gt;\");\r\n}\r\n\r\nfunction serializeComment(node, namespace, prefixMap, requireWellFormed) {\r\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\r\n    throw new Error(\"Failed to serialize XML: comment node data is not well-formed.\");\r\n  }\r\n\r\n  if (\r\n    requireWellFormed &&\r\n    (node.data.includes(\"--\") || node.data.endsWith(\"-\"))\r\n  ) {\r\n    throw new Error(\"Failed to serialize XML: found hyphens in illegal places in comment node data.\");\r\n  }\r\n  return `<!--${node.data}-->`;\r\n}\r\n\r\nfunction serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {\r\n  if (\r\n    requireWellFormed &&\r\n    (node.localName.includes(\":\") || !xnv.name(node.localName))\r\n  ) {\r\n    throw new Error(\"Failed to serialize XML: element node localName is not a valid XML name.\");\r\n  }\r\n  let markup = \"<\";\r\n  let qualifiedName = \"\";\r\n  let skipEndTag = false;\r\n  let ignoreNamespaceDefinitionAttr = false;\r\n  const map = Object.assign({}, prefixMap);\r\n  const localPrefixesMap = Object.create(null);\r\n  const localDefaultNamespace = recordNamespaceInformation(\r\n    node,\r\n    map,\r\n    localPrefixesMap\r\n  );\r\n  let inheritedNs = namespace;\r\n  const ns = node.namespaceURI;\r\n  if (inheritedNs === ns) {\r\n    if (localDefaultNamespace !== null) {\r\n      ignoreNamespaceDefinitionAttr = true;\r\n    }\r\n    if (ns === NAMESPACES.XML) {\r\n      qualifiedName = \"xml:\" + node.localName;\r\n    } else {\r\n      qualifiedName = node.localName;\r\n    }\r\n    markup += qualifiedName;\r\n  } else {\r\n    let { prefix } = node;\r\n    let candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);\r\n    if (prefix === \"xmlns\") {\r\n      if (requireWellFormed) {\r\n        throw new Error(\"Failed to serialize XML: element nodes can't have a prefix of \\\"xmlns\\\".\");\r\n      }\r\n      candidatePrefix = \"xmlns\";\r\n    }\r\n    if (candidatePrefix !== null) {\r\n      qualifiedName = candidatePrefix + \":\" + node.localName;\r\n      if (\r\n        localDefaultNamespace !== null &&\r\n        localDefaultNamespace !== NAMESPACES.XML\r\n      ) {\r\n        inheritedNs =\r\n          localDefaultNamespace === \"\" ? null : localDefaultNamespace;\r\n      }\r\n      markup += qualifiedName;\r\n    } else if (prefix !== null) {\r\n      if (prefix in localPrefixesMap) {\r\n        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);\r\n      }\r\n      if (map[ns]) {\r\n        map[ns].push(prefix);\r\n      } else {\r\n        map[ns] = [prefix];\r\n      }\r\n      qualifiedName = prefix + \":\" + node.localName;\r\n      markup += `${qualifiedName} xmlns:${prefix}=\"${attributeUtils.serializeAttributeValue(\r\n        ns,\r\n        requireWellFormed\r\n      )}\"`;\r\n      if (localDefaultNamespace !== null) {\r\n        inheritedNs =\r\n          localDefaultNamespace === \"\" ? null : localDefaultNamespace;\r\n      }\r\n    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {\r\n      ignoreNamespaceDefinitionAttr = true;\r\n      qualifiedName = node.localName;\r\n      inheritedNs = ns;\r\n      markup += `${qualifiedName} xmlns=\"${attributeUtils.serializeAttributeValue(\r\n        ns,\r\n        requireWellFormed\r\n      )}\"`;\r\n    } else {\r\n      qualifiedName = node.localName;\r\n      inheritedNs = ns;\r\n      markup += qualifiedName;\r\n    }\r\n  }\r\n\r\n  markup += attributeUtils.serializeAttributes(\r\n    node,\r\n    map,\r\n    localPrefixesMap,\r\n    ignoreNamespaceDefinitionAttr,\r\n    requireWellFormed,\r\n    refs\r\n  );\r\n\r\n  if (\r\n    ns === NAMESPACES.HTML &&\r\n    node.childNodes.length === 0 &&\r\n    VOID_ELEMENTS.has(node.localName)\r\n  ) {\r\n    markup += \" /\";\r\n    skipEndTag = true;\r\n  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {\r\n    markup += \"/\";\r\n    skipEndTag = true;\r\n  }\r\n  markup += \">\";\r\n  if (skipEndTag) {\r\n    return markup;\r\n  }\r\n\r\n  if (ns === NAMESPACES.HTML && node.localName === \"template\") {\r\n    markup += xmlSerialization(\r\n      node.content,\r\n      inheritedNs,\r\n      map,\r\n      requireWellFormed,\r\n      refs\r\n    );\r\n  } else {\r\n    for (const child of node.childNodes) {\r\n      markup += xmlSerialization(\r\n        child,\r\n        inheritedNs,\r\n        map,\r\n        requireWellFormed,\r\n        refs\r\n      );\r\n    }\r\n  }\r\n  markup += `</${qualifiedName}>`;\r\n  return markup;\r\n}\r\n\r\nfunction serializeCDATASection(node) {\r\n  return \"<![CDATA[\" + node.data + \"]]>\";\r\n}\r\n\r\n/**\r\n * @param {{prefixIndex: number}} refs\r\n */\r\nfunction xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {\r\n  switch (node.nodeType) {\r\n    case NODE_TYPES.ELEMENT_NODE:\r\n      return serializeElement(\r\n        node,\r\n        namespace,\r\n        prefixMap,\r\n        requireWellFormed,\r\n        refs\r\n      );\r\n    case NODE_TYPES.DOCUMENT_NODE:\r\n      return serializeDocument(\r\n        node,\r\n        namespace,\r\n        prefixMap,\r\n        requireWellFormed,\r\n        refs\r\n      );\r\n    case NODE_TYPES.COMMENT_NODE:\r\n      return serializeComment(node, namespace, prefixMap, requireWellFormed);\r\n    case NODE_TYPES.TEXT_NODE:\r\n      return serializeText(node, namespace, prefixMap, requireWellFormed);\r\n    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:\r\n      return serializeDocumentFragment(\r\n        node,\r\n        namespace,\r\n        prefixMap,\r\n        requireWellFormed,\r\n        refs\r\n      );\r\n    case NODE_TYPES.DOCUMENT_TYPE_NODE:\r\n      return serializeDocumentType(\r\n        node,\r\n        namespace,\r\n        prefixMap,\r\n        requireWellFormed\r\n      );\r\n    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:\r\n      return serializeProcessingInstruction(\r\n        node,\r\n        namespace,\r\n        prefixMap,\r\n        requireWellFormed\r\n      );\r\n    case NODE_TYPES.ATTRIBUTE_NODE:\r\n      return \"\";\r\n    case NODE_TYPES.CDATA_SECTION_NODE:\r\n      return serializeCDATASection(node);\r\n    default:\r\n      throw new TypeError(\"Failed to serialize XML: only Nodes can be serialized.\");\r\n  }\r\n}\r\n\r\nmodule.exports = (root, { requireWellFormed = false } = {}) => {\r\n  const namespacePrefixMap = Object.create(null);\r\n  namespacePrefixMap[\"http://www.w3.org/XML/1998/namespace\"] = [\"xml\"];\r\n  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {\r\n    prefixIndex: 1\r\n  });\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}