{"ast":null,"code":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst notImplemented = require(\"../../browser/not-implemented\");\nconst idlUtils = require(\"../generated/utils\");\nconst {\n  Canvas\n} = require(\"../../utils\");\nclass HTMLCanvasElementImpl extends HTMLElementImpl {\n  _attrModified(name, value, oldValue) {\n    if (this._canvas && (name === \"width\" || name === \"height\")) {\n      this._canvas[name] = parseInt(value);\n    }\n    super._attrModified(name, value, oldValue);\n  }\n  _getCanvas() {\n    if (Canvas && !this._canvas) {\n      this._canvas = Canvas.createCanvas(this.width, this.height);\n    }\n    return this._canvas;\n  }\n  getContext(contextId) {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      if (!this._context) {\n        this._context = canvas.getContext(contextId) || null;\n        if (this._context) {\n          // Override the native canvas reference with our wrapper. This is the\n          // reason why we need to locally cache _context, since each call to\n          // canvas.getContext(contextId) would replace this reference again.\n          // Perhaps in the longer term, a better solution would be to create a\n          // full wrapper for the Context object as well.\n          this._context.canvas = idlUtils.wrapperForImpl(this);\n          wrapNodeCanvasMethod(this._context, \"createPattern\");\n          wrapNodeCanvasMethod(this._context, \"drawImage\");\n        }\n      }\n      return this._context;\n    }\n    notImplemented(\"HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n    return null;\n  }\n  toDataURL() {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      return canvas.toDataURL(...arguments);\n    }\n    notImplemented(\"HTMLCanvasElement.prototype.toDataURL (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n    return null;\n  }\n  toBlob(callback, type, qualityArgument) {\n    const window = this._ownerDocument._defaultView;\n    const canvas = this._getCanvas();\n    if (canvas) {\n      const options = {};\n      switch (type) {\n        case \"image/jpg\":\n        case \"image/jpeg\":\n          type = \"image/jpeg\";\n          options.quality = qualityArgument;\n          break;\n        default:\n          type = \"image/png\";\n      }\n      canvas.toBuffer((err, buff) => {\n        if (err) {\n          throw err;\n        }\n        callback(new window.Blob([buff], {\n          type\n        }));\n      }, type, options);\n    } else {\n      notImplemented(\"HTMLCanvasElement.prototype.toBlob (without installing the canvas npm package)\", window);\n    }\n  }\n  get width() {\n    const parsed = parseInt(this.getAttributeNS(null, \"width\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 300 : parsed;\n  }\n  set width(v) {\n    v = v > 2147483647 ? 300 : v;\n    this.setAttributeNS(null, \"width\", String(v));\n  }\n  get height() {\n    const parsed = parseInt(this.getAttributeNS(null, \"height\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 150 : parsed;\n  }\n  set height(v) {\n    v = v > 2147483647 ? 150 : v;\n    this.setAttributeNS(null, \"height\", String(v));\n  }\n}\n\n// We need to wrap the methods that receive an image or canvas object\n// (luckily, always as the first argument), so that these objects can be\n// unwrapped an the expected types passed.\nfunction wrapNodeCanvasMethod(ctx, name) {\n  const prev = ctx[name];\n  ctx[name] = function (image) {\n    const impl = idlUtils.implForWrapper(image);\n    if (impl) {\n      if (impl instanceof HTMLCanvasElementImpl && !impl._canvas) {\n        impl._getCanvas();\n      }\n      image = impl._image || impl._canvas;\n    }\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n    return prev.call(ctx, image, ...rest);\n  };\n}\nmodule.exports = {\n  implementation: HTMLCanvasElementImpl\n};","map":{"version":3,"names":["HTMLElementImpl","require","implementation","notImplemented","idlUtils","Canvas","HTMLCanvasElementImpl","_attrModified","name","value","oldValue","_canvas","parseInt","_getCanvas","createCanvas","width","height","getContext","contextId","canvas","_context","wrapperForImpl","wrapNodeCanvasMethod","_ownerDocument","_defaultView","toDataURL","arguments","toBlob","callback","type","qualityArgument","window","options","quality","toBuffer","err","buff","Blob","parsed","getAttributeNS","isNaN","v","setAttributeNS","String","ctx","prev","image","impl","implForWrapper","_image","_len","length","rest","Array","_key","call","module","exports"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js"],"sourcesContent":["\"use strict\";\r\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\r\nconst notImplemented = require(\"../../browser/not-implemented\");\r\nconst idlUtils = require(\"../generated/utils\");\r\nconst { Canvas } = require(\"../../utils\");\r\n\r\nclass HTMLCanvasElementImpl extends HTMLElementImpl {\r\n  _attrModified(name, value, oldValue) {\r\n    if (this._canvas && (name === \"width\" || name === \"height\")) {\r\n      this._canvas[name] = parseInt(value);\r\n    }\r\n\r\n    super._attrModified(name, value, oldValue);\r\n  }\r\n\r\n  _getCanvas() {\r\n    if (Canvas && !this._canvas) {\r\n      this._canvas = Canvas.createCanvas(this.width, this.height);\r\n    }\r\n    return this._canvas;\r\n  }\r\n\r\n  getContext(contextId) {\r\n    const canvas = this._getCanvas();\r\n    if (canvas) {\r\n      if (!this._context) {\r\n        this._context = canvas.getContext(contextId) || null;\r\n        if (this._context) {\r\n          // Override the native canvas reference with our wrapper. This is the\r\n          // reason why we need to locally cache _context, since each call to\r\n          // canvas.getContext(contextId) would replace this reference again.\r\n          // Perhaps in the longer term, a better solution would be to create a\r\n          // full wrapper for the Context object as well.\r\n          this._context.canvas = idlUtils.wrapperForImpl(this);\r\n          wrapNodeCanvasMethod(this._context, \"createPattern\");\r\n          wrapNodeCanvasMethod(this._context, \"drawImage\");\r\n        }\r\n      }\r\n      return this._context;\r\n    }\r\n\r\n    notImplemented(\r\n      \"HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\",\r\n      this._ownerDocument._defaultView\r\n    );\r\n    return null;\r\n  }\r\n\r\n  toDataURL(...args) {\r\n    const canvas = this._getCanvas();\r\n    if (canvas) {\r\n      return canvas.toDataURL(...args);\r\n    }\r\n\r\n    notImplemented(\r\n      \"HTMLCanvasElement.prototype.toDataURL (without installing the canvas npm package)\",\r\n      this._ownerDocument._defaultView\r\n    );\r\n    return null;\r\n  }\r\n\r\n  toBlob(callback, type, qualityArgument) {\r\n    const window = this._ownerDocument._defaultView;\r\n    const canvas = this._getCanvas();\r\n    if (canvas) {\r\n      const options = {};\r\n      switch (type) {\r\n        case \"image/jpg\":\r\n        case \"image/jpeg\":\r\n          type = \"image/jpeg\";\r\n          options.quality = qualityArgument;\r\n          break;\r\n        default:\r\n          type = \"image/png\";\r\n      }\r\n      canvas.toBuffer((err, buff) => {\r\n        if (err) {\r\n          throw err;\r\n        }\r\n        callback(new window.Blob([buff], { type }));\r\n      }, type, options);\r\n    } else {\r\n      notImplemented(\r\n        \"HTMLCanvasElement.prototype.toBlob (without installing the canvas npm package)\",\r\n        window\r\n      );\r\n    }\r\n  }\r\n\r\n  get width() {\r\n    const parsed = parseInt(this.getAttributeNS(null, \"width\"));\r\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 300 : parsed;\r\n  }\r\n\r\n  set width(v) {\r\n    v = v > 2147483647 ? 300 : v;\r\n    this.setAttributeNS(null, \"width\", String(v));\r\n  }\r\n\r\n  get height() {\r\n    const parsed = parseInt(this.getAttributeNS(null, \"height\"));\r\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 150 : parsed;\r\n  }\r\n\r\n  set height(v) {\r\n    v = v > 2147483647 ? 150 : v;\r\n    this.setAttributeNS(null, \"height\", String(v));\r\n  }\r\n}\r\n\r\n// We need to wrap the methods that receive an image or canvas object\r\n// (luckily, always as the first argument), so that these objects can be\r\n// unwrapped an the expected types passed.\r\nfunction wrapNodeCanvasMethod(ctx, name) {\r\n  const prev = ctx[name];\r\n  ctx[name] = function (image, ...rest) {\r\n    const impl = idlUtils.implForWrapper(image);\r\n    if (impl) {\r\n      if (impl instanceof HTMLCanvasElementImpl && !impl._canvas) {\r\n        impl._getCanvas();\r\n      }\r\n      image = impl._image || impl._canvas;\r\n    }\r\n    return prev.call(ctx, image, ...rest);\r\n  };\r\n}\r\n\r\nmodule.exports = {\r\n  implementation: HTMLCanvasElementImpl\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}