{"ast":null,"code":"'use strict';\n\nconst unicode = require('../common/unicode');\nconst ERR = require('../common/error-codes');\n\n//Aliases\nconst $ = unicode.CODE_POINTS;\n\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nclass Preprocessor {\n  constructor() {\n    this.html = null;\n    this.pos = -1;\n    this.lastGapPos = -1;\n    this.lastCharPos = -1;\n    this.gapStack = [];\n    this.skipNextNewLine = false;\n    this.lastChunkWritten = false;\n    this.endOfChunkHit = false;\n    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n  }\n  _err() {\n    // NOTE: err reporting is noop by default. Enabled by mixin.\n  }\n  _addGap() {\n    this.gapStack.push(this.lastGapPos);\n    this.lastGapPos = this.pos;\n  }\n  _processSurrogate(cp) {\n    //NOTE: try to peek a surrogate pair\n    if (this.pos !== this.lastCharPos) {\n      const nextCp = this.html.charCodeAt(this.pos + 1);\n      if (unicode.isSurrogatePair(nextCp)) {\n        //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n        this.pos++;\n\n        //NOTE: add gap that should be avoided during retreat\n        this._addGap();\n        return unicode.getSurrogatePairCodePoint(cp, nextCp);\n      }\n    }\n\n    //NOTE: we are at the end of a chunk, therefore we can't infer surrogate pair yet.\n    else if (!this.lastChunkWritten) {\n      this.endOfChunkHit = true;\n      return $.EOF;\n    }\n\n    //NOTE: isolated surrogate\n    this._err(ERR.surrogateInInputStream);\n    return cp;\n  }\n  dropParsedChunk() {\n    if (this.pos > this.bufferWaterline) {\n      this.lastCharPos -= this.pos;\n      this.html = this.html.substring(this.pos);\n      this.pos = 0;\n      this.lastGapPos = -1;\n      this.gapStack = [];\n    }\n  }\n  write(chunk, isLastChunk) {\n    if (this.html) {\n      this.html += chunk;\n    } else {\n      this.html = chunk;\n    }\n    this.lastCharPos = this.html.length - 1;\n    this.endOfChunkHit = false;\n    this.lastChunkWritten = isLastChunk;\n  }\n  insertHtmlAtCurrentPos(chunk) {\n    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);\n    this.lastCharPos = this.html.length - 1;\n    this.endOfChunkHit = false;\n  }\n  advance() {\n    this.pos++;\n    if (this.pos > this.lastCharPos) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return $.EOF;\n    }\n    let cp = this.html.charCodeAt(this.pos);\n\n    //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n    //must be ignored.\n    if (this.skipNextNewLine && cp === $.LINE_FEED) {\n      this.skipNextNewLine = false;\n      this._addGap();\n      return this.advance();\n    }\n\n    //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n    if (cp === $.CARRIAGE_RETURN) {\n      this.skipNextNewLine = true;\n      return $.LINE_FEED;\n    }\n    this.skipNextNewLine = false;\n    if (unicode.isSurrogate(cp)) {\n      cp = this._processSurrogate(cp);\n    }\n\n    //OPTIMIZATION: first check if code point is in the common allowed\n    //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n    //before going into detailed performance cost validation.\n    const isCommonValidRange = cp > 0x1f && cp < 0x7f || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || cp > 0x9f && cp < 0xfdd0;\n    if (!isCommonValidRange) {\n      this._checkForProblematicCharacters(cp);\n    }\n    return cp;\n  }\n  _checkForProblematicCharacters(cp) {\n    if (unicode.isControlCodePoint(cp)) {\n      this._err(ERR.controlCharacterInInputStream);\n    } else if (unicode.isUndefinedCodePoint(cp)) {\n      this._err(ERR.noncharacterInInputStream);\n    }\n  }\n  retreat() {\n    if (this.pos === this.lastGapPos) {\n      this.lastGapPos = this.gapStack.pop();\n      this.pos--;\n    }\n    this.pos--;\n  }\n}\nmodule.exports = Preprocessor;","map":{"version":3,"names":["unicode","require","ERR","$","CODE_POINTS","DEFAULT_BUFFER_WATERLINE","Preprocessor","constructor","html","pos","lastGapPos","lastCharPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","bufferWaterline","_err","_addGap","push","_processSurrogate","cp","nextCp","charCodeAt","isSurrogatePair","getSurrogatePairCodePoint","EOF","surrogateInInputStream","dropParsedChunk","substring","write","chunk","isLastChunk","length","insertHtmlAtCurrentPos","advance","LINE_FEED","CARRIAGE_RETURN","isSurrogate","isCommonValidRange","_checkForProblematicCharacters","isControlCodePoint","controlCharacterInInputStream","isUndefinedCodePoint","noncharacterInInputStream","retreat","pop","module","exports"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/parse5/lib/tokenizer/preprocessor.js"],"sourcesContent":["'use strict';\r\n\r\nconst unicode = require('../common/unicode');\r\nconst ERR = require('../common/error-codes');\r\n\r\n//Aliases\r\nconst $ = unicode.CODE_POINTS;\r\n\r\n//Const\r\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\r\n\r\n//Preprocessor\r\n//NOTE: HTML input preprocessing\r\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\r\nclass Preprocessor {\r\n    constructor() {\r\n        this.html = null;\r\n\r\n        this.pos = -1;\r\n        this.lastGapPos = -1;\r\n        this.lastCharPos = -1;\r\n\r\n        this.gapStack = [];\r\n\r\n        this.skipNextNewLine = false;\r\n\r\n        this.lastChunkWritten = false;\r\n        this.endOfChunkHit = false;\r\n        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\r\n    }\r\n\r\n    _err() {\r\n        // NOTE: err reporting is noop by default. Enabled by mixin.\r\n    }\r\n\r\n    _addGap() {\r\n        this.gapStack.push(this.lastGapPos);\r\n        this.lastGapPos = this.pos;\r\n    }\r\n\r\n    _processSurrogate(cp) {\r\n        //NOTE: try to peek a surrogate pair\r\n        if (this.pos !== this.lastCharPos) {\r\n            const nextCp = this.html.charCodeAt(this.pos + 1);\r\n\r\n            if (unicode.isSurrogatePair(nextCp)) {\r\n                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\r\n                this.pos++;\r\n\r\n                //NOTE: add gap that should be avoided during retreat\r\n                this._addGap();\r\n\r\n                return unicode.getSurrogatePairCodePoint(cp, nextCp);\r\n            }\r\n        }\r\n\r\n        //NOTE: we are at the end of a chunk, therefore we can't infer surrogate pair yet.\r\n        else if (!this.lastChunkWritten) {\r\n            this.endOfChunkHit = true;\r\n            return $.EOF;\r\n        }\r\n\r\n        //NOTE: isolated surrogate\r\n        this._err(ERR.surrogateInInputStream);\r\n\r\n        return cp;\r\n    }\r\n\r\n    dropParsedChunk() {\r\n        if (this.pos > this.bufferWaterline) {\r\n            this.lastCharPos -= this.pos;\r\n            this.html = this.html.substring(this.pos);\r\n            this.pos = 0;\r\n            this.lastGapPos = -1;\r\n            this.gapStack = [];\r\n        }\r\n    }\r\n\r\n    write(chunk, isLastChunk) {\r\n        if (this.html) {\r\n            this.html += chunk;\r\n        } else {\r\n            this.html = chunk;\r\n        }\r\n\r\n        this.lastCharPos = this.html.length - 1;\r\n        this.endOfChunkHit = false;\r\n        this.lastChunkWritten = isLastChunk;\r\n    }\r\n\r\n    insertHtmlAtCurrentPos(chunk) {\r\n        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);\r\n\r\n        this.lastCharPos = this.html.length - 1;\r\n        this.endOfChunkHit = false;\r\n    }\r\n\r\n    advance() {\r\n        this.pos++;\r\n\r\n        if (this.pos > this.lastCharPos) {\r\n            this.endOfChunkHit = !this.lastChunkWritten;\r\n            return $.EOF;\r\n        }\r\n\r\n        let cp = this.html.charCodeAt(this.pos);\r\n\r\n        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\r\n        //must be ignored.\r\n        if (this.skipNextNewLine && cp === $.LINE_FEED) {\r\n            this.skipNextNewLine = false;\r\n            this._addGap();\r\n            return this.advance();\r\n        }\r\n\r\n        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\r\n        if (cp === $.CARRIAGE_RETURN) {\r\n            this.skipNextNewLine = true;\r\n            return $.LINE_FEED;\r\n        }\r\n\r\n        this.skipNextNewLine = false;\r\n\r\n        if (unicode.isSurrogate(cp)) {\r\n            cp = this._processSurrogate(cp);\r\n        }\r\n\r\n        //OPTIMIZATION: first check if code point is in the common allowed\r\n        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\r\n        //before going into detailed performance cost validation.\r\n        const isCommonValidRange =\r\n            (cp > 0x1f && cp < 0x7f) || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || (cp > 0x9f && cp < 0xfdd0);\r\n\r\n        if (!isCommonValidRange) {\r\n            this._checkForProblematicCharacters(cp);\r\n        }\r\n\r\n        return cp;\r\n    }\r\n\r\n    _checkForProblematicCharacters(cp) {\r\n        if (unicode.isControlCodePoint(cp)) {\r\n            this._err(ERR.controlCharacterInInputStream);\r\n        } else if (unicode.isUndefinedCodePoint(cp)) {\r\n            this._err(ERR.noncharacterInInputStream);\r\n        }\r\n    }\r\n\r\n    retreat() {\r\n        if (this.pos === this.lastGapPos) {\r\n            this.lastGapPos = this.gapStack.pop();\r\n            this.pos--;\r\n        }\r\n\r\n        this.pos--;\r\n    }\r\n}\r\n\r\nmodule.exports = Preprocessor;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}