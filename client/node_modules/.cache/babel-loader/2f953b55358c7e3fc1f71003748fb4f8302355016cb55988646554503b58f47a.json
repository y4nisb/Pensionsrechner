{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\r\n * SourceNodes provide a way to abstract over interpolating/concatenating\r\n * snippets of generated JavaScript source code while maintaining the line and\r\n * column information associated with the original source code.\r\n *\r\n * @param aLine The original line number.\r\n * @param aColumn The original column number.\r\n * @param aSource The original source's filename.\r\n * @param aChunks Optional. An array of strings which are snippets of\r\n *        generated JS, or other SourceNodes.\r\n * @param aName The original identifier.\r\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\r\n * Creates a SourceNode from generated code and a SourceMapConsumer.\r\n *\r\n * @param aGeneratedCode The generated code\r\n * @param aSourceMapConsumer The SourceMap for the generated code\r\n * @param aRelativePath Optional. The path that relative sources in the\r\n *        SourceMapConsumer should be relative to.\r\n */\nSourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n  // The SourceNode we want to fill with the generated code\n  // and the SourceMap\n  var node = new SourceNode();\n\n  // All even indices of this array are one line of the generated code,\n  // while all odd indices are the newlines between two adjacent lines\n  // (since `REGEX_NEWLINE` captures its match).\n  // Processed fragments are accessed by calling `shiftNextLine`.\n  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n  var remainingLinesIndex = 0;\n  var shiftNextLine = function () {\n    var lineContents = getNextLine();\n    // The last line of a file might not have a newline.\n    var newLine = getNextLine() || \"\";\n    return lineContents + newLine;\n    function getNextLine() {\n      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n    }\n  };\n\n  // We need to remember the position of \"remainingLines\"\n  var lastGeneratedLine = 1,\n    lastGeneratedColumn = 0;\n\n  // The generate SourceNodes we need a code range.\n  // To extract it current and last mapping is used.\n  // Here we store the last mapping.\n  var lastMapping = null;\n  aSourceMapConsumer.eachMapping(function (mapping) {\n    if (lastMapping !== null) {\n      // We add the code from \"lastMapping\" to \"mapping\":\n      // First check if there is a new line in between.\n      if (lastGeneratedLine < mapping.generatedLine) {\n        // Associate first line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n        lastGeneratedLine++;\n        lastGeneratedColumn = 0;\n        // The remaining code is added without mapping\n      } else {\n        // There is no new line in between.\n        // Associate the code between \"lastGeneratedColumn\" and\n        // \"mapping.generatedColumn\" with \"lastMapping\"\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n        addMappingWithCode(lastMapping, code);\n        // No more remaining code, continue\n        lastMapping = mapping;\n        return;\n      }\n    }\n    // We add the generated code until the first mapping\n    // to the SourceNode without any mapping.\n    // Each line is added as separate string.\n    while (lastGeneratedLine < mapping.generatedLine) {\n      node.add(shiftNextLine());\n      lastGeneratedLine++;\n    }\n    if (lastGeneratedColumn < mapping.generatedColumn) {\n      var nextLine = remainingLines[remainingLinesIndex] || '';\n      node.add(nextLine.substr(0, mapping.generatedColumn));\n      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n      lastGeneratedColumn = mapping.generatedColumn;\n    }\n    lastMapping = mapping;\n  }, this);\n  // We have processed all mappings.\n  if (remainingLinesIndex < remainingLines.length) {\n    if (lastMapping) {\n      // Associate the remaining code in the current line with \"lastMapping\"\n      addMappingWithCode(lastMapping, shiftNextLine());\n    }\n    // and add the remaining lines without any mapping\n    node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n  }\n\n  // Copy sourcesContent into SourceNode\n  aSourceMapConsumer.sources.forEach(function (sourceFile) {\n    var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n    if (content != null) {\n      if (aRelativePath != null) {\n        sourceFile = util.join(aRelativePath, sourceFile);\n      }\n      node.setSourceContent(sourceFile, content);\n    }\n  });\n  return node;\n  function addMappingWithCode(mapping, code) {\n    if (mapping === null || mapping.source === undefined) {\n      node.add(code);\n    } else {\n      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n    }\n  }\n};\n\n/**\r\n * Add a chunk of generated JS to this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  } else {\n    throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n  }\n  return this;\n};\n\n/**\r\n * Add a chunk of generated JS to the beginning of this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length - 1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  } else {\n    throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n  }\n  return this;\n};\n\n/**\r\n * Walk over the tree of JS snippets in this node and its children. The\r\n * walking function is called once for each snippet of JS and is passed that\r\n * snippet and the its original associated source's line/column location.\r\n *\r\n * @param aFn The traversal function.\r\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    } else {\n      if (chunk !== '') {\n        aFn(chunk, {\n          source: this.source,\n          line: this.line,\n          column: this.column,\n          name: this.name\n        });\n      }\n    }\n  }\n};\n\n/**\r\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\r\n * each of `this.children`.\r\n *\r\n * @param aSep The separator.\r\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len - 1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\r\n * Call String.prototype.replace on the very right-most source snippet. Useful\r\n * for trimming whitespace from the end of a source node, etc.\r\n *\r\n * @param aPattern The pattern to replace.\r\n * @param aReplacement The thing to replace the pattern with.\r\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  } else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  } else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\r\n * Set the source content for a source file. This will be added to the SourceMapGenerator\r\n * in the sourcesContent field.\r\n *\r\n * @param aSourceFile The filename of the source file\r\n * @param aSourceContent The content of the source file\r\n */\nSourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n};\n\n/**\r\n * Walk over the tree of SourceNodes. The walking function is called for each\r\n * source file content and is passed the filename and source content.\r\n *\r\n * @param aFn The traversal function.\r\n */\nSourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    if (this.children[i][isSourceNode]) {\n      this.children[i].walkSourceContents(aFn);\n    }\n  }\n  var sources = Object.keys(this.sourceContents);\n  for (var i = 0, len = sources.length; i < len; i++) {\n    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n  }\n};\n\n/**\r\n * Return the string representation of this source node. Walks over the tree\r\n * and concatenates all the various snippets together to one string.\r\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\r\n * Returns the string representation of this source node along with a source\r\n * map.\r\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null && original.line !== null && original.column !== null) {\n      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n  return {\n    code: generated.code,\n    map: map\n  };\n};\nexports.SourceNode = SourceNode;","map":{"version":3,"names":["SourceMapGenerator","require","util","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","SourceNode","aLine","aColumn","aSource","aChunks","aName","children","sourceContents","line","column","source","name","add","fromStringWithSourceMap","SourceNode_fromStringWithSourceMap","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","remainingLinesIndex","shiftNextLine","lineContents","getNextLine","newLine","length","undefined","lastGeneratedLine","lastGeneratedColumn","lastMapping","eachMapping","mapping","generatedLine","addMappingWithCode","nextLine","code","substr","generatedColumn","splice","join","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","originalLine","originalColumn","prototype","SourceNode_add","aChunk","Array","isArray","chunk","push","TypeError","prepend","SourceNode_prepend","i","unshift","walk","SourceNode_walk","aFn","len","SourceNode_join","aSep","newChildren","replaceRight","SourceNode_replaceRight","aPattern","aReplacement","lastChild","replace","SourceNode_setSourceContent","aSourceFile","aSourceContent","toSetString","walkSourceContents","SourceNode_walkSourceContents","Object","keys","fromSetString","toString","SourceNode_toString","str","toStringWithSourceMap","SourceNode_toStringWithSourceMap","aArgs","generated","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceContent","exports"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/escodegen/node_modules/source-map/lib/source-node.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\r\nvar util = require('./util');\r\n\r\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\r\n// operating systems these days (capturing the result).\r\nvar REGEX_NEWLINE = /(\\r?\\n)/;\r\n\r\n// Newline character code for charCodeAt() comparisons\r\nvar NEWLINE_CODE = 10;\r\n\r\n// Private symbol for identifying `SourceNode`s when multiple versions of\r\n// the source-map library are loaded. This MUST NOT CHANGE across\r\n// versions!\r\nvar isSourceNode = \"$$$isSourceNode$$$\";\r\n\r\n/**\r\n * SourceNodes provide a way to abstract over interpolating/concatenating\r\n * snippets of generated JavaScript source code while maintaining the line and\r\n * column information associated with the original source code.\r\n *\r\n * @param aLine The original line number.\r\n * @param aColumn The original column number.\r\n * @param aSource The original source's filename.\r\n * @param aChunks Optional. An array of strings which are snippets of\r\n *        generated JS, or other SourceNodes.\r\n * @param aName The original identifier.\r\n */\r\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\r\n  this.children = [];\r\n  this.sourceContents = {};\r\n  this.line = aLine == null ? null : aLine;\r\n  this.column = aColumn == null ? null : aColumn;\r\n  this.source = aSource == null ? null : aSource;\r\n  this.name = aName == null ? null : aName;\r\n  this[isSourceNode] = true;\r\n  if (aChunks != null) this.add(aChunks);\r\n}\r\n\r\n/**\r\n * Creates a SourceNode from generated code and a SourceMapConsumer.\r\n *\r\n * @param aGeneratedCode The generated code\r\n * @param aSourceMapConsumer The SourceMap for the generated code\r\n * @param aRelativePath Optional. The path that relative sources in the\r\n *        SourceMapConsumer should be relative to.\r\n */\r\nSourceNode.fromStringWithSourceMap =\r\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\r\n    // The SourceNode we want to fill with the generated code\r\n    // and the SourceMap\r\n    var node = new SourceNode();\r\n\r\n    // All even indices of this array are one line of the generated code,\r\n    // while all odd indices are the newlines between two adjacent lines\r\n    // (since `REGEX_NEWLINE` captures its match).\r\n    // Processed fragments are accessed by calling `shiftNextLine`.\r\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\r\n    var remainingLinesIndex = 0;\r\n    var shiftNextLine = function() {\r\n      var lineContents = getNextLine();\r\n      // The last line of a file might not have a newline.\r\n      var newLine = getNextLine() || \"\";\r\n      return lineContents + newLine;\r\n\r\n      function getNextLine() {\r\n        return remainingLinesIndex < remainingLines.length ?\r\n            remainingLines[remainingLinesIndex++] : undefined;\r\n      }\r\n    };\r\n\r\n    // We need to remember the position of \"remainingLines\"\r\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\r\n\r\n    // The generate SourceNodes we need a code range.\r\n    // To extract it current and last mapping is used.\r\n    // Here we store the last mapping.\r\n    var lastMapping = null;\r\n\r\n    aSourceMapConsumer.eachMapping(function (mapping) {\r\n      if (lastMapping !== null) {\r\n        // We add the code from \"lastMapping\" to \"mapping\":\r\n        // First check if there is a new line in between.\r\n        if (lastGeneratedLine < mapping.generatedLine) {\r\n          // Associate first line with \"lastMapping\"\r\n          addMappingWithCode(lastMapping, shiftNextLine());\r\n          lastGeneratedLine++;\r\n          lastGeneratedColumn = 0;\r\n          // The remaining code is added without mapping\r\n        } else {\r\n          // There is no new line in between.\r\n          // Associate the code between \"lastGeneratedColumn\" and\r\n          // \"mapping.generatedColumn\" with \"lastMapping\"\r\n          var nextLine = remainingLines[remainingLinesIndex] || '';\r\n          var code = nextLine.substr(0, mapping.generatedColumn -\r\n                                        lastGeneratedColumn);\r\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\r\n                                              lastGeneratedColumn);\r\n          lastGeneratedColumn = mapping.generatedColumn;\r\n          addMappingWithCode(lastMapping, code);\r\n          // No more remaining code, continue\r\n          lastMapping = mapping;\r\n          return;\r\n        }\r\n      }\r\n      // We add the generated code until the first mapping\r\n      // to the SourceNode without any mapping.\r\n      // Each line is added as separate string.\r\n      while (lastGeneratedLine < mapping.generatedLine) {\r\n        node.add(shiftNextLine());\r\n        lastGeneratedLine++;\r\n      }\r\n      if (lastGeneratedColumn < mapping.generatedColumn) {\r\n        var nextLine = remainingLines[remainingLinesIndex] || '';\r\n        node.add(nextLine.substr(0, mapping.generatedColumn));\r\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\r\n        lastGeneratedColumn = mapping.generatedColumn;\r\n      }\r\n      lastMapping = mapping;\r\n    }, this);\r\n    // We have processed all mappings.\r\n    if (remainingLinesIndex < remainingLines.length) {\r\n      if (lastMapping) {\r\n        // Associate the remaining code in the current line with \"lastMapping\"\r\n        addMappingWithCode(lastMapping, shiftNextLine());\r\n      }\r\n      // and add the remaining lines without any mapping\r\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\r\n    }\r\n\r\n    // Copy sourcesContent into SourceNode\r\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\r\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n      if (content != null) {\r\n        if (aRelativePath != null) {\r\n          sourceFile = util.join(aRelativePath, sourceFile);\r\n        }\r\n        node.setSourceContent(sourceFile, content);\r\n      }\r\n    });\r\n\r\n    return node;\r\n\r\n    function addMappingWithCode(mapping, code) {\r\n      if (mapping === null || mapping.source === undefined) {\r\n        node.add(code);\r\n      } else {\r\n        var source = aRelativePath\r\n          ? util.join(aRelativePath, mapping.source)\r\n          : mapping.source;\r\n        node.add(new SourceNode(mapping.originalLine,\r\n                                mapping.originalColumn,\r\n                                source,\r\n                                code,\r\n                                mapping.name));\r\n      }\r\n    }\r\n  };\r\n\r\n/**\r\n * Add a chunk of generated JS to this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    aChunk.forEach(function (chunk) {\r\n      this.add(chunk);\r\n    }, this);\r\n  }\r\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    if (aChunk) {\r\n      this.children.push(aChunk);\r\n    }\r\n  }\r\n  else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a chunk of generated JS to the beginning of this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    for (var i = aChunk.length-1; i >= 0; i--) {\r\n      this.prepend(aChunk[i]);\r\n    }\r\n  }\r\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    this.children.unshift(aChunk);\r\n  }\r\n  else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Walk over the tree of JS snippets in this node and its children. The\r\n * walking function is called once for each snippet of JS and is passed that\r\n * snippet and the its original associated source's line/column location.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\r\n  var chunk;\r\n  for (var i = 0, len = this.children.length; i < len; i++) {\r\n    chunk = this.children[i];\r\n    if (chunk[isSourceNode]) {\r\n      chunk.walk(aFn);\r\n    }\r\n    else {\r\n      if (chunk !== '') {\r\n        aFn(chunk, { source: this.source,\r\n                     line: this.line,\r\n                     column: this.column,\r\n                     name: this.name });\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\r\n * each of `this.children`.\r\n *\r\n * @param aSep The separator.\r\n */\r\nSourceNode.prototype.join = function SourceNode_join(aSep) {\r\n  var newChildren;\r\n  var i;\r\n  var len = this.children.length;\r\n  if (len > 0) {\r\n    newChildren = [];\r\n    for (i = 0; i < len-1; i++) {\r\n      newChildren.push(this.children[i]);\r\n      newChildren.push(aSep);\r\n    }\r\n    newChildren.push(this.children[i]);\r\n    this.children = newChildren;\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Call String.prototype.replace on the very right-most source snippet. Useful\r\n * for trimming whitespace from the end of a source node, etc.\r\n *\r\n * @param aPattern The pattern to replace.\r\n * @param aReplacement The thing to replace the pattern with.\r\n */\r\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\r\n  var lastChild = this.children[this.children.length - 1];\r\n  if (lastChild[isSourceNode]) {\r\n    lastChild.replaceRight(aPattern, aReplacement);\r\n  }\r\n  else if (typeof lastChild === 'string') {\r\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\r\n  }\r\n  else {\r\n    this.children.push(''.replace(aPattern, aReplacement));\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set the source content for a source file. This will be added to the SourceMapGenerator\r\n * in the sourcesContent field.\r\n *\r\n * @param aSourceFile The filename of the source file\r\n * @param aSourceContent The content of the source file\r\n */\r\nSourceNode.prototype.setSourceContent =\r\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\r\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\r\n  };\r\n\r\n/**\r\n * Walk over the tree of SourceNodes. The walking function is called for each\r\n * source file content and is passed the filename and source content.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walkSourceContents =\r\n  function SourceNode_walkSourceContents(aFn) {\r\n    for (var i = 0, len = this.children.length; i < len; i++) {\r\n      if (this.children[i][isSourceNode]) {\r\n        this.children[i].walkSourceContents(aFn);\r\n      }\r\n    }\r\n\r\n    var sources = Object.keys(this.sourceContents);\r\n    for (var i = 0, len = sources.length; i < len; i++) {\r\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\r\n    }\r\n  };\r\n\r\n/**\r\n * Return the string representation of this source node. Walks over the tree\r\n * and concatenates all the various snippets together to one string.\r\n */\r\nSourceNode.prototype.toString = function SourceNode_toString() {\r\n  var str = \"\";\r\n  this.walk(function (chunk) {\r\n    str += chunk;\r\n  });\r\n  return str;\r\n};\r\n\r\n/**\r\n * Returns the string representation of this source node along with a source\r\n * map.\r\n */\r\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\r\n  var generated = {\r\n    code: \"\",\r\n    line: 1,\r\n    column: 0\r\n  };\r\n  var map = new SourceMapGenerator(aArgs);\r\n  var sourceMappingActive = false;\r\n  var lastOriginalSource = null;\r\n  var lastOriginalLine = null;\r\n  var lastOriginalColumn = null;\r\n  var lastOriginalName = null;\r\n  this.walk(function (chunk, original) {\r\n    generated.code += chunk;\r\n    if (original.source !== null\r\n        && original.line !== null\r\n        && original.column !== null) {\r\n      if(lastOriginalSource !== original.source\r\n         || lastOriginalLine !== original.line\r\n         || lastOriginalColumn !== original.column\r\n         || lastOriginalName !== original.name) {\r\n        map.addMapping({\r\n          source: original.source,\r\n          original: {\r\n            line: original.line,\r\n            column: original.column\r\n          },\r\n          generated: {\r\n            line: generated.line,\r\n            column: generated.column\r\n          },\r\n          name: original.name\r\n        });\r\n      }\r\n      lastOriginalSource = original.source;\r\n      lastOriginalLine = original.line;\r\n      lastOriginalColumn = original.column;\r\n      lastOriginalName = original.name;\r\n      sourceMappingActive = true;\r\n    } else if (sourceMappingActive) {\r\n      map.addMapping({\r\n        generated: {\r\n          line: generated.line,\r\n          column: generated.column\r\n        }\r\n      });\r\n      lastOriginalSource = null;\r\n      sourceMappingActive = false;\r\n    }\r\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\r\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\r\n        generated.line++;\r\n        generated.column = 0;\r\n        // Mappings end at eol\r\n        if (idx + 1 === length) {\r\n          lastOriginalSource = null;\r\n          sourceMappingActive = false;\r\n        } else if (sourceMappingActive) {\r\n          map.addMapping({\r\n            source: original.source,\r\n            original: {\r\n              line: original.line,\r\n              column: original.column\r\n            },\r\n            generated: {\r\n              line: generated.line,\r\n              column: generated.column\r\n            },\r\n            name: original.name\r\n          });\r\n        }\r\n      } else {\r\n        generated.column++;\r\n      }\r\n    }\r\n  });\r\n  this.walkSourceContents(function (sourceFile, sourceContent) {\r\n    map.setSourceContent(sourceFile, sourceContent);\r\n  });\r\n\r\n  return { code: generated.code, map: map };\r\n};\r\n\r\nexports.SourceNode = SourceNode;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}