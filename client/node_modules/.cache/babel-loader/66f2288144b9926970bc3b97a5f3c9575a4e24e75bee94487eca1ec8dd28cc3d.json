{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\r\n * Recursive implementation of binary search.\r\n *\r\n * @param aLow Indices here and lower do not contain the needle.\r\n * @param aHigh Indices here and higher do not contain the needle.\r\n * @param aNeedle The element being searched for.\r\n * @param aHaystack The non-empty array being searched.\r\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\r\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\r\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  } else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  } else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\r\n * This is an implementation of binary search which will always try and return\r\n * the index of the closest element if there is no exact hit. This is because\r\n * mappings between original and generated line/col pairs are single points,\r\n * and there is an implicit region between each of them, so a miss just means\r\n * that you aren't on the very start of a region.\r\n *\r\n * @param aNeedle The element you are looking for.\r\n * @param aHaystack The array that is being searched.\r\n * @param aCompare A function which takes the needle and an element in the\r\n *     array and returns -1, 0, or 1 depending on whether the needle is less\r\n *     than, equal to, or greater than the element, respectively.\r\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\r\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\r\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n  return index;\n};","map":{"version":3,"names":["exports","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","recursiveSearch","aLow","aHigh","aNeedle","aHaystack","aCompare","aBias","mid","Math","floor","cmp","length","search","index"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/escodegen/node_modules/source-map/lib/binary-search.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nexports.GREATEST_LOWER_BOUND = 1;\r\nexports.LEAST_UPPER_BOUND = 2;\r\n\r\n/**\r\n * Recursive implementation of binary search.\r\n *\r\n * @param aLow Indices here and lower do not contain the needle.\r\n * @param aHigh Indices here and higher do not contain the needle.\r\n * @param aNeedle The element being searched for.\r\n * @param aHaystack The non-empty array being searched.\r\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\r\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\r\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n */\r\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\r\n  // This function terminates when one of the following is true:\r\n  //\r\n  //   1. We find the exact element we are looking for.\r\n  //\r\n  //   2. We did not find the exact element, but we can return the index of\r\n  //      the next-closest element.\r\n  //\r\n  //   3. We did not find the exact element, and there is no next-closest\r\n  //      element than the one we are searching for, so we return -1.\r\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\r\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\r\n  if (cmp === 0) {\r\n    // Found the element we are looking for.\r\n    return mid;\r\n  }\r\n  else if (cmp > 0) {\r\n    // Our needle is greater than aHaystack[mid].\r\n    if (aHigh - mid > 1) {\r\n      // The element is in the upper half.\r\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\r\n    }\r\n\r\n    // The exact needle element was not found in this haystack. Determine if\r\n    // we are in termination case (3) or (2) and return the appropriate thing.\r\n    if (aBias == exports.LEAST_UPPER_BOUND) {\r\n      return aHigh < aHaystack.length ? aHigh : -1;\r\n    } else {\r\n      return mid;\r\n    }\r\n  }\r\n  else {\r\n    // Our needle is less than aHaystack[mid].\r\n    if (mid - aLow > 1) {\r\n      // The element is in the lower half.\r\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\r\n    }\r\n\r\n    // we are in termination case (3) or (2) and return the appropriate thing.\r\n    if (aBias == exports.LEAST_UPPER_BOUND) {\r\n      return mid;\r\n    } else {\r\n      return aLow < 0 ? -1 : aLow;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This is an implementation of binary search which will always try and return\r\n * the index of the closest element if there is no exact hit. This is because\r\n * mappings between original and generated line/col pairs are single points,\r\n * and there is an implicit region between each of them, so a miss just means\r\n * that you aren't on the very start of a region.\r\n *\r\n * @param aNeedle The element you are looking for.\r\n * @param aHaystack The array that is being searched.\r\n * @param aCompare A function which takes the needle and an element in the\r\n *     array and returns -1, 0, or 1 depending on whether the needle is less\r\n *     than, equal to, or greater than the element, respectively.\r\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\r\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\r\n */\r\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\r\n  if (aHaystack.length === 0) {\r\n    return -1;\r\n  }\r\n\r\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\r\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\r\n  if (index < 0) {\r\n    return -1;\r\n  }\r\n\r\n  // We have found either the exact element, or the next-closest element than\r\n  // the one we are searching for. However, there may be more than one such\r\n  // element. Make sure we always return the smallest of these.\r\n  while (index - 1 >= 0) {\r\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\r\n      break;\r\n    }\r\n    --index;\r\n  }\r\n\r\n  return index;\r\n};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEAA,OAAO,CAACC,oBAAoB,GAAG,CAAC;AAChCD,OAAO,CAACE,iBAAiB,GAAG,CAAC;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,KAAK,EAAE;EACzE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAIC,GAAG,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACP,KAAK,GAAGD,IAAI,IAAI,CAAC,CAAC,GAAGA,IAAI;EAC/C,IAAIS,GAAG,GAAGL,QAAQ,CAACF,OAAO,EAAEC,SAAS,CAACG,GAAG,CAAC,EAAE,IAAI,CAAC;EACjD,IAAIG,GAAG,KAAK,CAAC,EAAE;IACb;IACA,OAAOH,GAAG;EACZ,CAAC,MACI,IAAIG,GAAG,GAAG,CAAC,EAAE;IAChB;IACA,IAAIR,KAAK,GAAGK,GAAG,GAAG,CAAC,EAAE;MACnB;MACA,OAAOP,eAAe,CAACO,GAAG,EAAEL,KAAK,EAAEC,OAAO,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,KAAK,CAAC;IACzE;;IAEA;IACA;IACA,IAAIA,KAAK,IAAIT,OAAO,CAACE,iBAAiB,EAAE;MACtC,OAAOG,KAAK,GAAGE,SAAS,CAACO,MAAM,GAAGT,KAAK,GAAG,CAAC,CAAC;IAC9C,CAAC,MAAM;MACL,OAAOK,GAAG;IACZ;EACF,CAAC,MACI;IACH;IACA,IAAIA,GAAG,GAAGN,IAAI,GAAG,CAAC,EAAE;MAClB;MACA,OAAOD,eAAe,CAACC,IAAI,EAAEM,GAAG,EAAEJ,OAAO,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,KAAK,CAAC;IACxE;;IAEA;IACA,IAAIA,KAAK,IAAIT,OAAO,CAACE,iBAAiB,EAAE;MACtC,OAAOQ,GAAG;IACZ,CAAC,MAAM;MACL,OAAON,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGA,IAAI;IAC7B;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAJ,OAAO,CAACe,MAAM,GAAG,SAASA,MAAMA,CAACT,OAAO,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,KAAK,EAAE;EACpE,IAAIF,SAAS,CAACO,MAAM,KAAK,CAAC,EAAE;IAC1B,OAAO,CAAC,CAAC;EACX;EAEA,IAAIE,KAAK,GAAGb,eAAe,CAAC,CAAC,CAAC,EAAEI,SAAS,CAACO,MAAM,EAAER,OAAO,EAAEC,SAAS,EACxCC,QAAQ,EAAEC,KAAK,IAAIT,OAAO,CAACC,oBAAoB,CAAC;EAC5E,IAAIe,KAAK,GAAG,CAAC,EAAE;IACb,OAAO,CAAC,CAAC;EACX;;EAEA;EACA;EACA;EACA,OAAOA,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE;IACrB,IAAIR,QAAQ,CAACD,SAAS,CAACS,KAAK,CAAC,EAAET,SAAS,CAACS,KAAK,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE;MAChE;IACF;IACA,EAAEA,KAAK;EACT;EAEA,OAAOA,KAAK;AACd,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}