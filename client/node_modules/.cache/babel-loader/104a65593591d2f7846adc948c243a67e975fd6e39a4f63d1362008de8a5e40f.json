{"ast":null,"code":"\"use strict\";\n\nconst punycode = require(\"punycode\");\nconst regexes = require(\"./lib/regexes.js\");\nconst mappingTable = require(\"./lib/mappingTable.json\");\nconst {\n  STATUS_MAPPING\n} = require(\"./lib/statusMapping.js\");\nfunction containsNonASCII(str) {\n  return /[^\\x00-\\x7F]/.test(str);\n}\nfunction findStatus(val, _ref) {\n  let {\n    useSTD3ASCIIRules\n  } = _ref;\n  let start = 0;\n  let end = mappingTable.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const target = mappingTable[mid];\n    const min = Array.isArray(target[0]) ? target[0][0] : target[0];\n    const max = Array.isArray(target[0]) ? target[0][1] : target[0];\n    if (min <= val && max >= val) {\n      if (useSTD3ASCIIRules && (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {\n        return [STATUS_MAPPING.disallowed, ...target.slice(2)];\n      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {\n        return [STATUS_MAPPING.valid, ...target.slice(2)];\n      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {\n        return [STATUS_MAPPING.mapped, ...target.slice(2)];\n      }\n      return target.slice(1);\n    } else if (min > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return null;\n}\nfunction mapChars(domainName, _ref2) {\n  let {\n    useSTD3ASCIIRules,\n    processingOption\n  } = _ref2;\n  let hasError = false;\n  let processed = \"\";\n  for (const ch of domainName) {\n    const [status, mapping] = findStatus(ch.codePointAt(0), {\n      useSTD3ASCIIRules\n    });\n    switch (status) {\n      case STATUS_MAPPING.disallowed:\n        hasError = true;\n        processed += ch;\n        break;\n      case STATUS_MAPPING.ignored:\n        break;\n      case STATUS_MAPPING.mapped:\n        processed += mapping;\n        break;\n      case STATUS_MAPPING.deviation:\n        if (processingOption === \"transitional\") {\n          processed += mapping;\n        } else {\n          processed += ch;\n        }\n        break;\n      case STATUS_MAPPING.valid:\n        processed += ch;\n        break;\n    }\n  }\n  return {\n    string: processed,\n    error: hasError\n  };\n}\nfunction validateLabel(label, _ref3) {\n  let {\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    processingOption,\n    useSTD3ASCIIRules\n  } = _ref3;\n  if (label.normalize(\"NFC\") !== label) {\n    return false;\n  }\n  const codePoints = Array.from(label);\n  if (checkHyphens) {\n    if (codePoints[2] === \"-\" && codePoints[3] === \"-\" || label.startsWith(\"-\") || label.endsWith(\"-\")) {\n      return false;\n    }\n  }\n  if (label.includes(\".\") || codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0])) {\n    return false;\n  }\n  for (const ch of codePoints) {\n    const [status] = findStatus(ch.codePointAt(0), {\n      useSTD3ASCIIRules\n    });\n    if (processingOption === \"transitional\" && status !== STATUS_MAPPING.valid || processingOption === \"nontransitional\" && status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {\n      return false;\n    }\n  }\n\n  // https://tools.ietf.org/html/rfc5892#appendix-A\n  if (checkJoiners) {\n    let last = 0;\n    for (const [i, ch] of codePoints.entries()) {\n      if (ch === \"\\u200C\" || ch === \"\\u200D\") {\n        if (i > 0) {\n          if (regexes.combiningClassVirama.test(codePoints[i - 1])) {\n            continue;\n          }\n          if (ch === \"\\u200C\") {\n            // TODO: make this more efficient\n            const next = codePoints.indexOf(\"\\u200C\", i + 1);\n            const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);\n            if (regexes.validZWNJ.test(test.join(\"\"))) {\n              last = i + 1;\n              continue;\n            }\n          }\n        }\n        return false;\n      }\n    }\n  }\n\n  // https://tools.ietf.org/html/rfc5893#section-2\n  if (checkBidi) {\n    let rtl;\n\n    // 1\n    if (regexes.bidiS1LTR.test(codePoints[0])) {\n      rtl = false;\n    } else if (regexes.bidiS1RTL.test(codePoints[0])) {\n      rtl = true;\n    } else {\n      return false;\n    }\n    if (rtl) {\n      // 2-4\n      if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {\n        return false;\n      }\n    } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {\n      // 5-6\n      return false;\n    }\n  }\n  return true;\n}\nfunction isBidiDomain(labels) {\n  const domain = labels.map(label => {\n    if (label.startsWith(\"xn--\")) {\n      try {\n        return punycode.decode(label.substring(4));\n      } catch (err) {\n        return \"\";\n      }\n    }\n    return label;\n  }).join(\".\");\n  return regexes.bidiDomain.test(domain);\n}\nfunction processing(domainName, options) {\n  const {\n    processingOption\n  } = options;\n\n  // 1. Map.\n  let {\n    string,\n    error\n  } = mapChars(domainName, options);\n\n  // 2. Normalize.\n  string = string.normalize(\"NFC\");\n\n  // 3. Break.\n  const labels = string.split(\".\");\n  const isBidi = isBidiDomain(labels);\n\n  // 4. Convert/Validate.\n  for (const [i, origLabel] of labels.entries()) {\n    let label = origLabel;\n    let curProcessing = processingOption;\n    if (label.startsWith(\"xn--\")) {\n      try {\n        label = punycode.decode(label.substring(4));\n        labels[i] = label;\n      } catch (err) {\n        error = true;\n        continue;\n      }\n      curProcessing = \"nontransitional\";\n    }\n\n    // No need to validate if we already know there is an error.\n    if (error) {\n      continue;\n    }\n    const validation = validateLabel(label, Object.assign({}, options, {\n      processingOption: curProcessing,\n      checkBidi: options.checkBidi && isBidi\n    }));\n    if (!validation) {\n      error = true;\n    }\n  }\n  return {\n    string: labels.join(\".\"),\n    error\n  };\n}\nfunction toASCII(domainName) {\n  let {\n    checkHyphens = false,\n    checkBidi = false,\n    checkJoiners = false,\n    useSTD3ASCIIRules = false,\n    processingOption = \"nontransitional\",\n    verifyDNSLength = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (processingOption !== \"transitional\" && processingOption !== \"nontransitional\") {\n    throw new RangeError(\"processingOption must be either transitional or nontransitional\");\n  }\n  const result = processing(domainName, {\n    processingOption,\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules\n  });\n  let labels = result.string.split(\".\");\n  labels = labels.map(l => {\n    if (containsNonASCII(l)) {\n      try {\n        return \"xn--\" + punycode.encode(l);\n      } catch (e) {\n        result.error = true;\n      }\n    }\n    return l;\n  });\n  if (verifyDNSLength) {\n    const total = labels.join(\".\").length;\n    if (total > 253 || total === 0) {\n      result.error = true;\n    }\n    for (let i = 0; i < labels.length; ++i) {\n      if (labels[i].length > 63 || labels[i].length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n  if (result.error) {\n    return null;\n  }\n  return labels.join(\".\");\n}\nfunction toUnicode(domainName) {\n  let {\n    checkHyphens = false,\n    checkBidi = false,\n    checkJoiners = false,\n    useSTD3ASCIIRules = false,\n    processingOption = \"nontransitional\"\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = processing(domainName, {\n    processingOption,\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules\n  });\n  return {\n    domain: result.string,\n    error: result.error\n  };\n}\nmodule.exports = {\n  toASCII,\n  toUnicode\n};","map":{"version":3,"names":["punycode","require","regexes","mappingTable","STATUS_MAPPING","containsNonASCII","str","test","findStatus","val","_ref","useSTD3ASCIIRules","start","end","length","mid","Math","floor","target","min","Array","isArray","max","disallowed_STD3_valid","disallowed_STD3_mapped","disallowed","slice","valid","mapped","mapChars","domainName","_ref2","processingOption","hasError","processed","ch","status","mapping","codePointAt","ignored","deviation","string","error","validateLabel","label","_ref3","checkHyphens","checkBidi","checkJoiners","normalize","codePoints","from","startsWith","endsWith","includes","combiningMarks","last","i","entries","combiningClassVirama","next","indexOf","validZWNJ","join","rtl","bidiS1LTR","bidiS1RTL","bidiS2","bidiS3","bidiS4EN","bidiS4AN","bidiS5","bidiS6","isBidiDomain","labels","domain","map","decode","substring","err","bidiDomain","processing","options","split","isBidi","origLabel","curProcessing","validation","Object","assign","toASCII","verifyDNSLength","arguments","undefined","RangeError","result","l","encode","e","total","toUnicode","module","exports"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/tr46/index.js"],"sourcesContent":["\"use strict\";\r\n\r\nconst punycode = require(\"punycode\");\r\nconst regexes = require(\"./lib/regexes.js\");\r\nconst mappingTable = require(\"./lib/mappingTable.json\");\r\nconst { STATUS_MAPPING } = require(\"./lib/statusMapping.js\");\r\n\r\nfunction containsNonASCII(str) {\r\n  return /[^\\x00-\\x7F]/.test(str);\r\n}\r\n\r\nfunction findStatus(val, { useSTD3ASCIIRules }) {\r\n  let start = 0;\r\n  let end = mappingTable.length - 1;\r\n\r\n  while (start <= end) {\r\n    const mid = Math.floor((start + end) / 2);\r\n\r\n    const target = mappingTable[mid];\r\n    const min = Array.isArray(target[0]) ? target[0][0] : target[0];\r\n    const max = Array.isArray(target[0]) ? target[0][1] : target[0];\r\n\r\n    if (min <= val && max >= val) {\r\n      if (useSTD3ASCIIRules &&\r\n          (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {\r\n        return [STATUS_MAPPING.disallowed, ...target.slice(2)];\r\n      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {\r\n        return [STATUS_MAPPING.valid, ...target.slice(2)];\r\n      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {\r\n        return [STATUS_MAPPING.mapped, ...target.slice(2)];\r\n      }\r\n\r\n      return target.slice(1);\r\n    } else if (min > val) {\r\n      end = mid - 1;\r\n    } else {\r\n      start = mid + 1;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction mapChars(domainName, { useSTD3ASCIIRules, processingOption }) {\r\n  let hasError = false;\r\n  let processed = \"\";\r\n\r\n  for (const ch of domainName) {\r\n    const [status, mapping] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });\r\n\r\n    switch (status) {\r\n      case STATUS_MAPPING.disallowed:\r\n        hasError = true;\r\n        processed += ch;\r\n        break;\r\n      case STATUS_MAPPING.ignored:\r\n        break;\r\n      case STATUS_MAPPING.mapped:\r\n        processed += mapping;\r\n        break;\r\n      case STATUS_MAPPING.deviation:\r\n        if (processingOption === \"transitional\") {\r\n          processed += mapping;\r\n        } else {\r\n          processed += ch;\r\n        }\r\n        break;\r\n      case STATUS_MAPPING.valid:\r\n        processed += ch;\r\n        break;\r\n    }\r\n  }\r\n\r\n  return {\r\n    string: processed,\r\n    error: hasError\r\n  };\r\n}\r\n\r\nfunction validateLabel(label, { checkHyphens, checkBidi, checkJoiners, processingOption, useSTD3ASCIIRules }) {\r\n  if (label.normalize(\"NFC\") !== label) {\r\n    return false;\r\n  }\r\n\r\n  const codePoints = Array.from(label);\r\n\r\n  if (checkHyphens) {\r\n    if ((codePoints[2] === \"-\" && codePoints[3] === \"-\") ||\r\n        (label.startsWith(\"-\") || label.endsWith(\"-\"))) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (label.includes(\".\") ||\r\n      (codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0]))) {\r\n    return false;\r\n  }\r\n\r\n  for (const ch of codePoints) {\r\n    const [status] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });\r\n    if ((processingOption === \"transitional\" && status !== STATUS_MAPPING.valid) ||\r\n        (processingOption === \"nontransitional\" &&\r\n         status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // https://tools.ietf.org/html/rfc5892#appendix-A\r\n  if (checkJoiners) {\r\n    let last = 0;\r\n    for (const [i, ch] of codePoints.entries()) {\r\n      if (ch === \"\\u200C\" || ch === \"\\u200D\") {\r\n        if (i > 0) {\r\n          if (regexes.combiningClassVirama.test(codePoints[i - 1])) {\r\n            continue;\r\n          }\r\n          if (ch === \"\\u200C\") {\r\n            // TODO: make this more efficient\r\n            const next = codePoints.indexOf(\"\\u200C\", i + 1);\r\n            const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);\r\n            if (regexes.validZWNJ.test(test.join(\"\"))) {\r\n              last = i + 1;\r\n              continue;\r\n            }\r\n          }\r\n        }\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  // https://tools.ietf.org/html/rfc5893#section-2\r\n  if (checkBidi) {\r\n    let rtl;\r\n\r\n    // 1\r\n    if (regexes.bidiS1LTR.test(codePoints[0])) {\r\n      rtl = false;\r\n    } else if (regexes.bidiS1RTL.test(codePoints[0])) {\r\n      rtl = true;\r\n    } else {\r\n      return false;\r\n    }\r\n\r\n    if (rtl) {\r\n      // 2-4\r\n      if (!regexes.bidiS2.test(label) ||\r\n          !regexes.bidiS3.test(label) ||\r\n          (regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label))) {\r\n        return false;\r\n      }\r\n    } else if (!regexes.bidiS5.test(label) ||\r\n               !regexes.bidiS6.test(label)) { // 5-6\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction isBidiDomain(labels) {\r\n  const domain = labels.map(label => {\r\n    if (label.startsWith(\"xn--\")) {\r\n      try {\r\n        return punycode.decode(label.substring(4));\r\n      } catch (err) {\r\n        return \"\";\r\n      }\r\n    }\r\n    return label;\r\n  }).join(\".\");\r\n  return regexes.bidiDomain.test(domain);\r\n}\r\n\r\nfunction processing(domainName, options) {\r\n  const { processingOption } = options;\r\n\r\n  // 1. Map.\r\n  let { string, error } = mapChars(domainName, options);\r\n\r\n  // 2. Normalize.\r\n  string = string.normalize(\"NFC\");\r\n\r\n  // 3. Break.\r\n  const labels = string.split(\".\");\r\n  const isBidi = isBidiDomain(labels);\r\n\r\n  // 4. Convert/Validate.\r\n  for (const [i, origLabel] of labels.entries()) {\r\n    let label = origLabel;\r\n    let curProcessing = processingOption;\r\n    if (label.startsWith(\"xn--\")) {\r\n      try {\r\n        label = punycode.decode(label.substring(4));\r\n        labels[i] = label;\r\n      } catch (err) {\r\n        error = true;\r\n        continue;\r\n      }\r\n      curProcessing = \"nontransitional\";\r\n    }\r\n\r\n    // No need to validate if we already know there is an error.\r\n    if (error) {\r\n      continue;\r\n    }\r\n    const validation = validateLabel(label, Object.assign({}, options, {\r\n      processingOption: curProcessing,\r\n      checkBidi: options.checkBidi && isBidi\r\n    }));\r\n    if (!validation) {\r\n      error = true;\r\n    }\r\n  }\r\n\r\n  return {\r\n    string: labels.join(\".\"),\r\n    error\r\n  };\r\n}\r\n\r\nfunction toASCII(domainName, {\r\n  checkHyphens = false,\r\n  checkBidi = false,\r\n  checkJoiners = false,\r\n  useSTD3ASCIIRules = false,\r\n  processingOption = \"nontransitional\",\r\n  verifyDNSLength = false\r\n} = {}) {\r\n  if (processingOption !== \"transitional\" && processingOption !== \"nontransitional\") {\r\n    throw new RangeError(\"processingOption must be either transitional or nontransitional\");\r\n  }\r\n\r\n  const result = processing(domainName, {\r\n    processingOption,\r\n    checkHyphens,\r\n    checkBidi,\r\n    checkJoiners,\r\n    useSTD3ASCIIRules\r\n  });\r\n  let labels = result.string.split(\".\");\r\n  labels = labels.map(l => {\r\n    if (containsNonASCII(l)) {\r\n      try {\r\n        return \"xn--\" + punycode.encode(l);\r\n      } catch (e) {\r\n        result.error = true;\r\n      }\r\n    }\r\n    return l;\r\n  });\r\n\r\n  if (verifyDNSLength) {\r\n    const total = labels.join(\".\").length;\r\n    if (total > 253 || total === 0) {\r\n      result.error = true;\r\n    }\r\n\r\n    for (let i = 0; i < labels.length; ++i) {\r\n      if (labels[i].length > 63 || labels[i].length === 0) {\r\n        result.error = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (result.error) {\r\n    return null;\r\n  }\r\n  return labels.join(\".\");\r\n}\r\n\r\nfunction toUnicode(domainName, {\r\n  checkHyphens = false,\r\n  checkBidi = false,\r\n  checkJoiners = false,\r\n  useSTD3ASCIIRules = false,\r\n  processingOption = \"nontransitional\"\r\n} = {}) {\r\n  const result = processing(domainName, {\r\n    processingOption,\r\n    checkHyphens,\r\n    checkBidi,\r\n    checkJoiners,\r\n    useSTD3ASCIIRules\r\n  });\r\n\r\n  return {\r\n    domain: result.string,\r\n    error: result.error\r\n  };\r\n}\r\n\r\nmodule.exports = {\r\n  toASCII,\r\n  toUnicode\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}