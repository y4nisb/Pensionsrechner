{"ast":null,"code":"\"use strict\";\n\nconst {\n  utf8Encode,\n  utf8DecodeWithoutBOM\n} = require(\"./encoding\");\nconst {\n  percentDecodeBytes,\n  utf8PercentEncodeString,\n  isURLEncodedPercentEncode\n} = require(\"./percent-encoding\");\n\n// https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseUrlencoded(input) {\n  const sequences = strictlySplitByteSequence(input, 38);\n  const output = [];\n  for (const bytes of sequences) {\n    if (bytes.length === 0) {\n      continue;\n    }\n    let name, value;\n    const indexOfEqual = bytes.indexOf(61);\n    if (indexOfEqual >= 0) {\n      name = bytes.slice(0, indexOfEqual);\n      value = bytes.slice(indexOfEqual + 1);\n    } else {\n      name = bytes;\n      value = new Uint8Array(0);\n    }\n    name = replaceByteInByteSequence(name, 0x2B, 0x20);\n    value = replaceByteInByteSequence(value, 0x2B, 0x20);\n    const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));\n    const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));\n    output.push([nameString, valueString]);\n  }\n  return output;\n}\n\n// https://url.spec.whatwg.org/#concept-urlencoded-string-parser\nfunction parseUrlencodedString(input) {\n  return parseUrlencoded(utf8Encode(input));\n}\n\n// https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeUrlencoded(tuples) {\n  let encodingOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  let encoding = \"utf-8\";\n  if (encodingOverride !== undefined) {\n    // TODO \"get the output encoding\", i.e. handle encoding labels vs. names.\n    encoding = encodingOverride;\n  }\n  let output = \"\";\n  for (const [i, tuple] of tuples.entries()) {\n    // TODO: handle encoding override\n\n    const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);\n    let value = tuple[1];\n    if (tuple.length > 2 && tuple[2] !== undefined) {\n      if (tuple[2] === \"hidden\" && name === \"_charset_\") {\n        value = encoding;\n      } else if (tuple[2] === \"file\") {\n        // value is a File object\n        value = value.name;\n      }\n    }\n    value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);\n    if (i !== 0) {\n      output += \"&\";\n    }\n    output += `${name}=${value}`;\n  }\n  return output;\n}\nfunction strictlySplitByteSequence(buf, cp) {\n  const list = [];\n  let last = 0;\n  let i = buf.indexOf(cp);\n  while (i >= 0) {\n    list.push(buf.slice(last, i));\n    last = i + 1;\n    i = buf.indexOf(cp, last);\n  }\n  if (last !== buf.length) {\n    list.push(buf.slice(last));\n  }\n  return list;\n}\nfunction replaceByteInByteSequence(buf, from, to) {\n  let i = buf.indexOf(from);\n  while (i >= 0) {\n    buf[i] = to;\n    i = buf.indexOf(from, i + 1);\n  }\n  return buf;\n}\nmodule.exports = {\n  parseUrlencodedString,\n  serializeUrlencoded\n};","map":{"version":3,"names":["utf8Encode","utf8DecodeWithoutBOM","require","percentDecodeBytes","utf8PercentEncodeString","isURLEncodedPercentEncode","parseUrlencoded","input","sequences","strictlySplitByteSequence","output","bytes","length","name","value","indexOfEqual","indexOf","slice","Uint8Array","replaceByteInByteSequence","nameString","valueString","push","parseUrlencodedString","serializeUrlencoded","tuples","encodingOverride","arguments","undefined","encoding","i","tuple","entries","buf","cp","list","last","from","to","module","exports"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/whatwg-url/dist/urlencoded.js"],"sourcesContent":["\"use strict\";\r\nconst { utf8Encode, utf8DecodeWithoutBOM } = require(\"./encoding\");\r\nconst { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = require(\"./percent-encoding\");\r\n\r\n// https://url.spec.whatwg.org/#concept-urlencoded-parser\r\nfunction parseUrlencoded(input) {\r\n  const sequences = strictlySplitByteSequence(input, 38);\r\n  const output = [];\r\n  for (const bytes of sequences) {\r\n    if (bytes.length === 0) {\r\n      continue;\r\n    }\r\n\r\n    let name, value;\r\n    const indexOfEqual = bytes.indexOf(61);\r\n\r\n    if (indexOfEqual >= 0) {\r\n      name = bytes.slice(0, indexOfEqual);\r\n      value = bytes.slice(indexOfEqual + 1);\r\n    } else {\r\n      name = bytes;\r\n      value = new Uint8Array(0);\r\n    }\r\n\r\n    name = replaceByteInByteSequence(name, 0x2B, 0x20);\r\n    value = replaceByteInByteSequence(value, 0x2B, 0x20);\r\n\r\n    const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));\r\n    const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));\r\n\r\n    output.push([nameString, valueString]);\r\n  }\r\n  return output;\r\n}\r\n\r\n// https://url.spec.whatwg.org/#concept-urlencoded-string-parser\r\nfunction parseUrlencodedString(input) {\r\n  return parseUrlencoded(utf8Encode(input));\r\n}\r\n\r\n// https://url.spec.whatwg.org/#concept-urlencoded-serializer\r\nfunction serializeUrlencoded(tuples, encodingOverride = undefined) {\r\n  let encoding = \"utf-8\";\r\n  if (encodingOverride !== undefined) {\r\n    // TODO \"get the output encoding\", i.e. handle encoding labels vs. names.\r\n    encoding = encodingOverride;\r\n  }\r\n\r\n  let output = \"\";\r\n  for (const [i, tuple] of tuples.entries()) {\r\n    // TODO: handle encoding override\r\n\r\n    const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);\r\n\r\n    let value = tuple[1];\r\n    if (tuple.length > 2 && tuple[2] !== undefined) {\r\n      if (tuple[2] === \"hidden\" && name === \"_charset_\") {\r\n        value = encoding;\r\n      } else if (tuple[2] === \"file\") {\r\n        // value is a File object\r\n        value = value.name;\r\n      }\r\n    }\r\n\r\n    value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);\r\n\r\n    if (i !== 0) {\r\n      output += \"&\";\r\n    }\r\n    output += `${name}=${value}`;\r\n  }\r\n  return output;\r\n}\r\n\r\nfunction strictlySplitByteSequence(buf, cp) {\r\n  const list = [];\r\n  let last = 0;\r\n  let i = buf.indexOf(cp);\r\n  while (i >= 0) {\r\n    list.push(buf.slice(last, i));\r\n    last = i + 1;\r\n    i = buf.indexOf(cp, last);\r\n  }\r\n  if (last !== buf.length) {\r\n    list.push(buf.slice(last));\r\n  }\r\n  return list;\r\n}\r\n\r\nfunction replaceByteInByteSequence(buf, from, to) {\r\n  let i = buf.indexOf(from);\r\n  while (i >= 0) {\r\n    buf[i] = to;\r\n    i = buf.indexOf(from, i + 1);\r\n  }\r\n  return buf;\r\n}\r\n\r\nmodule.exports = {\r\n  parseUrlencodedString,\r\n  serializeUrlencoded\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}