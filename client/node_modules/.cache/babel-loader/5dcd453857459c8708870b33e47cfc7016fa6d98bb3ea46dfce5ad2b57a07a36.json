{"ast":null,"code":"\"use strict\";\n\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst {\n  Writable\n} = require(\"stream\");\nconst zlib = require(\"zlib\");\nconst ver = process.version.replace(\"v\", \"\").split(\".\");\nconst majorNodeVersion = Number.parseInt(ver[0]);\nfunction abortRequest(clientRequest) {\n  // clientRequest.destroy breaks the test suite for versions 10 and 12,\n  // hence the version check\n  if (majorNodeVersion > 13) {\n    clientRequest.destroy();\n  } else {\n    clientRequest.abort();\n  }\n  clientRequest.removeAllListeners();\n  clientRequest.on(\"error\", () => {});\n}\nmodule.exports = class Request extends Writable {\n  constructor(url, clientOptions, requestOptions) {\n    super();\n    Object.assign(this, clientOptions);\n    this.currentURL = url;\n    this._requestOptions = requestOptions;\n    this.headers = requestOptions.headers;\n    this._ended = false;\n    this._redirectCount = 0;\n    this._requestBodyBuffers = [];\n    this._bufferIndex = 0;\n    this._performRequest();\n  }\n  abort() {\n    abortRequest(this._currentRequest);\n    this.emit(\"abort\");\n    this.removeAllListeners();\n  }\n  pipeRequest(form) {\n    form.pipe(this._currentRequest);\n  }\n  write(data, encoding) {\n    if (data.length > 0) {\n      this._requestBodyBuffers.push({\n        data,\n        encoding\n      });\n      this._currentRequest.write(data, encoding);\n    }\n  }\n  end() {\n    this.emit(\"request\", this._currentRequest);\n    this._ended = true;\n    this._currentRequest.end();\n  }\n  setHeader(name, value) {\n    this.headers[name] = value;\n    this._currentRequest.setHeader(name, value);\n  }\n  removeHeader(name) {\n    delete this.headers[name];\n    this._currentRequest.removeHeader(name);\n  }\n\n  // Without this method, the test send-redirect-infinite-sync will halt the test suite\n  // TODO: investigate this further and ideally remove\n  toJSON() {\n    const {\n      method,\n      headers\n    } = this._requestOptions;\n    return {\n      uri: new URL(this.currentURL),\n      method,\n      headers\n    };\n  }\n  _writeNext(error) {\n    if (this._currentRequest) {\n      if (error) {\n        this.emit(\"error\", error);\n      } else if (this._bufferIndex < this._requestBodyBuffers.length) {\n        const buffer = this._requestBodyBuffers[this._bufferIndex++];\n        if (!this._currentRequest.writableEnded) {\n          this._currentRequest.write(buffer.data, buffer.encoding, this._writeNext.bind(this));\n        }\n      } else if (this._ended) {\n        this._currentRequest.end();\n      }\n    }\n  }\n  _performRequest() {\n    var _this = this;\n    const urlOptions = new URL(this.currentURL);\n    const scheme = urlOptions.protocol;\n    this._requestOptions.agent = this.agents[scheme.substring(0, scheme.length - 1)];\n    const {\n      request\n    } = scheme === \"https:\" ? https : http;\n    this._currentRequest = request(this.currentURL, this._requestOptions, response => {\n      this._processResponse(response);\n    });\n    let cookies;\n    if (this._redirectCount === 0) {\n      this.originalCookieHeader = this.getHeader(\"Cookie\");\n    }\n    if (this.cookieJar) {\n      cookies = this.cookieJar.getCookieStringSync(this.currentURL);\n    }\n    if (cookies && cookies.length) {\n      if (this.originalCookieHeader) {\n        this.setHeader(\"Cookie\", this.originalCookieHeader + \"; \" + cookies);\n      } else {\n        this.setHeader(\"Cookie\", cookies);\n      }\n    }\n    for (const event of [\"connect\", \"error\", \"socket\", \"timeout\"]) {\n      this._currentRequest.on(event, function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this.emit(event, ...args);\n      });\n    }\n    if (this._isRedirect) {\n      this._bufferIndex = 0;\n      this._writeNext();\n    }\n  }\n  _processResponse(response) {\n    const cookies = response.headers[\"set-cookie\"];\n    if (this.cookieJar && Array.isArray(cookies)) {\n      try {\n        cookies.forEach(cookie => {\n          this.cookieJar.setCookieSync(cookie, this.currentURL, {\n            ignoreError: true\n          });\n        });\n      } catch (e) {\n        this.emit(\"error\", e);\n      }\n    }\n    const {\n      statusCode\n    } = response;\n    const {\n      location\n    } = response.headers;\n    // In Node v15, aborting a message with remaining data causes an error to be thrown,\n    // hence the version check\n    const catchResErrors = err => {\n      if (!(majorNodeVersion >= 15 && err.message === \"aborted\")) {\n        this.emit(\"error\", err);\n      }\n    };\n    response.on(\"error\", catchResErrors);\n    let redirectAddress = null;\n    let resendWithAuth = false;\n    if (typeof location === \"string\" && location.length && this.followRedirects && statusCode >= 300 && statusCode < 400) {\n      redirectAddress = location;\n    } else if (statusCode === 401 && /^Basic /i.test(response.headers[\"www-authenticate\"] || \"\") && this.user && this.user.length) {\n      this._requestOptions.auth = `${this.user}:${this.pass}`;\n      resendWithAuth = true;\n    }\n    if (redirectAddress || resendWithAuth) {\n      if (++this._redirectCount > 21) {\n        const redirectError = new Error(\"Maximum number of redirects exceeded\");\n        redirectError.code = \"ERR_TOO_MANY_REDIRECTS\";\n        this.emit(\"error\", redirectError);\n        return;\n      }\n      abortRequest(this._currentRequest);\n      response.destroy();\n      this._isRedirect = true;\n      if ((statusCode === 301 || statusCode === 302) && this._requestOptions.method === \"POST\" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._requestOptions.method)) {\n        this._requestOptions.method = \"GET\";\n        this._requestBodyBuffers = [];\n      }\n      let previousHostName = this._removeMatchingHeaders(/^host$/i);\n      if (!previousHostName) {\n        previousHostName = new URL(this.currentURL).hostname;\n      }\n      const previousURL = this.currentURL;\n      if (!resendWithAuth) {\n        const nextURL = redirectAddress.startsWith(\"https:\") ? new URL(redirectAddress) : new URL(redirectAddress, this.currentURL);\n        if (nextURL.hostname !== previousHostName) {\n          this._removeMatchingHeaders(/^authorization$/i);\n        }\n        this.currentURL = nextURL.toString();\n      }\n      this.headers.Referer = previousURL;\n      this.emit(\"redirect\", response, this.headers, this.currentURL);\n      try {\n        this._performRequest();\n      } catch (cause) {\n        this.emit(\"error\", cause);\n      }\n    } else {\n      let pipeline = response;\n      const acceptEncoding = this.headers[\"Accept-Encoding\"];\n      const requestCompressed = typeof acceptEncoding === \"string\" && (acceptEncoding.includes(\"gzip\") || acceptEncoding.includes(\"deflate\"));\n      if (requestCompressed && this._requestOptions.method !== \"HEAD\" && statusCode >= 200 && statusCode !== 204 && statusCode !== 304) {\n        const zlibOptions = {\n          flush: zlib.constants.Z_SYNC_FLUSH,\n          finishFlush: zlib.constants.Z_SYNC_FLUSH\n        };\n        const contentEncoding = (response.headers[\"content-encoding\"] || \"identity\").trim().toLowerCase();\n        if (contentEncoding === \"gzip\") {\n          pipeline = zlib.createGunzip(zlibOptions);\n          response.pipe(pipeline);\n        } else if (contentEncoding === \"deflate\") {\n          pipeline = zlib.createInflate(zlibOptions);\n          response.pipe(pipeline);\n        }\n      }\n      pipeline.removeAllListeners(\"error\");\n      this.emit(\"response\", response, this.currentURL);\n      pipeline.on(\"data\", bytes => this.emit(\"data\", bytes));\n      pipeline.once(\"end\", bytes => this.emit(\"end\", bytes));\n      pipeline.on(\"error\", catchResErrors);\n      pipeline.on(\"close\", () => this.emit(\"close\"));\n      this._requestBodyBuffers = [];\n    }\n  }\n  getHeader(key, value) {\n    if (this._currentRequest) {\n      return this._currentRequest.getHeader(key, value);\n    }\n    return null;\n  }\n  _removeMatchingHeaders(regex) {\n    let lastValue;\n    for (const header in this.headers) {\n      if (regex.test(header)) {\n        lastValue = this.headers[header];\n        delete this.headers[header];\n      }\n    }\n    return lastValue;\n  }\n};","map":{"version":3,"names":["http","require","https","Writable","zlib","ver","process","version","replace","split","majorNodeVersion","Number","parseInt","abortRequest","clientRequest","destroy","abort","removeAllListeners","on","module","exports","Request","constructor","url","clientOptions","requestOptions","Object","assign","currentURL","_requestOptions","headers","_ended","_redirectCount","_requestBodyBuffers","_bufferIndex","_performRequest","_currentRequest","emit","pipeRequest","form","pipe","write","data","encoding","length","push","end","setHeader","name","value","removeHeader","toJSON","method","uri","URL","_writeNext","error","buffer","writableEnded","bind","_this","urlOptions","scheme","protocol","agent","agents","substring","request","response","_processResponse","cookies","originalCookieHeader","getHeader","cookieJar","getCookieStringSync","event","_len","arguments","args","Array","_key","_isRedirect","isArray","forEach","cookie","setCookieSync","ignoreError","e","statusCode","location","catchResErrors","err","message","redirectAddress","resendWithAuth","followRedirects","test","user","auth","pass","redirectError","Error","code","previousHostName","_removeMatchingHeaders","hostname","previousURL","nextURL","startsWith","toString","Referer","cause","pipeline","acceptEncoding","requestCompressed","includes","zlibOptions","flush","constants","Z_SYNC_FLUSH","finishFlush","contentEncoding","trim","toLowerCase","createGunzip","createInflate","bytes","once","key","regex","lastValue","header"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/jsdom/living/helpers/http-request.js"],"sourcesContent":["\"use strict\";\r\nconst http = require(\"http\");\r\nconst https = require(\"https\");\r\nconst { Writable } = require(\"stream\");\r\nconst zlib = require(\"zlib\");\r\n\r\nconst ver = process.version.replace(\"v\", \"\").split(\".\");\r\nconst majorNodeVersion = Number.parseInt(ver[0]);\r\n\r\nfunction abortRequest(clientRequest) {\r\n  // clientRequest.destroy breaks the test suite for versions 10 and 12,\r\n  // hence the version check\r\n  if (majorNodeVersion > 13) {\r\n    clientRequest.destroy();\r\n  } else {\r\n    clientRequest.abort();\r\n  }\r\n  clientRequest.removeAllListeners();\r\n  clientRequest.on(\"error\", () => {});\r\n}\r\n\r\nmodule.exports = class Request extends Writable {\r\n  constructor(url, clientOptions, requestOptions) {\r\n    super();\r\n    Object.assign(this, clientOptions);\r\n    this.currentURL = url;\r\n    this._requestOptions = requestOptions;\r\n    this.headers = requestOptions.headers;\r\n    this._ended = false;\r\n    this._redirectCount = 0;\r\n    this._requestBodyBuffers = [];\r\n    this._bufferIndex = 0;\r\n    this._performRequest();\r\n  }\r\n\r\n  abort() {\r\n    abortRequest(this._currentRequest);\r\n    this.emit(\"abort\");\r\n    this.removeAllListeners();\r\n  }\r\n\r\n  pipeRequest(form) {\r\n    form.pipe(this._currentRequest);\r\n  }\r\n\r\n  write(data, encoding) {\r\n    if (data.length > 0) {\r\n      this._requestBodyBuffers.push({ data, encoding });\r\n      this._currentRequest.write(data, encoding);\r\n    }\r\n  }\r\n\r\n  end() {\r\n    this.emit(\"request\", this._currentRequest);\r\n    this._ended = true;\r\n    this._currentRequest.end();\r\n  }\r\n\r\n  setHeader(name, value) {\r\n    this.headers[name] = value;\r\n    this._currentRequest.setHeader(name, value);\r\n  }\r\n\r\n  removeHeader(name) {\r\n    delete this.headers[name];\r\n    this._currentRequest.removeHeader(name);\r\n  }\r\n\r\n  // Without this method, the test send-redirect-infinite-sync will halt the test suite\r\n  // TODO: investigate this further and ideally remove\r\n  toJSON() {\r\n    const { method, headers } = this._requestOptions;\r\n    return { uri: new URL(this.currentURL), method, headers };\r\n  }\r\n\r\n  _writeNext(error) {\r\n    if (this._currentRequest) {\r\n      if (error) {\r\n        this.emit(\"error\", error);\r\n      } else if (this._bufferIndex < this._requestBodyBuffers.length) {\r\n        const buffer = this._requestBodyBuffers[this._bufferIndex++];\r\n        if (!this._currentRequest.writableEnded) {\r\n          this._currentRequest.write(\r\n            buffer.data,\r\n            buffer.encoding,\r\n            this._writeNext.bind(this)\r\n          );\r\n        }\r\n      } else if (this._ended) {\r\n        this._currentRequest.end();\r\n      }\r\n    }\r\n  }\r\n\r\n  _performRequest() {\r\n    const urlOptions = new URL(this.currentURL);\r\n    const scheme = urlOptions.protocol;\r\n    this._requestOptions.agent = this.agents[scheme.substring(0, scheme.length - 1)];\r\n    const { request } = scheme === \"https:\" ? https : http;\r\n    this._currentRequest = request(this.currentURL, this._requestOptions, response => {\r\n      this._processResponse(response);\r\n    });\r\n\r\n    let cookies;\r\n    if (this._redirectCount === 0) {\r\n      this.originalCookieHeader = this.getHeader(\"Cookie\");\r\n    }\r\n    if (this.cookieJar) {\r\n      cookies = this.cookieJar.getCookieStringSync(this.currentURL);\r\n    }\r\n    if (cookies && cookies.length) {\r\n      if (this.originalCookieHeader) {\r\n        this.setHeader(\"Cookie\", this.originalCookieHeader + \"; \" + cookies);\r\n      } else {\r\n        this.setHeader(\"Cookie\", cookies);\r\n      }\r\n    }\r\n\r\n    for (const event of [\"connect\", \"error\", \"socket\", \"timeout\"]) {\r\n      this._currentRequest.on(event, (...args) => {\r\n        this.emit(event, ...args);\r\n      });\r\n    }\r\n    if (this._isRedirect) {\r\n      this._bufferIndex = 0;\r\n      this._writeNext();\r\n    }\r\n  }\r\n\r\n  _processResponse(response) {\r\n    const cookies = response.headers[\"set-cookie\"];\r\n    if (this.cookieJar && Array.isArray(cookies)) {\r\n      try {\r\n        cookies.forEach(cookie => {\r\n          this.cookieJar.setCookieSync(cookie, this.currentURL, { ignoreError: true });\r\n        });\r\n      } catch (e) {\r\n        this.emit(\"error\", e);\r\n      }\r\n    }\r\n\r\n    const { statusCode } = response;\r\n    const { location } = response.headers;\r\n    // In Node v15, aborting a message with remaining data causes an error to be thrown,\r\n    // hence the version check\r\n    const catchResErrors = err => {\r\n      if (!(majorNodeVersion >= 15 && err.message === \"aborted\")) {\r\n        this.emit(\"error\", err);\r\n      }\r\n    };\r\n    response.on(\"error\", catchResErrors);\r\n    let redirectAddress = null;\r\n    let resendWithAuth = false;\r\n    if (typeof location === \"string\" &&\r\n      location.length &&\r\n      this.followRedirects &&\r\n      statusCode >= 300 &&\r\n      statusCode < 400) {\r\n      redirectAddress = location;\r\n    } else if (statusCode === 401 &&\r\n      /^Basic /i.test(response.headers[\"www-authenticate\"] || \"\") &&\r\n      (this.user && this.user.length)) {\r\n      this._requestOptions.auth = `${this.user}:${this.pass}`;\r\n      resendWithAuth = true;\r\n    }\r\n    if (redirectAddress || resendWithAuth) {\r\n      if (++this._redirectCount > 21) {\r\n        const redirectError = new Error(\"Maximum number of redirects exceeded\");\r\n        redirectError.code = \"ERR_TOO_MANY_REDIRECTS\";\r\n        this.emit(\"error\", redirectError);\r\n        return;\r\n      }\r\n      abortRequest(this._currentRequest);\r\n      response.destroy();\r\n      this._isRedirect = true;\r\n      if (((statusCode === 301 || statusCode === 302) && this._requestOptions.method === \"POST\") ||\r\n        (statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._requestOptions.method))) {\r\n        this._requestOptions.method = \"GET\";\r\n        this._requestBodyBuffers = [];\r\n      }\r\n      let previousHostName = this._removeMatchingHeaders(/^host$/i);\r\n      if (!previousHostName) {\r\n        previousHostName = new URL(this.currentURL).hostname;\r\n      }\r\n      const previousURL = this.currentURL;\r\n      if (!resendWithAuth) {\r\n        const nextURL = redirectAddress.startsWith(\"https:\") ?\r\n          new URL(redirectAddress) :\r\n          new URL(redirectAddress, this.currentURL);\r\n        if (nextURL.hostname !== previousHostName) {\r\n          this._removeMatchingHeaders(/^authorization$/i);\r\n        }\r\n        this.currentURL = nextURL.toString();\r\n      }\r\n      this.headers.Referer = previousURL;\r\n      this.emit(\"redirect\", response, this.headers, this.currentURL);\r\n      try {\r\n        this._performRequest();\r\n      } catch (cause) {\r\n        this.emit(\"error\", cause);\r\n      }\r\n    } else {\r\n      let pipeline = response;\r\n      const acceptEncoding = this.headers[\"Accept-Encoding\"];\r\n      const requestCompressed = typeof acceptEncoding === \"string\" &&\r\n        (acceptEncoding.includes(\"gzip\") || acceptEncoding.includes(\"deflate\"));\r\n      if (\r\n        requestCompressed &&\r\n        this._requestOptions.method !== \"HEAD\" &&\r\n        statusCode >= 200 &&\r\n        statusCode !== 204 &&\r\n        statusCode !== 304\r\n      ) {\r\n        const zlibOptions = {\r\n          flush: zlib.constants.Z_SYNC_FLUSH,\r\n          finishFlush: zlib.constants.Z_SYNC_FLUSH\r\n        };\r\n        const contentEncoding = (response.headers[\"content-encoding\"] || \"identity\").trim().toLowerCase();\r\n        if (contentEncoding === \"gzip\") {\r\n          pipeline = zlib.createGunzip(zlibOptions);\r\n          response.pipe(pipeline);\r\n        } else if (contentEncoding === \"deflate\") {\r\n          pipeline = zlib.createInflate(zlibOptions);\r\n          response.pipe(pipeline);\r\n        }\r\n      }\r\n      pipeline.removeAllListeners(\"error\");\r\n      this.emit(\"response\", response, this.currentURL);\r\n      pipeline.on(\"data\", bytes => this.emit(\"data\", bytes));\r\n      pipeline.once(\"end\", bytes => this.emit(\"end\", bytes));\r\n      pipeline.on(\"error\", catchResErrors);\r\n      pipeline.on(\"close\", () => this.emit(\"close\"));\r\n      this._requestBodyBuffers = [];\r\n    }\r\n  }\r\n\r\n  getHeader(key, value) {\r\n    if (this._currentRequest) {\r\n      return this._currentRequest.getHeader(key, value);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _removeMatchingHeaders(regex) {\r\n    let lastValue;\r\n    for (const header in this.headers) {\r\n      if (regex.test(header)) {\r\n        lastValue = this.headers[header];\r\n        delete this.headers[header];\r\n      }\r\n    }\r\n    return lastValue;\r\n  }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}