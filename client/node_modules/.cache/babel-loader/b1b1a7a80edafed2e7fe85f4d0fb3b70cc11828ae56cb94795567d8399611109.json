{"ast":null,"code":"\"use strict\";\n\nconst MIMEType = require(\"whatwg-mimetype\");\nconst {\n  parseURL,\n  serializeURL\n} = require(\"whatwg-url\");\nconst {\n  stripLeadingAndTrailingASCIIWhitespace,\n  stringPercentDecode,\n  isomorphicDecode,\n  forgivingBase64Decode\n} = require(\"./utils.js\");\nmodule.exports = stringInput => {\n  const urlRecord = parseURL(stringInput);\n  if (urlRecord === null) {\n    return null;\n  }\n  return module.exports.fromURLRecord(urlRecord);\n};\nmodule.exports.fromURLRecord = urlRecord => {\n  if (urlRecord.scheme !== \"data\") {\n    return null;\n  }\n  const input = serializeURL(urlRecord, true).substring(\"data:\".length);\n  let position = 0;\n  let mimeType = \"\";\n  while (position < input.length && input[position] !== \",\") {\n    mimeType += input[position];\n    ++position;\n  }\n  mimeType = stripLeadingAndTrailingASCIIWhitespace(mimeType);\n  if (position === input.length) {\n    return null;\n  }\n  ++position;\n  const encodedBody = input.substring(position);\n  let body = stringPercentDecode(encodedBody);\n\n  // Can't use /i regexp flag because it isn't restricted to ASCII.\n  const mimeTypeBase64MatchResult = /(.*); *[Bb][Aa][Ss][Ee]64$/.exec(mimeType);\n  if (mimeTypeBase64MatchResult) {\n    const stringBody = isomorphicDecode(body);\n    body = forgivingBase64Decode(stringBody);\n    if (body === null) {\n      return null;\n    }\n    mimeType = mimeTypeBase64MatchResult[1];\n  }\n  if (mimeType.startsWith(\";\")) {\n    mimeType = \"text/plain\" + mimeType;\n  }\n  let mimeTypeRecord;\n  try {\n    mimeTypeRecord = new MIMEType(mimeType);\n  } catch (e) {\n    mimeTypeRecord = new MIMEType(\"text/plain;charset=US-ASCII\");\n  }\n  return {\n    mimeType: mimeTypeRecord,\n    body\n  };\n};","map":{"version":3,"names":["MIMEType","require","parseURL","serializeURL","stripLeadingAndTrailingASCIIWhitespace","stringPercentDecode","isomorphicDecode","forgivingBase64Decode","module","exports","stringInput","urlRecord","fromURLRecord","scheme","input","substring","length","position","mimeType","encodedBody","body","mimeTypeBase64MatchResult","exec","stringBody","startsWith","mimeTypeRecord","e"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/data-urls/lib/parser.js"],"sourcesContent":["\"use strict\";\r\nconst MIMEType = require(\"whatwg-mimetype\");\r\nconst { parseURL, serializeURL } = require(\"whatwg-url\");\r\nconst {\r\n  stripLeadingAndTrailingASCIIWhitespace,\r\n  stringPercentDecode,\r\n  isomorphicDecode,\r\n  forgivingBase64Decode\r\n} = require(\"./utils.js\");\r\n\r\nmodule.exports = stringInput => {\r\n  const urlRecord = parseURL(stringInput);\r\n\r\n  if (urlRecord === null) {\r\n    return null;\r\n  }\r\n\r\n  return module.exports.fromURLRecord(urlRecord);\r\n};\r\n\r\nmodule.exports.fromURLRecord = urlRecord => {\r\n  if (urlRecord.scheme !== \"data\") {\r\n    return null;\r\n  }\r\n\r\n  const input = serializeURL(urlRecord, true).substring(\"data:\".length);\r\n\r\n  let position = 0;\r\n\r\n  let mimeType = \"\";\r\n  while (position < input.length && input[position] !== \",\") {\r\n    mimeType += input[position];\r\n    ++position;\r\n  }\r\n  mimeType = stripLeadingAndTrailingASCIIWhitespace(mimeType);\r\n\r\n  if (position === input.length) {\r\n    return null;\r\n  }\r\n\r\n  ++position;\r\n\r\n  const encodedBody = input.substring(position);\r\n\r\n  let body = stringPercentDecode(encodedBody);\r\n\r\n  // Can't use /i regexp flag because it isn't restricted to ASCII.\r\n  const mimeTypeBase64MatchResult = /(.*); *[Bb][Aa][Ss][Ee]64$/.exec(mimeType);\r\n  if (mimeTypeBase64MatchResult) {\r\n    const stringBody = isomorphicDecode(body);\r\n    body = forgivingBase64Decode(stringBody);\r\n\r\n    if (body === null) {\r\n      return null;\r\n    }\r\n    mimeType = mimeTypeBase64MatchResult[1];\r\n  }\r\n\r\n  if (mimeType.startsWith(\";\")) {\r\n    mimeType = \"text/plain\" + mimeType;\r\n  }\r\n\r\n  let mimeTypeRecord;\r\n  try {\r\n    mimeTypeRecord = new MIMEType(mimeType);\r\n  } catch (e) {\r\n    mimeTypeRecord = new MIMEType(\"text/plain;charset=US-ASCII\");\r\n  }\r\n\r\n  return {\r\n    mimeType: mimeTypeRecord,\r\n    body\r\n  };\r\n};\r\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,QAAQ,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAC3C,MAAM;EAAEC,QAAQ;EAAEC;AAAa,CAAC,GAAGF,OAAO,CAAC,YAAY,CAAC;AACxD,MAAM;EACJG,sCAAsC;EACtCC,mBAAmB;EACnBC,gBAAgB;EAChBC;AACF,CAAC,GAAGN,OAAO,CAAC,YAAY,CAAC;AAEzBO,MAAM,CAACC,OAAO,GAAGC,WAAW,IAAI;EAC9B,MAAMC,SAAS,GAAGT,QAAQ,CAACQ,WAAW,CAAC;EAEvC,IAAIC,SAAS,KAAK,IAAI,EAAE;IACtB,OAAO,IAAI;EACb;EAEA,OAAOH,MAAM,CAACC,OAAO,CAACG,aAAa,CAACD,SAAS,CAAC;AAChD,CAAC;AAEDH,MAAM,CAACC,OAAO,CAACG,aAAa,GAAGD,SAAS,IAAI;EAC1C,IAAIA,SAAS,CAACE,MAAM,KAAK,MAAM,EAAE;IAC/B,OAAO,IAAI;EACb;EAEA,MAAMC,KAAK,GAAGX,YAAY,CAACQ,SAAS,EAAE,IAAI,CAAC,CAACI,SAAS,CAAC,OAAO,CAACC,MAAM,CAAC;EAErE,IAAIC,QAAQ,GAAG,CAAC;EAEhB,IAAIC,QAAQ,GAAG,EAAE;EACjB,OAAOD,QAAQ,GAAGH,KAAK,CAACE,MAAM,IAAIF,KAAK,CAACG,QAAQ,CAAC,KAAK,GAAG,EAAE;IACzDC,QAAQ,IAAIJ,KAAK,CAACG,QAAQ,CAAC;IAC3B,EAAEA,QAAQ;EACZ;EACAC,QAAQ,GAAGd,sCAAsC,CAACc,QAAQ,CAAC;EAE3D,IAAID,QAAQ,KAAKH,KAAK,CAACE,MAAM,EAAE;IAC7B,OAAO,IAAI;EACb;EAEA,EAAEC,QAAQ;EAEV,MAAME,WAAW,GAAGL,KAAK,CAACC,SAAS,CAACE,QAAQ,CAAC;EAE7C,IAAIG,IAAI,GAAGf,mBAAmB,CAACc,WAAW,CAAC;;EAE3C;EACA,MAAME,yBAAyB,GAAG,4BAA4B,CAACC,IAAI,CAACJ,QAAQ,CAAC;EAC7E,IAAIG,yBAAyB,EAAE;IAC7B,MAAME,UAAU,GAAGjB,gBAAgB,CAACc,IAAI,CAAC;IACzCA,IAAI,GAAGb,qBAAqB,CAACgB,UAAU,CAAC;IAExC,IAAIH,IAAI,KAAK,IAAI,EAAE;MACjB,OAAO,IAAI;IACb;IACAF,QAAQ,GAAGG,yBAAyB,CAAC,CAAC,CAAC;EACzC;EAEA,IAAIH,QAAQ,CAACM,UAAU,CAAC,GAAG,CAAC,EAAE;IAC5BN,QAAQ,GAAG,YAAY,GAAGA,QAAQ;EACpC;EAEA,IAAIO,cAAc;EAClB,IAAI;IACFA,cAAc,GAAG,IAAIzB,QAAQ,CAACkB,QAAQ,CAAC;EACzC,CAAC,CAAC,OAAOQ,CAAC,EAAE;IACVD,cAAc,GAAG,IAAIzB,QAAQ,CAAC,6BAA6B,CAAC;EAC9D;EAEA,OAAO;IACLkB,QAAQ,EAAEO,cAAc;IACxBL;EACF,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}