{"ast":null,"code":"\"use strict\";\n\nconst path = require(\"path\");\nconst fs = require(\"fs\").promises;\nconst vm = require(\"vm\");\nconst toughCookie = require(\"tough-cookie\");\nconst sniffHTMLEncoding = require(\"html-encoding-sniffer\");\nconst whatwgURL = require(\"whatwg-url\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst {\n  URL\n} = require(\"whatwg-url\");\nconst MIMEType = require(\"whatwg-mimetype\");\nconst idlUtils = require(\"./jsdom/living/generated/utils.js\");\nconst VirtualConsole = require(\"./jsdom/virtual-console.js\");\nconst {\n  createWindow\n} = require(\"./jsdom/browser/Window.js\");\nconst {\n  parseIntoDocument\n} = require(\"./jsdom/browser/parser\");\nconst {\n  fragmentSerialization\n} = require(\"./jsdom/living/domparsing/serialization.js\");\nconst ResourceLoader = require(\"./jsdom/browser/resources/resource-loader.js\");\nconst NoOpResourceLoader = require(\"./jsdom/browser/resources/no-op-resource-loader.js\");\nclass CookieJar extends toughCookie.CookieJar {\n  constructor(store, options) {\n    // jsdom cookie jars must be loose by default\n    super(store, {\n      looseMode: true,\n      ...options\n    });\n  }\n}\nconst window = Symbol(\"window\");\nlet sharedFragmentDocument = null;\nclass JSDOM {\n  constructor() {\n    let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const mimeType = new MIMEType(options.contentType === undefined ? \"text/html\" : options.contentType);\n    const {\n      html,\n      encoding\n    } = normalizeHTML(input, mimeType);\n    options = transformOptions(options, encoding, mimeType);\n    this[window] = createWindow(options.windowOptions);\n    const documentImpl = idlUtils.implForWrapper(this[window]._document);\n    options.beforeParse(this[window]._globalProxy);\n    parseIntoDocument(html, documentImpl);\n    documentImpl.close();\n  }\n  get window() {\n    // It's important to grab the global proxy, instead of just the result of `createWindow(...)`, since otherwise\n    // things like `window.eval` don't exist.\n    return this[window]._globalProxy;\n  }\n  get virtualConsole() {\n    return this[window]._virtualConsole;\n  }\n  get cookieJar() {\n    // TODO NEWAPI move _cookieJar to window probably\n    return idlUtils.implForWrapper(this[window]._document)._cookieJar;\n  }\n  serialize() {\n    return fragmentSerialization(idlUtils.implForWrapper(this[window]._document), {\n      requireWellFormed: false\n    });\n  }\n  nodeLocation(node) {\n    if (!idlUtils.implForWrapper(this[window]._document)._parseOptions.sourceCodeLocationInfo) {\n      throw new Error(\"Location information was not saved for this jsdom. Use includeNodeLocations during creation.\");\n    }\n    return idlUtils.implForWrapper(node).sourceCodeLocation;\n  }\n  getInternalVMContext() {\n    if (!vm.isContext(this[window])) {\n      throw new TypeError(\"This jsdom was not configured to allow script running. \" + \"Use the runScripts option during creation.\");\n    }\n    return this[window];\n  }\n  reconfigure(settings) {\n    if (\"windowTop\" in settings) {\n      this[window]._top = settings.windowTop;\n    }\n    if (\"url\" in settings) {\n      const document = idlUtils.implForWrapper(this[window]._document);\n      const url = whatwgURL.parseURL(settings.url);\n      if (url === null) {\n        throw new TypeError(`Could not parse \"${settings.url}\" as a URL`);\n      }\n      document._URL = url;\n      document._origin = whatwgURL.serializeURLOrigin(document._URL);\n    }\n  }\n  static fragment() {\n    let string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    if (!sharedFragmentDocument) {\n      sharedFragmentDocument = new JSDOM().window.document;\n    }\n    const template = sharedFragmentDocument.createElement(\"template\");\n    template.innerHTML = string;\n    return template.content;\n  }\n  static fromURL(url) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Promise.resolve().then(() => {\n      // Remove the hash while sending this through the research loader fetch().\n      // It gets added back a few lines down when constructing the JSDOM object.\n      const parsedURL = new URL(url);\n      const originalHash = parsedURL.hash;\n      parsedURL.hash = \"\";\n      url = parsedURL.href;\n      options = normalizeFromURLOptions(options);\n      const resourceLoader = resourcesToResourceLoader(options.resources);\n      const resourceLoaderForInitialRequest = resourceLoader.constructor === NoOpResourceLoader ? new ResourceLoader() : resourceLoader;\n      const req = resourceLoaderForInitialRequest.fetch(url, {\n        accept: \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n        cookieJar: options.cookieJar,\n        referrer: options.referrer\n      });\n      return req.then(body => {\n        const res = req.response;\n        options = Object.assign(options, {\n          url: req.href + originalHash,\n          contentType: res.headers[\"content-type\"],\n          referrer: req.getHeader(\"referer\")\n        });\n        return new JSDOM(body, options);\n      });\n    });\n  }\n  static async fromFile(filename) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = normalizeFromFileOptions(filename, options);\n    const buffer = await fs.readFile(filename);\n    return new JSDOM(buffer, options);\n  }\n}\nfunction normalizeFromURLOptions(options) {\n  // Checks on options that are invalid for `fromURL`\n  if (options.url !== undefined) {\n    throw new TypeError(\"Cannot supply a url option when using fromURL\");\n  }\n  if (options.contentType !== undefined) {\n    throw new TypeError(\"Cannot supply a contentType option when using fromURL\");\n  }\n\n  // Normalization of options which must be done before the rest of the fromURL code can use them, because they are\n  // given to request()\n  const normalized = {\n    ...options\n  };\n  if (options.referrer !== undefined) {\n    normalized.referrer = new URL(options.referrer).href;\n  }\n  if (options.cookieJar === undefined) {\n    normalized.cookieJar = new CookieJar();\n  }\n  return normalized;\n\n  // All other options don't need to be processed yet, and can be taken care of in the normal course of things when\n  // `fromURL` calls `new JSDOM(html, options)`.\n}\n\nfunction normalizeFromFileOptions(filename, options) {\n  const normalized = {\n    ...options\n  };\n  if (normalized.contentType === undefined) {\n    const extname = path.extname(filename);\n    if (extname === \".xhtml\" || extname === \".xht\" || extname === \".xml\") {\n      normalized.contentType = \"application/xhtml+xml\";\n    }\n  }\n  if (normalized.url === undefined) {\n    normalized.url = new URL(\"file:\" + path.resolve(filename));\n  }\n  return normalized;\n}\nfunction transformOptions(options, encoding, mimeType) {\n  const transformed = {\n    windowOptions: {\n      // Defaults\n      url: \"about:blank\",\n      referrer: \"\",\n      contentType: \"text/html\",\n      parsingMode: \"html\",\n      parseOptions: {\n        sourceCodeLocationInfo: false,\n        scriptingEnabled: false\n      },\n      runScripts: undefined,\n      encoding,\n      pretendToBeVisual: false,\n      storageQuota: 5000000,\n      // Defaults filled in later\n      resourceLoader: undefined,\n      virtualConsole: undefined,\n      cookieJar: undefined\n    },\n    // Defaults\n    beforeParse() {}\n  };\n\n  // options.contentType was parsed into mimeType by the caller.\n  if (!mimeType.isHTML() && !mimeType.isXML()) {\n    throw new RangeError(`The given content type of \"${options.contentType}\" was not a HTML or XML content type`);\n  }\n  transformed.windowOptions.contentType = mimeType.essence;\n  transformed.windowOptions.parsingMode = mimeType.isHTML() ? \"html\" : \"xml\";\n  if (options.url !== undefined) {\n    transformed.windowOptions.url = new URL(options.url).href;\n  }\n  if (options.referrer !== undefined) {\n    transformed.windowOptions.referrer = new URL(options.referrer).href;\n  }\n  if (options.includeNodeLocations) {\n    if (transformed.windowOptions.parsingMode === \"xml\") {\n      throw new TypeError(\"Cannot set includeNodeLocations to true with an XML content type\");\n    }\n    transformed.windowOptions.parseOptions = {\n      sourceCodeLocationInfo: true\n    };\n  }\n  transformed.windowOptions.cookieJar = options.cookieJar === undefined ? new CookieJar() : options.cookieJar;\n  transformed.windowOptions.virtualConsole = options.virtualConsole === undefined ? new VirtualConsole().sendTo(console) : options.virtualConsole;\n  if (!(transformed.windowOptions.virtualConsole instanceof VirtualConsole)) {\n    throw new TypeError(\"virtualConsole must be an instance of VirtualConsole\");\n  }\n  transformed.windowOptions.resourceLoader = resourcesToResourceLoader(options.resources);\n  if (options.runScripts !== undefined) {\n    transformed.windowOptions.runScripts = String(options.runScripts);\n    if (transformed.windowOptions.runScripts === \"dangerously\") {\n      transformed.windowOptions.parseOptions.scriptingEnabled = true;\n    } else if (transformed.windowOptions.runScripts !== \"outside-only\") {\n      throw new RangeError(`runScripts must be undefined, \"dangerously\", or \"outside-only\"`);\n    }\n  }\n  if (options.beforeParse !== undefined) {\n    transformed.beforeParse = options.beforeParse;\n  }\n  if (options.pretendToBeVisual !== undefined) {\n    transformed.windowOptions.pretendToBeVisual = Boolean(options.pretendToBeVisual);\n  }\n  if (options.storageQuota !== undefined) {\n    transformed.windowOptions.storageQuota = Number(options.storageQuota);\n  }\n  return transformed;\n}\nfunction normalizeHTML(html, mimeType) {\n  let encoding = \"UTF-8\";\n  if (ArrayBuffer.isView(html)) {\n    html = Buffer.from(html.buffer, html.byteOffset, html.byteLength);\n  } else if (html instanceof ArrayBuffer) {\n    html = Buffer.from(html);\n  }\n  if (Buffer.isBuffer(html)) {\n    encoding = sniffHTMLEncoding(html, {\n      defaultEncoding: mimeType.isXML() ? \"UTF-8\" : \"windows-1252\",\n      transportLayerEncodingLabel: mimeType.parameters.get(\"charset\")\n    });\n    html = whatwgEncoding.decode(html, encoding);\n  } else {\n    html = String(html);\n  }\n  return {\n    html,\n    encoding\n  };\n}\nfunction resourcesToResourceLoader(resources) {\n  switch (resources) {\n    case undefined:\n      {\n        return new NoOpResourceLoader();\n      }\n    case \"usable\":\n      {\n        return new ResourceLoader();\n      }\n    default:\n      {\n        if (!(resources instanceof ResourceLoader)) {\n          throw new TypeError(\"resources must be an instance of ResourceLoader\");\n        }\n        return resources;\n      }\n  }\n}\nexports.JSDOM = JSDOM;\nexports.VirtualConsole = VirtualConsole;\nexports.CookieJar = CookieJar;\nexports.ResourceLoader = ResourceLoader;\nexports.toughCookie = toughCookie;","map":{"version":3,"names":["path","require","fs","promises","vm","toughCookie","sniffHTMLEncoding","whatwgURL","whatwgEncoding","URL","MIMEType","idlUtils","VirtualConsole","createWindow","parseIntoDocument","fragmentSerialization","ResourceLoader","NoOpResourceLoader","CookieJar","constructor","store","options","looseMode","window","Symbol","sharedFragmentDocument","JSDOM","input","arguments","length","undefined","mimeType","contentType","html","encoding","normalizeHTML","transformOptions","windowOptions","documentImpl","implForWrapper","_document","beforeParse","_globalProxy","close","virtualConsole","_virtualConsole","cookieJar","_cookieJar","serialize","requireWellFormed","nodeLocation","node","_parseOptions","sourceCodeLocationInfo","Error","sourceCodeLocation","getInternalVMContext","isContext","TypeError","reconfigure","settings","_top","windowTop","document","url","parseURL","_URL","_origin","serializeURLOrigin","fragment","string","template","createElement","innerHTML","content","fromURL","Promise","resolve","then","parsedURL","originalHash","hash","href","normalizeFromURLOptions","resourceLoader","resourcesToResourceLoader","resources","resourceLoaderForInitialRequest","req","fetch","accept","referrer","body","res","response","Object","assign","headers","getHeader","fromFile","filename","normalizeFromFileOptions","buffer","readFile","normalized","extname","transformed","parsingMode","parseOptions","scriptingEnabled","runScripts","pretendToBeVisual","storageQuota","isHTML","isXML","RangeError","essence","includeNodeLocations","sendTo","console","String","Boolean","Number","ArrayBuffer","isView","Buffer","from","byteOffset","byteLength","isBuffer","defaultEncoding","transportLayerEncodingLabel","parameters","get","decode","exports"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/api.js"],"sourcesContent":["\"use strict\";\r\nconst path = require(\"path\");\r\nconst fs = require(\"fs\").promises;\r\nconst vm = require(\"vm\");\r\nconst toughCookie = require(\"tough-cookie\");\r\nconst sniffHTMLEncoding = require(\"html-encoding-sniffer\");\r\nconst whatwgURL = require(\"whatwg-url\");\r\nconst whatwgEncoding = require(\"whatwg-encoding\");\r\nconst { URL } = require(\"whatwg-url\");\r\nconst MIMEType = require(\"whatwg-mimetype\");\r\nconst idlUtils = require(\"./jsdom/living/generated/utils.js\");\r\nconst VirtualConsole = require(\"./jsdom/virtual-console.js\");\r\nconst { createWindow } = require(\"./jsdom/browser/Window.js\");\r\nconst { parseIntoDocument } = require(\"./jsdom/browser/parser\");\r\nconst { fragmentSerialization } = require(\"./jsdom/living/domparsing/serialization.js\");\r\nconst ResourceLoader = require(\"./jsdom/browser/resources/resource-loader.js\");\r\nconst NoOpResourceLoader = require(\"./jsdom/browser/resources/no-op-resource-loader.js\");\r\n\r\nclass CookieJar extends toughCookie.CookieJar {\r\n  constructor(store, options) {\r\n    // jsdom cookie jars must be loose by default\r\n    super(store, { looseMode: true, ...options });\r\n  }\r\n}\r\n\r\nconst window = Symbol(\"window\");\r\nlet sharedFragmentDocument = null;\r\n\r\nclass JSDOM {\r\n  constructor(input = \"\", options = {}) {\r\n    const mimeType = new MIMEType(options.contentType === undefined ? \"text/html\" : options.contentType);\r\n    const { html, encoding } = normalizeHTML(input, mimeType);\r\n\r\n    options = transformOptions(options, encoding, mimeType);\r\n\r\n    this[window] = createWindow(options.windowOptions);\r\n\r\n    const documentImpl = idlUtils.implForWrapper(this[window]._document);\r\n\r\n    options.beforeParse(this[window]._globalProxy);\r\n\r\n    parseIntoDocument(html, documentImpl);\r\n\r\n    documentImpl.close();\r\n  }\r\n\r\n  get window() {\r\n    // It's important to grab the global proxy, instead of just the result of `createWindow(...)`, since otherwise\r\n    // things like `window.eval` don't exist.\r\n    return this[window]._globalProxy;\r\n  }\r\n\r\n  get virtualConsole() {\r\n    return this[window]._virtualConsole;\r\n  }\r\n\r\n  get cookieJar() {\r\n    // TODO NEWAPI move _cookieJar to window probably\r\n    return idlUtils.implForWrapper(this[window]._document)._cookieJar;\r\n  }\r\n\r\n  serialize() {\r\n    return fragmentSerialization(idlUtils.implForWrapper(this[window]._document), { requireWellFormed: false });\r\n  }\r\n\r\n  nodeLocation(node) {\r\n    if (!idlUtils.implForWrapper(this[window]._document)._parseOptions.sourceCodeLocationInfo) {\r\n      throw new Error(\"Location information was not saved for this jsdom. Use includeNodeLocations during creation.\");\r\n    }\r\n\r\n    return idlUtils.implForWrapper(node).sourceCodeLocation;\r\n  }\r\n\r\n  getInternalVMContext() {\r\n    if (!vm.isContext(this[window])) {\r\n      throw new TypeError(\"This jsdom was not configured to allow script running. \" +\r\n        \"Use the runScripts option during creation.\");\r\n    }\r\n\r\n    return this[window];\r\n  }\r\n\r\n  reconfigure(settings) {\r\n    if (\"windowTop\" in settings) {\r\n      this[window]._top = settings.windowTop;\r\n    }\r\n\r\n    if (\"url\" in settings) {\r\n      const document = idlUtils.implForWrapper(this[window]._document);\r\n\r\n      const url = whatwgURL.parseURL(settings.url);\r\n      if (url === null) {\r\n        throw new TypeError(`Could not parse \"${settings.url}\" as a URL`);\r\n      }\r\n\r\n      document._URL = url;\r\n      document._origin = whatwgURL.serializeURLOrigin(document._URL);\r\n    }\r\n  }\r\n\r\n  static fragment(string = \"\") {\r\n    if (!sharedFragmentDocument) {\r\n      sharedFragmentDocument = (new JSDOM()).window.document;\r\n    }\r\n\r\n    const template = sharedFragmentDocument.createElement(\"template\");\r\n    template.innerHTML = string;\r\n    return template.content;\r\n  }\r\n\r\n  static fromURL(url, options = {}) {\r\n    return Promise.resolve().then(() => {\r\n      // Remove the hash while sending this through the research loader fetch().\r\n      // It gets added back a few lines down when constructing the JSDOM object.\r\n      const parsedURL = new URL(url);\r\n      const originalHash = parsedURL.hash;\r\n      parsedURL.hash = \"\";\r\n      url = parsedURL.href;\r\n\r\n      options = normalizeFromURLOptions(options);\r\n\r\n      const resourceLoader = resourcesToResourceLoader(options.resources);\r\n      const resourceLoaderForInitialRequest = resourceLoader.constructor === NoOpResourceLoader ?\r\n        new ResourceLoader() :\r\n        resourceLoader;\r\n\r\n      const req = resourceLoaderForInitialRequest.fetch(url, {\r\n        accept: \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\r\n        cookieJar: options.cookieJar,\r\n        referrer: options.referrer\r\n      });\r\n\r\n      return req.then(body => {\r\n        const res = req.response;\r\n\r\n        options = Object.assign(options, {\r\n          url: req.href + originalHash,\r\n          contentType: res.headers[\"content-type\"],\r\n          referrer: req.getHeader(\"referer\")\r\n        });\r\n\r\n        return new JSDOM(body, options);\r\n      });\r\n    });\r\n  }\r\n\r\n  static async fromFile(filename, options = {}) {\r\n    options = normalizeFromFileOptions(filename, options);\r\n    const buffer = await fs.readFile(filename);\r\n\r\n    return new JSDOM(buffer, options);\r\n  }\r\n}\r\n\r\nfunction normalizeFromURLOptions(options) {\r\n  // Checks on options that are invalid for `fromURL`\r\n  if (options.url !== undefined) {\r\n    throw new TypeError(\"Cannot supply a url option when using fromURL\");\r\n  }\r\n  if (options.contentType !== undefined) {\r\n    throw new TypeError(\"Cannot supply a contentType option when using fromURL\");\r\n  }\r\n\r\n  // Normalization of options which must be done before the rest of the fromURL code can use them, because they are\r\n  // given to request()\r\n  const normalized = { ...options };\r\n\r\n  if (options.referrer !== undefined) {\r\n    normalized.referrer = (new URL(options.referrer)).href;\r\n  }\r\n\r\n  if (options.cookieJar === undefined) {\r\n    normalized.cookieJar = new CookieJar();\r\n  }\r\n\r\n  return normalized;\r\n\r\n  // All other options don't need to be processed yet, and can be taken care of in the normal course of things when\r\n  // `fromURL` calls `new JSDOM(html, options)`.\r\n}\r\n\r\nfunction normalizeFromFileOptions(filename, options) {\r\n  const normalized = { ...options };\r\n\r\n  if (normalized.contentType === undefined) {\r\n    const extname = path.extname(filename);\r\n    if (extname === \".xhtml\" || extname === \".xht\" || extname === \".xml\") {\r\n      normalized.contentType = \"application/xhtml+xml\";\r\n    }\r\n  }\r\n\r\n  if (normalized.url === undefined) {\r\n    normalized.url = new URL(\"file:\" + path.resolve(filename));\r\n  }\r\n\r\n  return normalized;\r\n}\r\n\r\nfunction transformOptions(options, encoding, mimeType) {\r\n  const transformed = {\r\n    windowOptions: {\r\n      // Defaults\r\n      url: \"about:blank\",\r\n      referrer: \"\",\r\n      contentType: \"text/html\",\r\n      parsingMode: \"html\",\r\n      parseOptions: {\r\n        sourceCodeLocationInfo: false,\r\n        scriptingEnabled: false\r\n      },\r\n      runScripts: undefined,\r\n      encoding,\r\n      pretendToBeVisual: false,\r\n      storageQuota: 5000000,\r\n\r\n      // Defaults filled in later\r\n      resourceLoader: undefined,\r\n      virtualConsole: undefined,\r\n      cookieJar: undefined\r\n    },\r\n\r\n    // Defaults\r\n    beforeParse() { }\r\n  };\r\n\r\n  // options.contentType was parsed into mimeType by the caller.\r\n  if (!mimeType.isHTML() && !mimeType.isXML()) {\r\n    throw new RangeError(`The given content type of \"${options.contentType}\" was not a HTML or XML content type`);\r\n  }\r\n\r\n  transformed.windowOptions.contentType = mimeType.essence;\r\n  transformed.windowOptions.parsingMode = mimeType.isHTML() ? \"html\" : \"xml\";\r\n\r\n  if (options.url !== undefined) {\r\n    transformed.windowOptions.url = (new URL(options.url)).href;\r\n  }\r\n\r\n  if (options.referrer !== undefined) {\r\n    transformed.windowOptions.referrer = (new URL(options.referrer)).href;\r\n  }\r\n\r\n  if (options.includeNodeLocations) {\r\n    if (transformed.windowOptions.parsingMode === \"xml\") {\r\n      throw new TypeError(\"Cannot set includeNodeLocations to true with an XML content type\");\r\n    }\r\n\r\n    transformed.windowOptions.parseOptions = { sourceCodeLocationInfo: true };\r\n  }\r\n\r\n  transformed.windowOptions.cookieJar = options.cookieJar === undefined ?\r\n                                       new CookieJar() :\r\n                                       options.cookieJar;\r\n\r\n  transformed.windowOptions.virtualConsole = options.virtualConsole === undefined ?\r\n                                            (new VirtualConsole()).sendTo(console) :\r\n                                            options.virtualConsole;\r\n\r\n  if (!(transformed.windowOptions.virtualConsole instanceof VirtualConsole)) {\r\n    throw new TypeError(\"virtualConsole must be an instance of VirtualConsole\");\r\n  }\r\n\r\n  transformed.windowOptions.resourceLoader = resourcesToResourceLoader(options.resources);\r\n\r\n  if (options.runScripts !== undefined) {\r\n    transformed.windowOptions.runScripts = String(options.runScripts);\r\n    if (transformed.windowOptions.runScripts === \"dangerously\") {\r\n      transformed.windowOptions.parseOptions.scriptingEnabled = true;\r\n    } else if (transformed.windowOptions.runScripts !== \"outside-only\") {\r\n      throw new RangeError(`runScripts must be undefined, \"dangerously\", or \"outside-only\"`);\r\n    }\r\n  }\r\n\r\n  if (options.beforeParse !== undefined) {\r\n    transformed.beforeParse = options.beforeParse;\r\n  }\r\n\r\n  if (options.pretendToBeVisual !== undefined) {\r\n    transformed.windowOptions.pretendToBeVisual = Boolean(options.pretendToBeVisual);\r\n  }\r\n\r\n  if (options.storageQuota !== undefined) {\r\n    transformed.windowOptions.storageQuota = Number(options.storageQuota);\r\n  }\r\n\r\n  return transformed;\r\n}\r\n\r\nfunction normalizeHTML(html, mimeType) {\r\n  let encoding = \"UTF-8\";\r\n\r\n  if (ArrayBuffer.isView(html)) {\r\n    html = Buffer.from(html.buffer, html.byteOffset, html.byteLength);\r\n  } else if (html instanceof ArrayBuffer) {\r\n    html = Buffer.from(html);\r\n  }\r\n\r\n  if (Buffer.isBuffer(html)) {\r\n    encoding = sniffHTMLEncoding(html, {\r\n      defaultEncoding: mimeType.isXML() ? \"UTF-8\" : \"windows-1252\",\r\n      transportLayerEncodingLabel: mimeType.parameters.get(\"charset\")\r\n    });\r\n    html = whatwgEncoding.decode(html, encoding);\r\n  } else {\r\n    html = String(html);\r\n  }\r\n\r\n  return { html, encoding };\r\n}\r\n\r\nfunction resourcesToResourceLoader(resources) {\r\n  switch (resources) {\r\n    case undefined: {\r\n      return new NoOpResourceLoader();\r\n    }\r\n    case \"usable\": {\r\n      return new ResourceLoader();\r\n    }\r\n    default: {\r\n      if (!(resources instanceof ResourceLoader)) {\r\n        throw new TypeError(\"resources must be an instance of ResourceLoader\");\r\n      }\r\n      return resources;\r\n    }\r\n  }\r\n}\r\n\r\nexports.JSDOM = JSDOM;\r\n\r\nexports.VirtualConsole = VirtualConsole;\r\nexports.CookieJar = CookieJar;\r\nexports.ResourceLoader = ResourceLoader;\r\n\r\nexports.toughCookie = toughCookie;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}