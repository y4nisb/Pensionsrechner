{"ast":null,"code":"\"use strict\";\n\nconst {\n  hasWeakRefs\n} = require(\"../../utils\");\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\nconst {\n  filter,\n  FILTER_ACCEPT\n} = require(\"./helpers\");\nexports.implementation = class NodeIteratorImpl {\n  constructor(globalObject, args, privateData) {\n    this._active = false;\n    this.root = privateData.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n    this._referenceNode = this.root;\n    this._pointerBeforeReferenceNode = true;\n\n    // This is used to deactivate the NodeIterator if there are too many working in a Document at the same time.\n    // Without weak references, a JS implementation of NodeIterator will leak, since we can't know when to clean it up.\n    // This ensures we force a clean up of those beyond some maximum (specified by the Document).\n    if (!hasWeakRefs) {\n      this._working = true;\n    }\n    this._globalObject = globalObject;\n  }\n  get referenceNode() {\n    this._throwIfNotWorking();\n    return this._referenceNode;\n  }\n  get pointerBeforeReferenceNode() {\n    this._throwIfNotWorking();\n    return this._pointerBeforeReferenceNode;\n  }\n  nextNode() {\n    this._throwIfNotWorking();\n    return this._traverse(\"next\");\n  }\n  previousNode() {\n    this._throwIfNotWorking();\n    return this._traverse(\"previous\");\n  }\n  detach() {\n    // Intentionally do nothing, per spec.\n  }\n\n  // Called by Documents.\n  _preRemovingSteps(toBeRemovedNode) {\n    // Second clause is https://github.com/whatwg/dom/issues/496\n    if (!toBeRemovedNode.contains(this._referenceNode) || toBeRemovedNode === this.root) {\n      return;\n    }\n    if (this._pointerBeforeReferenceNode) {\n      let next = null;\n      let candidateForNext = domSymbolTree.following(toBeRemovedNode, {\n        skipChildren: true\n      });\n      while (candidateForNext !== null) {\n        if (this.root.contains(candidateForNext)) {\n          next = candidateForNext;\n          break;\n        }\n        candidateForNext = domSymbolTree.following(candidateForNext, {\n          skipChildren: true\n        });\n      }\n      if (next !== null) {\n        this._referenceNode = next;\n        return;\n      }\n      this._pointerBeforeReferenceNode = false;\n    }\n    const {\n      previousSibling\n    } = toBeRemovedNode;\n    this._referenceNode = previousSibling === null ? toBeRemovedNode.parentNode : domSymbolTree.lastInclusiveDescendant(toBeRemovedNode.previousSibling);\n  }\n\n  // Only called by getters and methods that are affected by the pre-removing steps\n  _throwIfNotWorking() {\n    if (!hasWeakRefs && !this._working) {\n      throw Error(`This NodeIterator is no longer working. More than 10 iterators are being used concurrently. ` + `Using more than 10 node iterators requires WeakRef support.`);\n    }\n  }\n  _traverse(direction) {\n    let node = this._referenceNode;\n    let beforeNode = this._pointerBeforeReferenceNode;\n    while (true) {\n      if (direction === \"next\") {\n        if (!beforeNode) {\n          node = domSymbolTree.following(node, {\n            root: this.root\n          });\n          if (!node) {\n            return null;\n          }\n        }\n        beforeNode = false;\n      } else if (direction === \"previous\") {\n        if (beforeNode) {\n          node = domSymbolTree.preceding(node, {\n            root: this.root\n          });\n          if (!node) {\n            return null;\n          }\n        }\n        beforeNode = true;\n      }\n      const result = filter(this, node);\n      if (result === FILTER_ACCEPT) {\n        break;\n      }\n    }\n    this._referenceNode = node;\n    this._pointerBeforeReferenceNode = beforeNode;\n    return node;\n  }\n};","map":{"version":3,"names":["hasWeakRefs","require","domSymbolTree","filter","FILTER_ACCEPT","exports","implementation","NodeIteratorImpl","constructor","globalObject","args","privateData","_active","root","whatToShow","_referenceNode","_pointerBeforeReferenceNode","_working","_globalObject","referenceNode","_throwIfNotWorking","pointerBeforeReferenceNode","nextNode","_traverse","previousNode","detach","_preRemovingSteps","toBeRemovedNode","contains","next","candidateForNext","following","skipChildren","previousSibling","parentNode","lastInclusiveDescendant","Error","direction","node","beforeNode","preceding","result"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/jsdom/living/traversal/NodeIterator-impl.js"],"sourcesContent":["\"use strict\";\r\nconst { hasWeakRefs } = require(\"../../utils\");\r\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\r\nconst { filter, FILTER_ACCEPT } = require(\"./helpers\");\r\n\r\nexports.implementation = class NodeIteratorImpl {\r\n  constructor(globalObject, args, privateData) {\r\n    this._active = false;\r\n    this.root = privateData.root;\r\n    this.whatToShow = privateData.whatToShow;\r\n    this.filter = privateData.filter;\r\n\r\n    this._referenceNode = this.root;\r\n    this._pointerBeforeReferenceNode = true;\r\n\r\n    // This is used to deactivate the NodeIterator if there are too many working in a Document at the same time.\r\n    // Without weak references, a JS implementation of NodeIterator will leak, since we can't know when to clean it up.\r\n    // This ensures we force a clean up of those beyond some maximum (specified by the Document).\r\n    if (!hasWeakRefs) {\r\n      this._working = true;\r\n    }\r\n\r\n    this._globalObject = globalObject;\r\n  }\r\n\r\n  get referenceNode() {\r\n    this._throwIfNotWorking();\r\n    return this._referenceNode;\r\n  }\r\n\r\n  get pointerBeforeReferenceNode() {\r\n    this._throwIfNotWorking();\r\n    return this._pointerBeforeReferenceNode;\r\n  }\r\n\r\n  nextNode() {\r\n    this._throwIfNotWorking();\r\n    return this._traverse(\"next\");\r\n  }\r\n\r\n  previousNode() {\r\n    this._throwIfNotWorking();\r\n    return this._traverse(\"previous\");\r\n  }\r\n\r\n  detach() {\r\n    // Intentionally do nothing, per spec.\r\n  }\r\n\r\n  // Called by Documents.\r\n  _preRemovingSteps(toBeRemovedNode) {\r\n    // Second clause is https://github.com/whatwg/dom/issues/496\r\n    if (!toBeRemovedNode.contains(this._referenceNode) || toBeRemovedNode === this.root) {\r\n      return;\r\n    }\r\n\r\n    if (this._pointerBeforeReferenceNode) {\r\n      let next = null;\r\n      let candidateForNext = domSymbolTree.following(toBeRemovedNode, { skipChildren: true });\r\n      while (candidateForNext !== null) {\r\n        if (this.root.contains(candidateForNext)) {\r\n          next = candidateForNext;\r\n          break;\r\n        }\r\n        candidateForNext = domSymbolTree.following(candidateForNext, { skipChildren: true });\r\n      }\r\n\r\n      if (next !== null) {\r\n        this._referenceNode = next;\r\n        return;\r\n      }\r\n\r\n      this._pointerBeforeReferenceNode = false;\r\n    }\r\n\r\n    const { previousSibling } = toBeRemovedNode;\r\n    this._referenceNode = previousSibling === null ?\r\n                          toBeRemovedNode.parentNode :\r\n                          domSymbolTree.lastInclusiveDescendant(toBeRemovedNode.previousSibling);\r\n  }\r\n\r\n  // Only called by getters and methods that are affected by the pre-removing steps\r\n  _throwIfNotWorking() {\r\n    if (!hasWeakRefs && !this._working) {\r\n      throw Error(`This NodeIterator is no longer working. More than 10 iterators are being used concurrently. ` +\r\n        `Using more than 10 node iterators requires WeakRef support.`);\r\n    }\r\n  }\r\n\r\n  _traverse(direction) {\r\n    let node = this._referenceNode;\r\n    let beforeNode = this._pointerBeforeReferenceNode;\r\n\r\n    while (true) {\r\n      if (direction === \"next\") {\r\n        if (!beforeNode) {\r\n          node = domSymbolTree.following(node, { root: this.root });\r\n\r\n          if (!node) {\r\n            return null;\r\n          }\r\n        }\r\n\r\n        beforeNode = false;\r\n      } else if (direction === \"previous\") {\r\n        if (beforeNode) {\r\n          node = domSymbolTree.preceding(node, { root: this.root });\r\n\r\n          if (!node) {\r\n            return null;\r\n          }\r\n        }\r\n\r\n        beforeNode = true;\r\n      }\r\n\r\n      const result = filter(this, node);\r\n      if (result === FILTER_ACCEPT) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    this._referenceNode = node;\r\n    this._pointerBeforeReferenceNode = beforeNode;\r\n    return node;\r\n  }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}