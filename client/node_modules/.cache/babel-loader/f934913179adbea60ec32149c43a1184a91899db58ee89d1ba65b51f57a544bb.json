{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst ed5 = require(\"xmlchars/xml/1.0/ed5\");\nconst ed2 = require(\"xmlchars/xml/1.1/ed2\");\nconst NSed3 = require(\"xmlchars/xmlns/1.0/ed3\");\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  __proto__: null,\n  xml: XML_NAMESPACE,\n  xmlns: XMLNS_NAMESPACE\n};\nconst XML_ENTITIES = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  __proto__: null,\n  amp: \"&\",\n  gt: \">\",\n  lt: \"<\",\n  quot: \"\\\"\",\n  apos: \"'\"\n};\n// EOC: end-of-chunk\nconst EOC = -1;\nconst NL_LIKE = -2;\nconst S_BEGIN = 0; // Initial state.\nconst S_BEGIN_WHITESPACE = 1; // leading whitespace\nconst S_DOCTYPE = 2; // <!DOCTYPE\nconst S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\nconst S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\nconst S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\nconst S_DTD_OPEN_WAKA = 6;\nconst S_DTD_OPEN_WAKA_BANG = 7;\nconst S_DTD_COMMENT = 8; // <!--\nconst S_DTD_COMMENT_ENDING = 9; // <!-- blah -\nconst S_DTD_COMMENT_ENDED = 10; // <!-- blah --\nconst S_DTD_PI = 11; // <?\nconst S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\nconst S_TEXT = 13; // general stuff\nconst S_ENTITY = 14; // &amp and such\nconst S_OPEN_WAKA = 15; // <\nconst S_OPEN_WAKA_BANG = 16; // <!...\nconst S_COMMENT = 17; // <!--\nconst S_COMMENT_ENDING = 18; // <!-- blah -\nconst S_COMMENT_ENDED = 19; // <!-- blah --\nconst S_CDATA = 20; // <![CDATA[ something\nconst S_CDATA_ENDING = 21; // ]\nconst S_CDATA_ENDING_2 = 22; // ]]\nconst S_PI_FIRST_CHAR = 23; // <?hi, first char\nconst S_PI_REST = 24; // <?hi, rest of the name\nconst S_PI_BODY = 25; // <?hi there\nconst S_PI_ENDING = 26; // <?hi \"there\" ?\nconst S_XML_DECL_NAME_START = 27; // <?xml\nconst S_XML_DECL_NAME = 28; // <?xml foo\nconst S_XML_DECL_EQ = 29; // <?xml foo=\nconst S_XML_DECL_VALUE_START = 30; // <?xml foo=\nconst S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\nconst S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\nconst S_XML_DECL_ENDING = 33; // <?xml ... ?\nconst S_OPEN_TAG = 34; // <strong\nconst S_OPEN_TAG_SLASH = 35; // <strong /\nconst S_ATTRIB = 36; // <a\nconst S_ATTRIB_NAME = 37; // <a foo\nconst S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\nconst S_ATTRIB_VALUE = 39; // <a foo=\nconst S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\nconst S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\nconst S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\nconst S_CLOSE_TAG = 43; // </a\nconst S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\nconst TAB = 9;\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\nconst NEL = 0x85;\nconst LS = 0x2028; // Line Separator\nconst isQuote = c => c === DQUOTE || c === SQUOTE;\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\nfunction nsPairCheck(parser, prefix, uri) {\n  switch (prefix) {\n    case \"xml\":\n      if (uri !== XML_NAMESPACE) {\n        parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n      }\n      break;\n    case \"xmlns\":\n      if (uri !== XMLNS_NAMESPACE) {\n        parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n      }\n      break;\n    default:\n  }\n  switch (uri) {\n    case XMLNS_NAMESPACE:\n      parser.fail(prefix === \"\" ? `the default namespace may not be set to ${uri}.` : `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n      break;\n    case XML_NAMESPACE:\n      switch (prefix) {\n        case \"xml\":\n          // Assinging the XML namespace to \"xml\" is fine.\n          break;\n        case \"\":\n          parser.fail(`the default namespace may not be set to ${uri}.`);\n          break;\n        default:\n          parser.fail(\"may not assign the xml namespace to another prefix.\");\n      }\n      break;\n    default:\n  }\n}\nfunction nsMappingCheck(parser, mapping) {\n  for (const local of Object.keys(mapping)) {\n    nsPairCheck(parser, local, mapping[local]);\n  }\n}\nconst isNCName = name => NC_NAME_RE.test(name);\nconst isName = name => NAME_RE.test(name);\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\r\n * The list of supported events.\r\n */\nexports.EVENTS = [\"xmldecl\", \"text\", \"processinginstruction\", \"doctype\", \"comment\", \"opentagstart\", \"attribute\", \"opentag\", \"closetag\", \"cdata\", \"error\", \"end\", \"ready\"];\nconst EVENT_NAME_TO_HANDLER_NAME = {\n  xmldecl: \"xmldeclHandler\",\n  text: \"textHandler\",\n  processinginstruction: \"piHandler\",\n  doctype: \"doctypeHandler\",\n  comment: \"commentHandler\",\n  opentagstart: \"openTagStartHandler\",\n  attribute: \"attributeHandler\",\n  opentag: \"openTagHandler\",\n  closetag: \"closeTagHandler\",\n  cdata: \"cdataHandler\",\n  error: \"errorHandler\",\n  end: \"endHandler\",\n  ready: \"readyHandler\"\n};\nclass SaxesParser {\n  /**\r\n   * @param opt The parser options.\r\n   */\n  constructor(opt) {\n    this.opt = opt !== null && opt !== void 0 ? opt : {};\n    this.fragmentOpt = !!this.opt.fragment;\n    const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n    this.trackPosition = this.opt.position !== false;\n    this.fileName = this.opt.fileName;\n    if (xmlnsOpt) {\n      // This is the function we use to perform name checks on PIs and entities.\n      // When namespaces are used, colons are not allowed in PI target names or\n      // entity names. So the check depends on whether namespaces are used. See:\n      //\n      // https://www.w3.org/XML/xml-names-19990114-errata.html\n      // NE08\n      //\n      this.nameStartCheck = isNCNameStartChar;\n      this.nameCheck = isNCNameChar;\n      this.isName = isNCName;\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      this.processAttribs = this.processAttribsNS;\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      this.pushAttrib = this.pushAttribNS;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.ns = Object.assign({\n        __proto__: null\n      }, rootNS);\n      const additional = this.opt.additionalNamespaces;\n      if (additional != null) {\n        nsMappingCheck(this, additional);\n        Object.assign(this.ns, additional);\n      }\n    } else {\n      this.nameStartCheck = isNameStartChar;\n      this.nameCheck = isNameChar;\n      this.isName = isName;\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      this.processAttribs = this.processAttribsPlain;\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      this.pushAttrib = this.pushAttribPlain;\n    }\n    //\n    // The order of the members in this table needs to correspond to the state\n    // numbers given to the states that correspond to the methods being recorded\n    // here.\n    //\n    this.stateTable = [/* eslint-disable @typescript-eslint/unbound-method */\n    this.sBegin, this.sBeginWhitespace, this.sDoctype, this.sDoctypeQuote, this.sDTD, this.sDTDQuoted, this.sDTDOpenWaka, this.sDTDOpenWakaBang, this.sDTDComment, this.sDTDCommentEnding, this.sDTDCommentEnded, this.sDTDPI, this.sDTDPIEnding, this.sText, this.sEntity, this.sOpenWaka, this.sOpenWakaBang, this.sComment, this.sCommentEnding, this.sCommentEnded, this.sCData, this.sCDataEnding, this.sCDataEnding2, this.sPIFirstChar, this.sPIRest, this.sPIBody, this.sPIEnding, this.sXMLDeclNameStart, this.sXMLDeclName, this.sXMLDeclEq, this.sXMLDeclValueStart, this.sXMLDeclValue, this.sXMLDeclSeparator, this.sXMLDeclEnding, this.sOpenTag, this.sOpenTagSlash, this.sAttrib, this.sAttribName, this.sAttribNameSawWhite, this.sAttribValue, this.sAttribValueQuoted, this.sAttribValueClosed, this.sAttribValueUnquoted, this.sCloseTag, this.sCloseTagSawWhite];\n    this._init();\n  }\n  /**\r\n   * Indicates whether or not the parser is closed. If ``true``, wait for\r\n   * the ``ready`` event to write again.\r\n   */\n  get closed() {\n    return this._closed;\n  }\n  _init() {\n    var _a;\n    this.openWakaBang = \"\";\n    this.text = \"\";\n    this.name = \"\";\n    this.piTarget = \"\";\n    this.entity = \"\";\n    this.q = null;\n    this.tags = [];\n    this.tag = null;\n    this.topNS = null;\n    this.chunk = \"\";\n    this.chunkPosition = 0;\n    this.i = 0;\n    this.prevI = 0;\n    this.carriedFromPrevious = undefined;\n    this.forbiddenState = FORBIDDEN_START;\n    this.attribList = [];\n    // The logic is organized so as to minimize the need to check\n    // this.opt.fragment while parsing.\n    const {\n      fragmentOpt\n    } = this;\n    this.state = fragmentOpt ? S_TEXT : S_BEGIN;\n    // We want these to be all true if we are dealing with a fragment.\n    this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt;\n    // An XML declaration is intially possible only when parsing whole\n    // documents.\n    this.xmlDeclPossible = !fragmentOpt;\n    this.xmlDeclExpects = [\"version\"];\n    this.entityReturnState = undefined;\n    let {\n      defaultXMLVersion\n    } = this.opt;\n    if (defaultXMLVersion === undefined) {\n      if (this.opt.forceXMLVersion === true) {\n        throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n      }\n      defaultXMLVersion = \"1.0\";\n    }\n    this.setXMLVersion(defaultXMLVersion);\n    this.positionAtNewLine = 0;\n    this.doctype = false;\n    this._closed = false;\n    this.xmlDecl = {\n      version: undefined,\n      encoding: undefined,\n      standalone: undefined\n    };\n    this.line = 1;\n    this.column = 0;\n    this.ENTITIES = Object.create(XML_ENTITIES);\n    // eslint-disable-next-line no-unused-expressions\n    (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n  }\n  /**\r\n   * The stream position the parser is currently looking at. This field is\r\n   * zero-based.\r\n   *\r\n   * This field is not based on counting Unicode characters but is to be\r\n   * interpreted as a plain index into a JavaScript string.\r\n   */\n  get position() {\n    return this.chunkPosition + this.i;\n  }\n  /**\r\n   * The column number of the next character to be read by the parser.  *\r\n   * This field is zero-based. (The first column in a line is 0.)\r\n   *\r\n   * This field reports the index at which the next character would be in the\r\n   * line if the line were represented as a JavaScript string.  Note that this\r\n   * *can* be different to a count based on the number of *Unicode characters*\r\n   * due to how JavaScript handles astral plane characters.\r\n   *\r\n   * See [[column]] for a number that corresponds to a count of Unicode\r\n   * characters.\r\n   */\n  get columnIndex() {\n    return this.position - this.positionAtNewLine;\n  }\n  /**\r\n   * Set an event listener on an event. The parser supports one handler per\r\n   * event type. If you try to set an event handler over an existing handler,\r\n   * the old handler is silently overwritten.\r\n   *\r\n   * @param name The event to listen to.\r\n   *\r\n   * @param handler The handler to set.\r\n   */\n  on(name, handler) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n  }\n  /**\r\n   * Unset an event handler.\r\n   *\r\n   * @parma name The event to stop listening to.\r\n   */\n  off(name) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n  }\n  /**\r\n   * Make an error object. The error object will have a message that contains\r\n   * the ``fileName`` option passed at the creation of the parser. If position\r\n   * tracking was turned on, it will also have line and column number\r\n   * information.\r\n   *\r\n   * @param message The message describing the error to report.\r\n   *\r\n   * @returns An error object with a properly formatted message.\r\n   */\n  makeError(message) {\n    var _a;\n    let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n    if (this.trackPosition) {\n      if (msg.length > 0) {\n        msg += \":\";\n      }\n      msg += `${this.line}:${this.column}`;\n    }\n    if (msg.length > 0) {\n      msg += \": \";\n    }\n    return new Error(msg + message);\n  }\n  /**\r\n   * Report a parsing error. This method is made public so that client code may\r\n   * check for issues that are outside the scope of this project and can report\r\n   * errors.\r\n   *\r\n   * @param message The error to report.\r\n   *\r\n   * @returns this\r\n   */\n  fail(message) {\n    const err = this.makeError(message);\n    const handler = this.errorHandler;\n    if (handler === undefined) {\n      throw err;\n    } else {\n      handler(err);\n    }\n    return this;\n  }\n  /**\r\n   * Write a XML data to the parser.\r\n   *\r\n   * @param chunk The XML data to write.\r\n   *\r\n   * @returns this\r\n   */\n  write(chunk) {\n    if (this.closed) {\n      return this.fail(\"cannot write after close; assign an onready handler.\");\n    }\n    let end = false;\n    if (chunk === null) {\n      // We cannot return immediately because carriedFromPrevious may need\n      // processing.\n      end = true;\n      chunk = \"\";\n    } else if (typeof chunk === \"object\") {\n      chunk = chunk.toString();\n    }\n    // We checked if performing a pre-decomposition of the string into an array\n    // of single complete characters (``Array.from(chunk)``) would be faster\n    // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n    // isn't. (There may be Node-specific code that would perform faster than\n    // ``Array.from`` but don't want to be dependent on Node.)\n    if (this.carriedFromPrevious !== undefined) {\n      // The previous chunk had char we must carry over.\n      chunk = `${this.carriedFromPrevious}${chunk}`;\n      this.carriedFromPrevious = undefined;\n    }\n    let limit = chunk.length;\n    const lastCode = chunk.charCodeAt(limit - 1);\n    if (!end && (\n    // A trailing CR or surrogate must be carried over to the next\n    // chunk.\n    lastCode === CR || lastCode >= 0xD800 && lastCode <= 0xDBFF)) {\n      // The chunk ends with a character that must be carried over. We cannot\n      // know how to handle it until we get the next chunk or the end of the\n      // stream. So save it for later.\n      this.carriedFromPrevious = chunk[limit - 1];\n      limit--;\n      chunk = chunk.slice(0, limit);\n    }\n    const {\n      stateTable\n    } = this;\n    this.chunk = chunk;\n    this.i = 0;\n    while (this.i < limit) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      stateTable[this.state].call(this);\n    }\n    this.chunkPosition += limit;\n    return end ? this.end() : this;\n  }\n  /**\r\n   * Close the current stream. Perform final well-formedness checks and reset\r\n   * the parser tstate.\r\n   *\r\n   * @returns this\r\n   */\n  close() {\n    return this.write(null);\n  }\n  /**\r\n   * Get a single code point out of the current chunk. This updates the current\r\n   * position if we do position tracking.\r\n   *\r\n   * This is the algorithm to use for XML 1.0.\r\n   *\r\n   * @returns The character read.\r\n   */\n  getCode10() {\n    const {\n      chunk,\n      i\n    } = this;\n    this.prevI = i;\n    // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n    // read this.i again, which is a bit faster.\n    this.i = i + 1;\n    if (i >= chunk.length) {\n      return EOC;\n    }\n    // Using charCodeAt and handling the surrogates ourselves is faster\n    // than using codePointAt.\n    const code = chunk.charCodeAt(i);\n    this.column++;\n    if (code < 0xD800) {\n      if (code >= SPACE || code === TAB) {\n        return code;\n      }\n      switch (code) {\n        case NL:\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL;\n        case CR:\n          // We may get NaN if we read past the end of the chunk, which is fine.\n          if (chunk.charCodeAt(i + 1) === NL) {\n            // A \\r\\n sequence is converted to \\n so we have to skip over the\n            // next character. We already know it has a size of 1 so ++ is fine\n            // here.\n            this.i = i + 2;\n          }\n          // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n          // ahead.\n          // In either case, \\r becomes \\n.\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL_LIKE;\n        default:\n          // If we get here, then code < SPACE and it is not NL CR or TAB.\n          this.fail(\"disallowed character.\");\n          return code;\n      }\n    }\n    if (code > 0xDBFF) {\n      // This is a specialized version of isChar10 that takes into account\n      // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n      // test cases that don't need testing.\n      if (!(code >= 0xE000 && code <= 0xFFFD)) {\n        this.fail(\"disallowed character.\");\n      }\n      return code;\n    }\n    const final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n    this.i = i + 2;\n    // This is a specialized version of isChar10 that takes into account that in\n    // this context necessarily final >= 0x10000.\n    if (final > 0x10FFFF) {\n      this.fail(\"disallowed character.\");\n    }\n    return final;\n  }\n  /**\r\n   * Get a single code point out of the current chunk. This updates the current\r\n   * position if we do position tracking.\r\n   *\r\n   * This is the algorithm to use for XML 1.1.\r\n   *\r\n   * @returns {number} The character read.\r\n   */\n  getCode11() {\n    const {\n      chunk,\n      i\n    } = this;\n    this.prevI = i;\n    // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n    // read this.i again, which is a bit faster.\n    this.i = i + 1;\n    if (i >= chunk.length) {\n      return EOC;\n    }\n    // Using charCodeAt and handling the surrogates ourselves is faster\n    // than using codePointAt.\n    const code = chunk.charCodeAt(i);\n    this.column++;\n    if (code < 0xD800) {\n      if (code > 0x1F && code < 0x7F || code > 0x9F && code !== LS || code === TAB) {\n        return code;\n      }\n      switch (code) {\n        case NL:\n          // 0xA\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL;\n        case CR:\n          {\n            // 0xD\n            // We may get NaN if we read past the end of the chunk, which is\n            // fine.\n            const next = chunk.charCodeAt(i + 1);\n            if (next === NL || next === NEL) {\n              // A CR NL or CR NEL sequence is converted to NL so we have to skip\n              // over the next character. We already know it has a size of 1.\n              this.i = i + 2;\n            }\n            // Otherwise, a CR is just converted to NL, no skip.\n          }\n        /* yes, fall through */\n        case NEL: // 0x85\n        case LS:\n          // Ox2028\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL_LIKE;\n        default:\n          this.fail(\"disallowed character.\");\n          return code;\n      }\n    }\n    if (code > 0xDBFF) {\n      // This is a specialized version of isCharAndNotRestricted that takes into\n      // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n      // does not test cases that don't need testing.\n      if (!(code >= 0xE000 && code <= 0xFFFD)) {\n        this.fail(\"disallowed character.\");\n      }\n      return code;\n    }\n    const final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n    this.i = i + 2;\n    // This is a specialized version of isCharAndNotRestricted that takes into\n    // account that in this context necessarily final >= 0x10000.\n    if (final > 0x10FFFF) {\n      this.fail(\"disallowed character.\");\n    }\n    return final;\n  }\n  /**\r\n   * Like ``getCode`` but with the return value normalized so that ``NL`` is\r\n   * returned for ``NL_LIKE``.\r\n   */\n  getCodeNorm() {\n    const c = this.getCode();\n    return c === NL_LIKE ? NL : c;\n  }\n  unget() {\n    this.i = this.prevI;\n    this.column--;\n  }\n  /**\r\n   * Capture characters into a buffer until encountering one of a set of\r\n   * characters.\r\n   *\r\n   * @param chars An array of codepoints. Encountering a character in the array\r\n   * ends the capture. (``chars`` may safely contain ``NL``.)\r\n   *\r\n   * @return The character code that made the capture end, or ``EOC`` if we hit\r\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\r\n   * instead.\r\n   */\n  captureTo(chars) {\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const c = this.getCode();\n      const isNLLike = c === NL_LIKE;\n      const final = isNLLike ? NL : c;\n      if (final === EOC || chars.includes(final)) {\n        this.text += chunk.slice(start, this.prevI);\n        return final;\n      }\n      if (isNLLike) {\n        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n        start = this.i;\n      }\n    }\n  }\n  /**\r\n   * Capture characters into a buffer until encountering a character.\r\n   *\r\n   * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\r\n   * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\r\n   *\r\n   * @return ``true`` if we ran into the character. Otherwise, we ran into the\r\n   * end of the current chunk.\r\n   */\n  captureToChar(char) {\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let c = this.getCode();\n      switch (c) {\n        case NL_LIKE:\n          this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          start = this.i;\n          c = NL;\n          break;\n        case EOC:\n          this.text += chunk.slice(start);\n          return false;\n        default:\n      }\n      if (c === char) {\n        this.text += chunk.slice(start, this.prevI);\n        return true;\n      }\n    }\n  }\n  /**\r\n   * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\r\n   * this parser.\r\n   *\r\n   * @return The character code that made the test fail, or ``EOC`` if we hit\r\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\r\n   * instead.\r\n   */\n  captureNameChars() {\n    const {\n      chunk,\n      i: start\n    } = this;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const c = this.getCode();\n      if (c === EOC) {\n        this.name += chunk.slice(start);\n        return EOC;\n      }\n      // NL is not a name char so we don't have to test specifically for it.\n      if (!isNameChar(c)) {\n        this.name += chunk.slice(start, this.prevI);\n        return c === NL_LIKE ? NL : c;\n      }\n    }\n  }\n  /**\r\n   * Skip white spaces.\r\n   *\r\n   * @return The character that ended the skip, or ``EOC`` if we hit\r\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\r\n   * instead.\r\n   */\n  skipSpaces() {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const c = this.getCodeNorm();\n      if (c === EOC || !isS(c)) {\n        return c;\n      }\n    }\n  }\n  setXMLVersion(version) {\n    this.currentXMLVersion = version;\n    /*  eslint-disable @typescript-eslint/unbound-method */\n    if (version === \"1.0\") {\n      this.isChar = isChar10;\n      this.getCode = this.getCode10;\n    } else {\n      this.isChar = isChar11;\n      this.getCode = this.getCode11;\n    }\n    /* eslint-enable @typescript-eslint/unbound-method */\n  }\n  // STATE ENGINE METHODS\n  // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n  // to be sure never to come back to this state later.\n  sBegin() {\n    // We are essentially peeking at the first character of the chunk. Since\n    // S_BEGIN can be in effect only when we start working on the first chunk,\n    // the index at which we must look is necessarily 0. Note also that the\n    // following test does not depend on decoding surrogates.\n    // If the initial character is 0xFEFF, ignore it.\n    if (this.chunk.charCodeAt(0) === 0xFEFF) {\n      this.i++;\n      this.column++;\n    }\n    this.state = S_BEGIN_WHITESPACE;\n  }\n  sBeginWhitespace() {\n    // We need to know whether we've encountered spaces or not because as soon\n    // as we run into a space, an XML declaration is no longer possible. Rather\n    // than slow down skipSpaces even in places where we don't care whether it\n    // skipped anything or not, we check whether prevI is equal to the value of\n    // i from before we skip spaces.\n    const iBefore = this.i;\n    const c = this.skipSpaces();\n    if (this.prevI !== iBefore) {\n      this.xmlDeclPossible = false;\n    }\n    switch (c) {\n      case LESS:\n        this.state = S_OPEN_WAKA;\n        // We could naively call closeText but in this state, it is not normal\n        // to have text be filled with any data.\n        if (this.text.length !== 0) {\n          throw new Error(\"no-empty text at start\");\n        }\n        break;\n      case EOC:\n        break;\n      default:\n        this.unget();\n        this.state = S_TEXT;\n        this.xmlDeclPossible = false;\n    }\n  }\n  sDoctype() {\n    var _a;\n    const c = this.captureTo(DOCTYPE_TERMINATOR);\n    switch (c) {\n      case GREATER:\n        {\n          // eslint-disable-next-line no-unused-expressions\n          (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n          this.text = \"\";\n          this.state = S_TEXT;\n          this.doctype = true; // just remember that we saw it.\n          break;\n        }\n      case EOC:\n        break;\n      default:\n        this.text += String.fromCodePoint(c);\n        if (c === OPEN_BRACKET) {\n          this.state = S_DTD;\n        } else if (isQuote(c)) {\n          this.state = S_DOCTYPE_QUOTE;\n          this.q = c;\n        }\n    }\n  }\n  sDoctypeQuote() {\n    const q = this.q;\n    if (this.captureToChar(q)) {\n      this.text += String.fromCodePoint(q);\n      this.q = null;\n      this.state = S_DOCTYPE;\n    }\n  }\n  sDTD() {\n    const c = this.captureTo(DTD_TERMINATOR);\n    if (c === EOC) {\n      return;\n    }\n    this.text += String.fromCodePoint(c);\n    if (c === CLOSE_BRACKET) {\n      this.state = S_DOCTYPE;\n    } else if (c === LESS) {\n      this.state = S_DTD_OPEN_WAKA;\n    } else if (isQuote(c)) {\n      this.state = S_DTD_QUOTED;\n      this.q = c;\n    }\n  }\n  sDTDQuoted() {\n    const q = this.q;\n    if (this.captureToChar(q)) {\n      this.text += String.fromCodePoint(q);\n      this.state = S_DTD;\n      this.q = null;\n    }\n  }\n  sDTDOpenWaka() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n    switch (c) {\n      case BANG:\n        this.state = S_DTD_OPEN_WAKA_BANG;\n        this.openWakaBang = \"\";\n        break;\n      case QUESTION:\n        this.state = S_DTD_PI;\n        break;\n      default:\n        this.state = S_DTD;\n    }\n  }\n  sDTDOpenWakaBang() {\n    const char = String.fromCodePoint(this.getCodeNorm());\n    const owb = this.openWakaBang += char;\n    this.text += char;\n    if (owb !== \"-\") {\n      this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n      this.openWakaBang = \"\";\n    }\n  }\n  sDTDComment() {\n    if (this.captureToChar(MINUS)) {\n      this.text += \"-\";\n      this.state = S_DTD_COMMENT_ENDING;\n    }\n  }\n  sDTDCommentEnding() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n    this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n  }\n  sDTDCommentEnded() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n    if (c === GREATER) {\n      this.state = S_DTD;\n    } else {\n      this.fail(\"malformed comment.\");\n      // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n      this.state = S_DTD_COMMENT;\n    }\n  }\n  sDTDPI() {\n    if (this.captureToChar(QUESTION)) {\n      this.text += \"?\";\n      this.state = S_DTD_PI_ENDING;\n    }\n  }\n  sDTDPIEnding() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n    if (c === GREATER) {\n      this.state = S_DTD;\n    }\n  }\n  sText() {\n    //\n    // We did try a version of saxes where the S_TEXT state was split in two\n    // states: one for text inside the root element, and one for text\n    // outside. This was avoiding having to test this.tags.length to decide\n    // what implementation to actually use.\n    //\n    // Peformance testing on gigabyte-size files did not show any advantage to\n    // using the two states solution instead of the current one. Conversely, it\n    // made the code a bit more complicated elsewhere. For instance, a comment\n    // can appear before the root element so when a comment ended it was\n    // necessary to determine whether to return to the S_TEXT state or to the\n    // new text-outside-root state.\n    //\n    if (this.tags.length !== 0) {\n      this.handleTextInRoot();\n    } else {\n      this.handleTextOutsideRoot();\n    }\n  }\n  sEntity() {\n    // This is essentially a specialized version of captureToChar(SEMICOLON...)\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this;\n    // eslint-disable-next-line no-labels, no-restricted-syntax\n    loop:\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      switch (this.getCode()) {\n        case NL_LIKE:\n          this.entity += `${chunk.slice(start, this.prevI)}\\n`;\n          start = this.i;\n          break;\n        case SEMICOLON:\n          {\n            const {\n              entityReturnState\n            } = this;\n            const entity = this.entity + chunk.slice(start, this.prevI);\n            this.state = entityReturnState;\n            let parsed;\n            if (entity === \"\") {\n              this.fail(\"empty entity name.\");\n              parsed = \"&;\";\n            } else {\n              parsed = this.parseEntity(entity);\n              this.entity = \"\";\n            }\n            if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n              this.text += parsed;\n            }\n            // eslint-disable-next-line no-labels\n            break loop;\n          }\n        case EOC:\n          this.entity += chunk.slice(start);\n          // eslint-disable-next-line no-labels\n          break loop;\n        default:\n      }\n    }\n  }\n  sOpenWaka() {\n    // Reminder: a state handler is called with at least one character\n    // available in the current chunk. So the first call to get code inside of\n    // a state handler cannot return ``EOC``. That's why we don't test\n    // for it.\n    const c = this.getCode();\n    // either a /, ?, !, or text is coming next.\n    if (isNameStartChar(c)) {\n      this.state = S_OPEN_TAG;\n      this.unget();\n      this.xmlDeclPossible = false;\n    } else {\n      switch (c) {\n        case FORWARD_SLASH:\n          this.state = S_CLOSE_TAG;\n          this.xmlDeclPossible = false;\n          break;\n        case BANG:\n          this.state = S_OPEN_WAKA_BANG;\n          this.openWakaBang = \"\";\n          this.xmlDeclPossible = false;\n          break;\n        case QUESTION:\n          this.state = S_PI_FIRST_CHAR;\n          break;\n        default:\n          this.fail(\"disallowed character in tag name\");\n          this.state = S_TEXT;\n          this.xmlDeclPossible = false;\n      }\n    }\n  }\n  sOpenWakaBang() {\n    this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n    switch (this.openWakaBang) {\n      case \"[CDATA[\":\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextBeforeRoot = true;\n        }\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextAfterRoot = true;\n        }\n        this.state = S_CDATA;\n        this.openWakaBang = \"\";\n        break;\n      case \"--\":\n        this.state = S_COMMENT;\n        this.openWakaBang = \"\";\n        break;\n      case \"DOCTYPE\":\n        this.state = S_DOCTYPE;\n        if (this.doctype || this.sawRoot) {\n          this.fail(\"inappropriately located doctype declaration.\");\n        }\n        this.openWakaBang = \"\";\n        break;\n      default:\n        // 7 happens to be the maximum length of the string that can possibly\n        // match one of the cases above.\n        if (this.openWakaBang.length >= 7) {\n          this.fail(\"incorrect syntax.\");\n        }\n    }\n  }\n  sComment() {\n    if (this.captureToChar(MINUS)) {\n      this.state = S_COMMENT_ENDING;\n    }\n  }\n  sCommentEnding() {\n    var _a;\n    const c = this.getCodeNorm();\n    if (c === MINUS) {\n      this.state = S_COMMENT_ENDED;\n      // eslint-disable-next-line no-unused-expressions\n      (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n      this.text = \"\";\n    } else {\n      this.text += `-${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    }\n  }\n  sCommentEnded() {\n    const c = this.getCodeNorm();\n    if (c !== GREATER) {\n      this.fail(\"malformed comment.\");\n      // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n      this.text += `--${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    } else {\n      this.state = S_TEXT;\n    }\n  }\n  sCData() {\n    if (this.captureToChar(CLOSE_BRACKET)) {\n      this.state = S_CDATA_ENDING;\n    }\n  }\n  sCDataEnding() {\n    const c = this.getCodeNorm();\n    if (c === CLOSE_BRACKET) {\n      this.state = S_CDATA_ENDING_2;\n    } else {\n      this.text += `]${String.fromCodePoint(c)}`;\n      this.state = S_CDATA;\n    }\n  }\n  sCDataEnding2() {\n    var _a;\n    const c = this.getCodeNorm();\n    switch (c) {\n      case GREATER:\n        {\n          // eslint-disable-next-line no-unused-expressions\n          (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n          this.text = \"\";\n          this.state = S_TEXT;\n          break;\n        }\n      case CLOSE_BRACKET:\n        this.text += \"]\";\n        break;\n      default:\n        this.text += `]]${String.fromCodePoint(c)}`;\n        this.state = S_CDATA;\n    }\n  }\n  // We need this separate state to check the first character fo the pi target\n  // with this.nameStartCheck which allows less characters than this.nameCheck.\n  sPIFirstChar() {\n    const c = this.getCodeNorm();\n    // This is first because in the case where the file is well-formed this is\n    // the branch taken. We optimize for well-formedness.\n    if (this.nameStartCheck(c)) {\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    } else if (c === QUESTION || isS(c)) {\n      this.fail(\"processing instruction without a target.\");\n      this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n    } else {\n      this.fail(\"disallowed character in processing instruction name.\");\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    }\n  }\n  sPIRest() {\n    // Capture characters into a piTarget while ``this.nameCheck`` run on the\n    // character read returns true.\n    const {\n      chunk,\n      i: start\n    } = this;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const c = this.getCodeNorm();\n      if (c === EOC) {\n        this.piTarget += chunk.slice(start);\n        return;\n      }\n      // NL cannot satisfy this.nameCheck so we don't have to test specifically\n      // for it.\n      if (!this.nameCheck(c)) {\n        this.piTarget += chunk.slice(start, this.prevI);\n        const isQuestion = c === QUESTION;\n        if (isQuestion || isS(c)) {\n          if (this.piTarget === \"xml\") {\n            if (!this.xmlDeclPossible) {\n              this.fail(\"an XML declaration must be at the start of the document.\");\n            }\n            this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n          } else {\n            this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n          }\n        } else {\n          this.fail(\"disallowed character in processing instruction name.\");\n          this.piTarget += String.fromCodePoint(c);\n        }\n        break;\n      }\n    }\n  }\n  sPIBody() {\n    if (this.text.length === 0) {\n      const c = this.getCodeNorm();\n      if (c === QUESTION) {\n        this.state = S_PI_ENDING;\n      } else if (!isS(c)) {\n        this.text = String.fromCodePoint(c);\n      }\n    }\n    // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    else if (this.captureToChar(QUESTION)) {\n      this.state = S_PI_ENDING;\n    }\n  }\n  sPIEnding() {\n    var _a;\n    const c = this.getCodeNorm();\n    if (c === GREATER) {\n      const {\n        piTarget\n      } = this;\n      if (piTarget.toLowerCase() === \"xml\") {\n        this.fail(\"the XML declaration must appear at the start of the document.\");\n      }\n      // eslint-disable-next-line no-unused-expressions\n      (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n        target: piTarget,\n        body: this.text\n      });\n      this.piTarget = this.text = \"\";\n      this.state = S_TEXT;\n    } else if (c === QUESTION) {\n      // We ran into ?? as part of a processing instruction. We initially took\n      // the first ? as a sign that the PI was ending, but it is not. So we have\n      // to add it to the body but we take the new ? as a sign that the PI is\n      // ending.\n      this.text += \"?\";\n    } else {\n      this.text += `?${String.fromCodePoint(c)}`;\n      this.state = S_PI_BODY;\n    }\n    this.xmlDeclPossible = false;\n  }\n  sXMLDeclNameStart() {\n    const c = this.skipSpaces();\n    // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    if (c === QUESTION) {\n      // It is valid to go to S_XML_DECL_ENDING from this state.\n      this.state = S_XML_DECL_ENDING;\n      return;\n    }\n    if (c !== EOC) {\n      this.state = S_XML_DECL_NAME;\n      this.name = String.fromCodePoint(c);\n    }\n  }\n  sXMLDeclName() {\n    const c = this.captureTo(XML_DECL_NAME_TERMINATOR);\n    // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.name += this.text;\n      this.text = \"\";\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n    if (!(isS(c) || c === EQUAL)) {\n      return;\n    }\n    this.name += this.text;\n    this.text = \"\";\n    if (!this.xmlDeclExpects.includes(this.name)) {\n      switch (this.name.length) {\n        case 0:\n          this.fail(\"did not expect any more name/value pairs.\");\n          break;\n        case 1:\n          this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n          break;\n        default:\n          this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n      }\n    }\n    this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n  }\n  sXMLDeclEq() {\n    const c = this.getCodeNorm();\n    // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n    if (isS(c)) {\n      return;\n    }\n    if (c !== EQUAL) {\n      this.fail(\"value required.\");\n    }\n    this.state = S_XML_DECL_VALUE_START;\n  }\n  sXMLDeclValueStart() {\n    const c = this.getCodeNorm();\n    // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n    if (isS(c)) {\n      return;\n    }\n    if (!isQuote(c)) {\n      this.fail(\"value must be quoted.\");\n      this.q = SPACE;\n    } else {\n      this.q = c;\n    }\n    this.state = S_XML_DECL_VALUE;\n  }\n  sXMLDeclValue() {\n    const c = this.captureTo([this.q, QUESTION]);\n    // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.text = \"\";\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n    if (c === EOC) {\n      return;\n    }\n    const value = this.text;\n    this.text = \"\";\n    switch (this.name) {\n      case \"version\":\n        {\n          this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n          const version = value;\n          this.xmlDecl.version = version;\n          // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n          if (!/^1\\.[0-9]+$/.test(version)) {\n            this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n          }\n          // When forceXMLVersion is set, the XML declaration is ignored.\n          else if (!this.opt.forceXMLVersion) {\n            this.setXMLVersion(version);\n          }\n          break;\n        }\n      case \"encoding\":\n        if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n          this.fail(\"encoding value must match \\\r\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n        }\n        this.xmlDeclExpects = [\"standalone\"];\n        this.xmlDecl.encoding = value;\n        break;\n      case \"standalone\":\n        if (value !== \"yes\" && value !== \"no\") {\n          this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n        }\n        this.xmlDeclExpects = [];\n        this.xmlDecl.standalone = value;\n        break;\n      default:\n      // We don't need to raise an error here since we've already raised one\n      // when checking what name was expected.\n    }\n\n    this.name = \"\";\n    this.state = S_XML_DECL_SEPARATOR;\n  }\n  sXMLDeclSeparator() {\n    const c = this.getCodeNorm();\n    // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    if (c === QUESTION) {\n      // It is valid to go to S_XML_DECL_ENDING from this state.\n      this.state = S_XML_DECL_ENDING;\n      return;\n    }\n    if (!isS(c)) {\n      this.fail(\"whitespace required.\");\n      this.unget();\n    }\n    this.state = S_XML_DECL_NAME_START;\n  }\n  sXMLDeclEnding() {\n    var _a;\n    const c = this.getCodeNorm();\n    if (c === GREATER) {\n      if (this.piTarget !== \"xml\") {\n        this.fail(\"processing instructions are not allowed before root.\");\n      } else if (this.name !== \"version\" && this.xmlDeclExpects.includes(\"version\")) {\n        this.fail(\"XML declaration must contain a version.\");\n      }\n      // eslint-disable-next-line no-unused-expressions\n      (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n      this.name = \"\";\n      this.piTarget = this.text = \"\";\n      this.state = S_TEXT;\n    } else {\n      // We got here because the previous character was a ?, but the question\n      // mark character is not valid inside any of the XML declaration\n      // name/value pairs.\n      this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n    }\n    this.xmlDeclPossible = false;\n  }\n  sOpenTag() {\n    var _a;\n    const c = this.captureNameChars();\n    if (c === EOC) {\n      return;\n    }\n    const tag = this.tag = {\n      name: this.name,\n      attributes: Object.create(null)\n    };\n    this.name = \"\";\n    if (this.xmlnsOpt) {\n      this.topNS = tag.ns = Object.create(null);\n    }\n    // eslint-disable-next-line no-unused-expressions\n    (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n    this.sawRoot = true;\n    if (!this.fragmentOpt && this.closedRoot) {\n      this.fail(\"documents may contain only one root.\");\n    }\n    switch (c) {\n      case GREATER:\n        this.openTag();\n        break;\n      case FORWARD_SLASH:\n        this.state = S_OPEN_TAG_SLASH;\n        break;\n      default:\n        if (!isS(c)) {\n          this.fail(\"disallowed character in tag name.\");\n        }\n        this.state = S_ATTRIB;\n    }\n  }\n  sOpenTagSlash() {\n    if (this.getCode() === GREATER) {\n      this.openSelfClosingTag();\n    } else {\n      this.fail(\"forward-slash in opening tag not followed by >.\");\n      this.state = S_ATTRIB;\n    }\n  }\n  sAttrib() {\n    const c = this.skipSpaces();\n    if (c === EOC) {\n      return;\n    }\n    if (isNameStartChar(c)) {\n      this.unget();\n      this.state = S_ATTRIB_NAME;\n    } else if (c === GREATER) {\n      this.openTag();\n    } else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    } else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n  sAttribName() {\n    const c = this.captureNameChars();\n    if (c === EQUAL) {\n      this.state = S_ATTRIB_VALUE;\n    } else if (isS(c)) {\n      this.state = S_ATTRIB_NAME_SAW_WHITE;\n    } else if (c === GREATER) {\n      this.fail(\"attribute without value.\");\n      this.pushAttrib(this.name, this.name);\n      this.name = this.text = \"\";\n      this.openTag();\n    } else if (c !== EOC) {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n  sAttribNameSawWhite() {\n    const c = this.skipSpaces();\n    switch (c) {\n      case EOC:\n        return;\n      case EQUAL:\n        this.state = S_ATTRIB_VALUE;\n        break;\n      default:\n        this.fail(\"attribute without value.\");\n        // Should we do this???\n        // this.tag.attributes[this.name] = \"\";\n        this.text = \"\";\n        this.name = \"\";\n        if (c === GREATER) {\n          this.openTag();\n        } else if (isNameStartChar(c)) {\n          this.unget();\n          this.state = S_ATTRIB_NAME;\n        } else {\n          this.fail(\"disallowed character in attribute name.\");\n          this.state = S_ATTRIB;\n        }\n    }\n  }\n  sAttribValue() {\n    const c = this.getCodeNorm();\n    if (isQuote(c)) {\n      this.q = c;\n      this.state = S_ATTRIB_VALUE_QUOTED;\n    } else if (!isS(c)) {\n      this.fail(\"unquoted attribute value.\");\n      this.state = S_ATTRIB_VALUE_UNQUOTED;\n      this.unget();\n    }\n  }\n  sAttribValueQuoted() {\n    // We deliberately do not use captureTo here. The specialized code we use\n    // here is faster than using captureTo.\n    const {\n      q,\n      chunk\n    } = this;\n    let {\n      i: start\n    } = this;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      switch (this.getCode()) {\n        case q:\n          this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n          this.name = this.text = \"\";\n          this.q = null;\n          this.state = S_ATTRIB_VALUE_CLOSED;\n          return;\n        case AMP:\n          this.text += chunk.slice(start, this.prevI);\n          this.state = S_ENTITY;\n          this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n          return;\n        case NL:\n        case NL_LIKE:\n        case TAB:\n          this.text += `${chunk.slice(start, this.prevI)} `;\n          start = this.i;\n          break;\n        case LESS:\n          this.text += chunk.slice(start, this.prevI);\n          this.fail(\"disallowed character.\");\n          return;\n        case EOC:\n          this.text += chunk.slice(start);\n          return;\n        default:\n      }\n    }\n  }\n  sAttribValueClosed() {\n    const c = this.getCodeNorm();\n    if (isS(c)) {\n      this.state = S_ATTRIB;\n    } else if (c === GREATER) {\n      this.openTag();\n    } else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    } else if (isNameStartChar(c)) {\n      this.fail(\"no whitespace between attributes.\");\n      this.unget();\n      this.state = S_ATTRIB_NAME;\n    } else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n  sAttribValueUnquoted() {\n    // We don't do anything regarding EOL or space handling for unquoted\n    // attributes. We already have failed by the time we get here, and the\n    // contract that saxes upholds states that upon failure, it is not safe to\n    // rely on the data passed to event handlers (other than\n    // ``onerror``). Passing \"bad\" data is not a problem.\n    const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n    switch (c) {\n      case AMP:\n        this.state = S_ENTITY;\n        this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n        break;\n      case LESS:\n        this.fail(\"disallowed character.\");\n        break;\n      case EOC:\n        break;\n      default:\n        if (this.text.includes(\"]]>\")) {\n          this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n        }\n        this.pushAttrib(this.name, this.text);\n        this.name = this.text = \"\";\n        if (c === GREATER) {\n          this.openTag();\n        } else {\n          this.state = S_ATTRIB;\n        }\n    }\n  }\n  sCloseTag() {\n    const c = this.captureNameChars();\n    if (c === GREATER) {\n      this.closeTag();\n    } else if (isS(c)) {\n      this.state = S_CLOSE_TAG_SAW_WHITE;\n    } else if (c !== EOC) {\n      this.fail(\"disallowed character in closing tag.\");\n    }\n  }\n  sCloseTagSawWhite() {\n    switch (this.skipSpaces()) {\n      case GREATER:\n        this.closeTag();\n        break;\n      case EOC:\n        break;\n      default:\n        this.fail(\"disallowed character in closing tag.\");\n    }\n  }\n  // END OF STATE ENGINE METHODS\n  handleTextInRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for performing the ]]> check. A previous version of this code, checked\n    // ``this.text`` for the presence of ]]>. It simplified the code but was\n    // very costly when character data contained a lot of entities to be parsed.\n    //\n    // Since we are using a specialized loop, we also keep track of the presence\n    // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n    //\n    let {\n      i: start,\n      forbiddenState\n    } = this;\n    const {\n      chunk,\n      textHandler: handler\n    } = this;\n    // eslint-disable-next-line no-labels, no-restricted-syntax\n    scanLoop:\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      switch (this.getCode()) {\n        case LESS:\n          {\n            this.state = S_OPEN_WAKA;\n            if (handler !== undefined) {\n              const {\n                text\n              } = this;\n              const slice = chunk.slice(start, this.prevI);\n              if (text.length !== 0) {\n                handler(text + slice);\n                this.text = \"\";\n              } else if (slice.length !== 0) {\n                handler(slice);\n              }\n            }\n            forbiddenState = FORBIDDEN_START;\n            // eslint-disable-next-line no-labels\n            break scanLoop;\n          }\n        case AMP:\n          this.state = S_ENTITY;\n          this.entityReturnState = S_TEXT;\n          if (handler !== undefined) {\n            this.text += chunk.slice(start, this.prevI);\n          }\n          forbiddenState = FORBIDDEN_START;\n          // eslint-disable-next-line no-labels\n          break scanLoop;\n        case CLOSE_BRACKET:\n          switch (forbiddenState) {\n            case FORBIDDEN_START:\n              forbiddenState = FORBIDDEN_BRACKET;\n              break;\n            case FORBIDDEN_BRACKET:\n              forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n              break;\n            case FORBIDDEN_BRACKET_BRACKET:\n              break;\n            default:\n              throw new Error(\"impossible state\");\n          }\n          break;\n        case GREATER:\n          if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n            this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n          }\n          forbiddenState = FORBIDDEN_START;\n          break;\n        case NL_LIKE:\n          if (handler !== undefined) {\n            this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          }\n          start = this.i;\n          forbiddenState = FORBIDDEN_START;\n          break;\n        case EOC:\n          if (handler !== undefined) {\n            this.text += chunk.slice(start);\n          }\n          // eslint-disable-next-line no-labels\n          break scanLoop;\n        default:\n          forbiddenState = FORBIDDEN_START;\n      }\n    }\n    this.forbiddenState = forbiddenState;\n  }\n  handleTextOutsideRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for a specialized task. We keep track of the presence of non-space\n    // characters in the text since these are errors when appearing outside the\n    // document root element.\n    let {\n      i: start\n    } = this;\n    const {\n      chunk,\n      textHandler: handler\n    } = this;\n    let nonSpace = false;\n    // eslint-disable-next-line no-labels, no-restricted-syntax\n    outRootLoop:\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const code = this.getCode();\n      switch (code) {\n        case LESS:\n          {\n            this.state = S_OPEN_WAKA;\n            if (handler !== undefined) {\n              const {\n                text\n              } = this;\n              const slice = chunk.slice(start, this.prevI);\n              if (text.length !== 0) {\n                handler(text + slice);\n                this.text = \"\";\n              } else if (slice.length !== 0) {\n                handler(slice);\n              }\n            }\n            // eslint-disable-next-line no-labels\n            break outRootLoop;\n          }\n        case AMP:\n          this.state = S_ENTITY;\n          this.entityReturnState = S_TEXT;\n          if (handler !== undefined) {\n            this.text += chunk.slice(start, this.prevI);\n          }\n          nonSpace = true;\n          // eslint-disable-next-line no-labels\n          break outRootLoop;\n        case NL_LIKE:\n          if (handler !== undefined) {\n            this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          }\n          start = this.i;\n          break;\n        case EOC:\n          if (handler !== undefined) {\n            this.text += chunk.slice(start);\n          }\n          // eslint-disable-next-line no-labels\n          break outRootLoop;\n        default:\n          if (!isS(code)) {\n            nonSpace = true;\n          }\n      }\n    }\n    if (!nonSpace) {\n      return;\n    }\n    // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n    // to avoid reporting errors for every single character that is out of\n    // place.\n    if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextBeforeRoot = true;\n    }\n    if (this.closedRoot && !this.reportedTextAfterRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextAfterRoot = true;\n    }\n  }\n  pushAttribNS(name, value) {\n    var _a;\n    const {\n      prefix,\n      local\n    } = this.qname(name);\n    const attr = {\n      name,\n      prefix,\n      local,\n      value\n    };\n    this.attribList.push(attr);\n    // eslint-disable-next-line no-unused-expressions\n    (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n    if (prefix === \"xmlns\") {\n      const trimmed = value.trim();\n      if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n        this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n      }\n      this.topNS[local] = trimmed;\n      nsPairCheck(this, local, trimmed);\n    } else if (name === \"xmlns\") {\n      const trimmed = value.trim();\n      this.topNS[\"\"] = trimmed;\n      nsPairCheck(this, \"\", trimmed);\n    }\n  }\n  pushAttribPlain(name, value) {\n    var _a;\n    const attr = {\n      name,\n      value\n    };\n    this.attribList.push(attr);\n    // eslint-disable-next-line no-unused-expressions\n    (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n  }\n  /**\r\n   * End parsing. This performs final well-formedness checks and resets the\r\n   * parser to a clean state.\r\n   *\r\n   * @returns this\r\n   */\n  end() {\n    var _a, _b;\n    if (!this.sawRoot) {\n      this.fail(\"document must contain a root element.\");\n    }\n    const {\n      tags\n    } = this;\n    while (tags.length > 0) {\n      const tag = tags.pop();\n      this.fail(`unclosed tag: ${tag.name}`);\n    }\n    if (this.state !== S_BEGIN && this.state !== S_TEXT) {\n      this.fail(\"unexpected end.\");\n    }\n    const {\n      text\n    } = this;\n    if (text.length !== 0) {\n      // eslint-disable-next-line no-unused-expressions\n      (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n      this.text = \"\";\n    }\n    this._closed = true;\n    // eslint-disable-next-line no-unused-expressions\n    (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n    this._init();\n    return this;\n  }\n  /**\r\n   * Resolve a namespace prefix.\r\n   *\r\n   * @param prefix The prefix to resolve.\r\n   *\r\n   * @returns The namespace URI or ``undefined`` if the prefix is not defined.\r\n   */\n  resolve(prefix) {\n    var _a, _b;\n    let uri = this.topNS[prefix];\n    if (uri !== undefined) {\n      return uri;\n    }\n    const {\n      tags\n    } = this;\n    for (let index = tags.length - 1; index >= 0; index--) {\n      uri = tags[index].ns[prefix];\n      if (uri !== undefined) {\n        return uri;\n      }\n    }\n    uri = this.ns[prefix];\n    if (uri !== undefined) {\n      return uri;\n    }\n    return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n  }\n  /**\r\n   * Parse a qname into its prefix and local name parts.\r\n   *\r\n   * @param name The name to parse\r\n   *\r\n   * @returns\r\n   */\n  qname(name) {\n    // This is faster than using name.split(\":\").\n    const colon = name.indexOf(\":\");\n    if (colon === -1) {\n      return {\n        prefix: \"\",\n        local: name\n      };\n    }\n    const local = name.slice(colon + 1);\n    const prefix = name.slice(0, colon);\n    if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n      this.fail(`malformed name: ${name}.`);\n    }\n    return {\n      prefix,\n      local\n    };\n  }\n  processAttribsNS() {\n    var _a;\n    const {\n      attribList\n    } = this;\n    const tag = this.tag;\n    {\n      // add namespace info to tag\n      const {\n        prefix,\n        local\n      } = this.qname(tag.name);\n      tag.prefix = prefix;\n      tag.local = local;\n      const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n      if (prefix !== \"\") {\n        if (prefix === \"xmlns\") {\n          this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n        }\n        if (uri === \"\") {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          tag.uri = prefix;\n        }\n      }\n    }\n    if (attribList.length === 0) {\n      return;\n    }\n    const {\n      attributes\n    } = tag;\n    const seen = new Set();\n    // Note: do not apply default ns to attributes:\n    //   http://www.w3.org/TR/REC-xml-names/#defaulting\n    for (const attr of attribList) {\n      const {\n        name,\n        prefix,\n        local\n      } = attr;\n      let uri;\n      let eqname;\n      if (prefix === \"\") {\n        uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n        eqname = name;\n      } else {\n        uri = this.resolve(prefix);\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (uri === undefined) {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          uri = prefix;\n        }\n        eqname = `{${uri}}${local}`;\n      }\n      if (seen.has(eqname)) {\n        this.fail(`duplicate attribute: ${eqname}.`);\n      }\n      seen.add(eqname);\n      attr.uri = uri;\n      attributes[name] = attr;\n    }\n    this.attribList = [];\n  }\n  processAttribsPlain() {\n    const {\n      attribList\n    } = this;\n    // eslint-disable-next-line prefer-destructuring\n    const attributes = this.tag.attributes;\n    for (const {\n      name,\n      value\n    } of attribList) {\n      if (attributes[name] !== undefined) {\n        this.fail(`duplicate attribute: ${name}.`);\n      }\n      attributes[name] = value;\n    }\n    this.attribList = [];\n  }\n  /**\r\n   * Handle a complete open tag. This parser code calls this once it has seen\r\n   * the whole tag. This method checks for well-formeness and then emits\r\n   * ``onopentag``.\r\n   */\n  openTag() {\n    var _a;\n    this.processAttribs();\n    const {\n      tags\n    } = this;\n    const tag = this.tag;\n    tag.isSelfClosing = false;\n    // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n    // eslint-disable-next-line no-unused-expressions\n    (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n    tags.push(tag);\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n  /**\r\n   * Handle a complete self-closing tag. This parser code calls this once it has\r\n   * seen the whole tag. This method checks for well-formeness and then emits\r\n   * ``onopentag`` and ``onclosetag``.\r\n   */\n  openSelfClosingTag() {\n    var _a, _b, _c;\n    this.processAttribs();\n    const {\n      tags\n    } = this;\n    const tag = this.tag;\n    tag.isSelfClosing = true;\n    // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n    // eslint-disable-next-line no-unused-expressions\n    (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n    // eslint-disable-next-line no-unused-expressions\n    (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n    const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n    if (top === null) {\n      this.closedRoot = true;\n    }\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n  /**\r\n   * Handle a complete close tag. This parser code calls this once it has seen\r\n   * the whole tag. This method checks for well-formeness and then emits\r\n   * ``onclosetag``.\r\n   */\n  closeTag() {\n    const {\n      tags,\n      name\n    } = this;\n    // Our state after this will be S_TEXT, no matter what, and we can clear\n    // tagName now.\n    this.state = S_TEXT;\n    this.name = \"\";\n    if (name === \"\") {\n      this.fail(\"weird empty close tag.\");\n      this.text += \"</>\";\n      return;\n    }\n    const handler = this.closeTagHandler;\n    let l = tags.length;\n    while (l-- > 0) {\n      const tag = this.tag = tags.pop();\n      this.topNS = tag.ns;\n      // eslint-disable-next-line no-unused-expressions\n      handler === null || handler === void 0 ? void 0 : handler(tag);\n      if (tag.name === name) {\n        break;\n      }\n      this.fail(\"unexpected close tag.\");\n    }\n    if (l === 0) {\n      this.closedRoot = true;\n    } else if (l < 0) {\n      this.fail(`unmatched closing tag: ${name}.`);\n      this.text += `</${name}>`;\n    }\n  }\n  /**\r\n   * Resolves an entity. Makes any necessary well-formedness checks.\r\n   *\r\n   * @param entity The entity to resolve.\r\n   *\r\n   * @returns The parsed entity.\r\n   */\n  parseEntity(entity) {\n    // startsWith would be significantly slower for this test.\n    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n    if (entity[0] !== \"#\") {\n      const defined = this.ENTITIES[entity];\n      if (defined !== undefined) {\n        return defined;\n      }\n      this.fail(this.isName(entity) ? \"undefined entity.\" : \"disallowed character in entity name.\");\n      return `&${entity};`;\n    }\n    let num = NaN;\n    if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n      num = parseInt(entity.slice(2), 16);\n    } else if (/^#[0-9]+$/.test(entity)) {\n      num = parseInt(entity.slice(1), 10);\n    }\n    // The character reference is required to match the CHAR production.\n    if (!this.isChar(num)) {\n      this.fail(\"malformed character entity.\");\n      return `&${entity};`;\n    }\n    return String.fromCodePoint(num);\n  }\n}\nexports.SaxesParser = SaxesParser;","map":{"version":3,"names":["ed5","require","ed2","NSed3","isS","isChar10","isChar","isNameStartChar","isNameChar","S_LIST","NAME_RE","isChar11","isNCNameStartChar","isNCNameChar","NC_NAME_RE","XML_NAMESPACE","XMLNS_NAMESPACE","rootNS","__proto__","xml","xmlns","XML_ENTITIES","amp","gt","lt","quot","apos","EOC","NL_LIKE","S_BEGIN","S_BEGIN_WHITESPACE","S_DOCTYPE","S_DOCTYPE_QUOTE","S_DTD","S_DTD_QUOTED","S_DTD_OPEN_WAKA","S_DTD_OPEN_WAKA_BANG","S_DTD_COMMENT","S_DTD_COMMENT_ENDING","S_DTD_COMMENT_ENDED","S_DTD_PI","S_DTD_PI_ENDING","S_TEXT","S_ENTITY","S_OPEN_WAKA","S_OPEN_WAKA_BANG","S_COMMENT","S_COMMENT_ENDING","S_COMMENT_ENDED","S_CDATA","S_CDATA_ENDING","S_CDATA_ENDING_2","S_PI_FIRST_CHAR","S_PI_REST","S_PI_BODY","S_PI_ENDING","S_XML_DECL_NAME_START","S_XML_DECL_NAME","S_XML_DECL_EQ","S_XML_DECL_VALUE_START","S_XML_DECL_VALUE","S_XML_DECL_SEPARATOR","S_XML_DECL_ENDING","S_OPEN_TAG","S_OPEN_TAG_SLASH","S_ATTRIB","S_ATTRIB_NAME","S_ATTRIB_NAME_SAW_WHITE","S_ATTRIB_VALUE","S_ATTRIB_VALUE_QUOTED","S_ATTRIB_VALUE_CLOSED","S_ATTRIB_VALUE_UNQUOTED","S_CLOSE_TAG","S_CLOSE_TAG_SAW_WHITE","TAB","NL","CR","SPACE","BANG","DQUOTE","AMP","SQUOTE","MINUS","FORWARD_SLASH","SEMICOLON","LESS","EQUAL","GREATER","QUESTION","OPEN_BRACKET","CLOSE_BRACKET","NEL","LS","isQuote","c","QUOTES","DOCTYPE_TERMINATOR","DTD_TERMINATOR","XML_DECL_NAME_TERMINATOR","ATTRIB_VALUE_UNQUOTED_TERMINATOR","nsPairCheck","parser","prefix","uri","fail","nsMappingCheck","mapping","local","Object","keys","isNCName","name","test","isName","FORBIDDEN_START","FORBIDDEN_BRACKET","FORBIDDEN_BRACKET_BRACKET","exports","EVENTS","EVENT_NAME_TO_HANDLER_NAME","xmldecl","text","processinginstruction","doctype","comment","opentagstart","attribute","opentag","closetag","cdata","error","end","ready","SaxesParser","constructor","opt","fragmentOpt","fragment","xmlnsOpt","trackPosition","position","fileName","nameStartCheck","nameCheck","processAttribs","processAttribsNS","pushAttrib","pushAttribNS","ns","assign","additional","additionalNamespaces","processAttribsPlain","pushAttribPlain","stateTable","sBegin","sBeginWhitespace","sDoctype","sDoctypeQuote","sDTD","sDTDQuoted","sDTDOpenWaka","sDTDOpenWakaBang","sDTDComment","sDTDCommentEnding","sDTDCommentEnded","sDTDPI","sDTDPIEnding","sText","sEntity","sOpenWaka","sOpenWakaBang","sComment","sCommentEnding","sCommentEnded","sCData","sCDataEnding","sCDataEnding2","sPIFirstChar","sPIRest","sPIBody","sPIEnding","sXMLDeclNameStart","sXMLDeclName","sXMLDeclEq","sXMLDeclValueStart","sXMLDeclValue","sXMLDeclSeparator","sXMLDeclEnding","sOpenTag","sOpenTagSlash","sAttrib","sAttribName","sAttribNameSawWhite","sAttribValue","sAttribValueQuoted","sAttribValueClosed","sAttribValueUnquoted","sCloseTag","sCloseTagSawWhite","_init","closed","_closed","openWakaBang","piTarget","entity","q","tags","tag","topNS","chunk","chunkPosition","i","prevI","carriedFromPrevious","undefined","forbiddenState","attribList","state","reportedTextBeforeRoot","reportedTextAfterRoot","closedRoot","sawRoot","xmlDeclPossible","xmlDeclExpects","entityReturnState","defaultXMLVersion","forceXMLVersion","Error","setXMLVersion","positionAtNewLine","xmlDecl","version","encoding","standalone","line","column","ENTITIES","create","_a","readyHandler","call","columnIndex","on","handler","off","makeError","message","msg","length","err","errorHandler","write","toString","limit","lastCode","charCodeAt","slice","close","getCode10","code","final","getCode11","next","getCodeNorm","getCode","unget","captureTo","chars","start","isNLLike","includes","captureToChar","char","captureNameChars","skipSpaces","currentXMLVersion","iBefore","doctypeHandler","String","fromCodePoint","owb","handleTextInRoot","handleTextOutsideRoot","loop","parsed","parseEntity","textHandler","commentHandler","cdataHandler","isQuestion","toLowerCase","piHandler","target","body","join","value","xmldeclHandler","attributes","openTagStartHandler","openTag","openSelfClosingTag","closeTag","scanLoop","nonSpace","outRootLoop","qname","attr","push","attributeHandler","trimmed","trim","pop","_b","endHandler","resolve","index","resolvePrefix","colon","indexOf","JSON","stringify","seen","Set","eqname","has","add","isSelfClosing","openTagHandler","closeTagHandler","top","_c","l","defined","num","NaN","parseInt"],"sources":["../../src/saxes.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}