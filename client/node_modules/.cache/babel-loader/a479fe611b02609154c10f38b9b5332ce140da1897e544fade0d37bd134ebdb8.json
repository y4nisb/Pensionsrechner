{"ast":null,"code":"\"use strict\";\n\nconst {\n  SaxesParser\n} = require(\"saxes\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst {\n  createElement\n} = require(\"../../living/helpers/create-element\");\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\nconst DocumentType = require(\"../../living/generated/DocumentType\");\nconst CDATASection = require(\"../../living/generated/CDATASection\");\nconst Comment = require(\"../../living/generated/Comment\");\nconst ProcessingInstruction = require(\"../../living/generated/ProcessingInstruction\");\nconst Text = require(\"../../living/generated/Text\");\nconst attributes = require(\"../../living/attributes\");\nconst {\n  HTML_NS\n} = require(\"../../living/helpers/namespaces\");\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\nconst CUSTOM_NAME_DOCTYPE = /<!doctype\\s+([^\\s>]+)/i;\nfunction parseDocType(globalObject, ownerDocument, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentType(globalObject, ownerDocument, \"html\", \"\", \"\");\n  }\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n  if (publicPieces) {\n    return createDocumentType(globalObject, ownerDocument, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n  if (systemPieces) {\n    return createDocumentType(globalObject, ownerDocument, systemPieces[1], \"\", systemPieces[2]);\n  }\n  const namePiece = CUSTOM_NAME_DOCTYPE.exec(html)[1] || \"html\";\n  return createDocumentType(globalObject, ownerDocument, namePiece, \"\", \"\");\n}\nfunction createDocumentType(globalObject, ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl(globalObject, [], {\n    ownerDocument,\n    name,\n    publicId,\n    systemId\n  });\n}\nfunction isHTMLTemplateElement(element) {\n  return element.tagName === \"template\" && element.namespaceURI === HTML_NS;\n}\nfunction createParser(rootNode, globalObject, saxesOptions) {\n  const parser = new SaxesParser({\n    ...saxesOptions,\n    // Browsers always have namespace support.\n    xmlns: true,\n    // We force the parser to treat all documents (even documents declaring themselves to be XML 1.1 documents) as XML\n    // 1.0 documents. See https://github.com/jsdom/jsdom/issues/2677 for a discussion of the stakes.\n    defaultXMLVersion: \"1.0\",\n    forceXMLVersion: true\n  });\n  const openStack = [rootNode];\n  function getOwnerDocument() {\n    const currentElement = openStack[openStack.length - 1];\n    return isHTMLTemplateElement(currentElement) ? currentElement._templateContents._ownerDocument : currentElement._ownerDocument;\n  }\n  function appendChild(child) {\n    const parentElement = openStack[openStack.length - 1];\n    if (isHTMLTemplateElement(parentElement)) {\n      parentElement._templateContents._insert(child, null);\n    } else {\n      parentElement._insert(child, null);\n    }\n  }\n  parser.on(\"text\", saxesOptions.fragment ?\n  // In a fragment, all text events produced by saxes must result in a text\n  // node.\n  data => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(Text.createImpl(globalObject, [], {\n      data,\n      ownerDocument\n    }));\n  } :\n  // When parsing a whole document, we must ignore those text nodes that are\n  // produced outside the root element. Saxes produces events for them,\n  // but DOM trees do not record text outside the root element.\n  data => {\n    if (openStack.length > 1) {\n      const ownerDocument = getOwnerDocument();\n      appendChild(Text.createImpl(globalObject, [], {\n        data,\n        ownerDocument\n      }));\n    }\n  });\n  parser.on(\"cdata\", data => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(CDATASection.createImpl(globalObject, [], {\n      data,\n      ownerDocument\n    }));\n  });\n  parser.on(\"opentag\", tag => {\n    const {\n      local: tagLocal,\n      attributes: tagAttributes\n    } = tag;\n    const ownerDocument = getOwnerDocument();\n    const tagNamespace = tag.uri === \"\" ? null : tag.uri;\n    const tagPrefix = tag.prefix === \"\" ? null : tag.prefix;\n    const isValue = tagAttributes.is === undefined ? null : tagAttributes.is.value;\n    const elem = createElement(ownerDocument, tagLocal, tagNamespace, tagPrefix, isValue, true);\n\n    // We mark a script element as \"parser-inserted\", which prevents it from\n    // being immediately executed.\n    if (tagLocal === \"script\" && tagNamespace === HTML_NS) {\n      elem._parserInserted = true;\n    }\n    for (const key of Object.keys(tagAttributes)) {\n      const {\n        prefix,\n        local,\n        uri,\n        value\n      } = tagAttributes[key];\n      attributes.setAttributeValue(elem, local, value, prefix === \"\" ? null : prefix, uri === \"\" ? null : uri);\n    }\n    appendChild(elem);\n    openStack.push(elem);\n  });\n  parser.on(\"closetag\", () => {\n    const elem = openStack.pop();\n    // Once a script is populated, we can execute it.\n    if (elem.localName === \"script\" && elem.namespaceURI === HTML_NS) {\n      elem._eval();\n    }\n  });\n  parser.on(\"comment\", data => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(Comment.createImpl(globalObject, [], {\n      data,\n      ownerDocument\n    }));\n  });\n  parser.on(\"processinginstruction\", _ref => {\n    let {\n      target,\n      body\n    } = _ref;\n    const ownerDocument = getOwnerDocument();\n    appendChild(ProcessingInstruction.createImpl(globalObject, [], {\n      target,\n      data: body,\n      ownerDocument\n    }));\n  });\n  parser.on(\"doctype\", dt => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(parseDocType(globalObject, ownerDocument, `<!doctype ${dt}>`));\n    const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n    let result;\n    while (result = entityMatcher.exec(dt)) {\n      const [, name, value] = result;\n      if (!(name in parser.ENTITIES)) {\n        parser.ENTITIES[name] = value;\n      }\n    }\n  });\n  parser.on(\"error\", err => {\n    throw DOMException.create(globalObject, [err.message, \"SyntaxError\"]);\n  });\n  return parser;\n}\nfunction parseFragment(markup, contextElement) {\n  const {\n    _globalObject,\n    _ownerDocument\n  } = contextElement;\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: _ownerDocument\n  });\n\n  // Only parseFragment needs resolvePrefix per the saxes documentation:\n  // https://github.com/lddubeau/saxes#parsing-xml-fragments\n  const parser = createParser(fragment, _globalObject, {\n    fragment: true,\n    resolvePrefix(prefix) {\n      // saxes wants undefined as the return value if the prefix is not defined, not null.\n      return contextElement.lookupNamespaceURI(prefix) || undefined;\n    }\n  });\n  parser.write(markup).close();\n  return fragment;\n}\nfunction parseIntoDocument(markup, ownerDocument) {\n  const {\n    _globalObject\n  } = ownerDocument;\n  const parser = createParser(ownerDocument, _globalObject, {\n    fileName: ownerDocument.location && ownerDocument.location.href\n  });\n  parser.write(markup).close();\n  return ownerDocument;\n}\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};","map":{"version":3,"names":["SaxesParser","require","DOMException","createElement","DocumentFragment","DocumentType","CDATASection","Comment","ProcessingInstruction","Text","attributes","HTML_NS","HTML5_DOCTYPE","PUBLIC_DOCTYPE","SYSTEM_DOCTYPE","CUSTOM_NAME_DOCTYPE","parseDocType","globalObject","ownerDocument","html","test","createDocumentType","publicPieces","exec","systemPieces","namePiece","name","publicId","systemId","createImpl","isHTMLTemplateElement","element","tagName","namespaceURI","createParser","rootNode","saxesOptions","parser","xmlns","defaultXMLVersion","forceXMLVersion","openStack","getOwnerDocument","currentElement","length","_templateContents","_ownerDocument","appendChild","child","parentElement","_insert","on","fragment","data","tag","local","tagLocal","tagAttributes","tagNamespace","uri","tagPrefix","prefix","isValue","is","undefined","value","elem","_parserInserted","key","Object","keys","setAttributeValue","push","pop","localName","_eval","_ref","target","body","dt","entityMatcher","result","ENTITIES","err","create","message","parseFragment","markup","contextElement","_globalObject","resolvePrefix","lookupNamespaceURI","write","close","parseIntoDocument","fileName","location","href","module","exports"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/jsdom/browser/parser/xml.js"],"sourcesContent":["\"use strict\";\r\n\r\nconst { SaxesParser } = require(\"saxes\");\r\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\r\n\r\nconst { createElement } = require(\"../../living/helpers/create-element\");\r\n\r\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\r\nconst DocumentType = require(\"../../living/generated/DocumentType\");\r\nconst CDATASection = require(\"../../living/generated/CDATASection\");\r\nconst Comment = require(\"../../living/generated/Comment\");\r\nconst ProcessingInstruction = require(\"../../living/generated/ProcessingInstruction\");\r\nconst Text = require(\"../../living/generated/Text\");\r\n\r\nconst attributes = require(\"../../living/attributes\");\r\nconst { HTML_NS } = require(\"../../living/helpers/namespaces\");\r\n\r\nconst HTML5_DOCTYPE = /<!doctype html>/i;\r\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\r\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\r\nconst CUSTOM_NAME_DOCTYPE = /<!doctype\\s+([^\\s>]+)/i;\r\n\r\nfunction parseDocType(globalObject, ownerDocument, html) {\r\n  if (HTML5_DOCTYPE.test(html)) {\r\n    return createDocumentType(globalObject, ownerDocument, \"html\", \"\", \"\");\r\n  }\r\n\r\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\r\n  if (publicPieces) {\r\n    return createDocumentType(globalObject, ownerDocument, publicPieces[1], publicPieces[2], publicPieces[3]);\r\n  }\r\n\r\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\r\n  if (systemPieces) {\r\n    return createDocumentType(globalObject, ownerDocument, systemPieces[1], \"\", systemPieces[2]);\r\n  }\r\n\r\n  const namePiece = CUSTOM_NAME_DOCTYPE.exec(html)[1] || \"html\";\r\n  return createDocumentType(globalObject, ownerDocument, namePiece, \"\", \"\");\r\n}\r\n\r\nfunction createDocumentType(globalObject, ownerDocument, name, publicId, systemId) {\r\n  return DocumentType.createImpl(globalObject, [], { ownerDocument, name, publicId, systemId });\r\n}\r\n\r\nfunction isHTMLTemplateElement(element) {\r\n  return element.tagName === \"template\" && element.namespaceURI === HTML_NS;\r\n}\r\n\r\n\r\nfunction createParser(rootNode, globalObject, saxesOptions) {\r\n  const parser = new SaxesParser({\r\n    ...saxesOptions,\r\n    // Browsers always have namespace support.\r\n    xmlns: true,\r\n    // We force the parser to treat all documents (even documents declaring themselves to be XML 1.1 documents) as XML\r\n    // 1.0 documents. See https://github.com/jsdom/jsdom/issues/2677 for a discussion of the stakes.\r\n    defaultXMLVersion: \"1.0\",\r\n    forceXMLVersion: true\r\n  });\r\n  const openStack = [rootNode];\r\n\r\n  function getOwnerDocument() {\r\n    const currentElement = openStack[openStack.length - 1];\r\n\r\n    return isHTMLTemplateElement(currentElement) ?\r\n      currentElement._templateContents._ownerDocument :\r\n      currentElement._ownerDocument;\r\n  }\r\n\r\n  function appendChild(child) {\r\n    const parentElement = openStack[openStack.length - 1];\r\n\r\n    if (isHTMLTemplateElement(parentElement)) {\r\n      parentElement._templateContents._insert(child, null);\r\n    } else {\r\n      parentElement._insert(child, null);\r\n    }\r\n  }\r\n\r\n  parser.on(\"text\", saxesOptions.fragment ?\r\n    // In a fragment, all text events produced by saxes must result in a text\r\n    // node.\r\n    data => {\r\n      const ownerDocument = getOwnerDocument();\r\n      appendChild(Text.createImpl(globalObject, [], { data, ownerDocument }));\r\n    } :\r\n    // When parsing a whole document, we must ignore those text nodes that are\r\n    // produced outside the root element. Saxes produces events for them,\r\n    // but DOM trees do not record text outside the root element.\r\n    data => {\r\n      if (openStack.length > 1) {\r\n        const ownerDocument = getOwnerDocument();\r\n        appendChild(Text.createImpl(globalObject, [], { data, ownerDocument }));\r\n      }\r\n    });\r\n\r\n  parser.on(\"cdata\", data => {\r\n    const ownerDocument = getOwnerDocument();\r\n    appendChild(CDATASection.createImpl(globalObject, [], { data, ownerDocument }));\r\n  });\r\n\r\n  parser.on(\"opentag\", tag => {\r\n    const { local: tagLocal, attributes: tagAttributes } = tag;\r\n\r\n    const ownerDocument = getOwnerDocument();\r\n    const tagNamespace = tag.uri === \"\" ? null : tag.uri;\r\n    const tagPrefix = tag.prefix === \"\" ? null : tag.prefix;\r\n    const isValue = tagAttributes.is === undefined ? null : tagAttributes.is.value;\r\n\r\n    const elem = createElement(ownerDocument, tagLocal, tagNamespace, tagPrefix, isValue, true);\r\n\r\n    // We mark a script element as \"parser-inserted\", which prevents it from\r\n    // being immediately executed.\r\n    if (tagLocal === \"script\" && tagNamespace === HTML_NS) {\r\n      elem._parserInserted = true;\r\n    }\r\n\r\n    for (const key of Object.keys(tagAttributes)) {\r\n      const { prefix, local, uri, value } = tagAttributes[key];\r\n      attributes.setAttributeValue(elem, local, value, prefix === \"\" ? null : prefix, uri === \"\" ? null : uri);\r\n    }\r\n\r\n    appendChild(elem);\r\n    openStack.push(elem);\r\n  });\r\n\r\n  parser.on(\"closetag\", () => {\r\n    const elem = openStack.pop();\r\n    // Once a script is populated, we can execute it.\r\n    if (elem.localName === \"script\" && elem.namespaceURI === HTML_NS) {\r\n      elem._eval();\r\n    }\r\n  });\r\n\r\n  parser.on(\"comment\", data => {\r\n    const ownerDocument = getOwnerDocument();\r\n    appendChild(Comment.createImpl(globalObject, [], { data, ownerDocument }));\r\n  });\r\n\r\n  parser.on(\"processinginstruction\", ({ target, body }) => {\r\n    const ownerDocument = getOwnerDocument();\r\n    appendChild(ProcessingInstruction.createImpl(globalObject, [], { target, data: body, ownerDocument }));\r\n  });\r\n\r\n  parser.on(\"doctype\", dt => {\r\n    const ownerDocument = getOwnerDocument();\r\n    appendChild(parseDocType(globalObject, ownerDocument, `<!doctype ${dt}>`));\r\n\r\n    const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\r\n    let result;\r\n    while ((result = entityMatcher.exec(dt))) {\r\n      const [, name, value] = result;\r\n      if (!(name in parser.ENTITIES)) {\r\n        parser.ENTITIES[name] = value;\r\n      }\r\n    }\r\n  });\r\n\r\n  parser.on(\"error\", err => {\r\n    throw DOMException.create(globalObject, [err.message, \"SyntaxError\"]);\r\n  });\r\n\r\n  return parser;\r\n}\r\n\r\nfunction parseFragment(markup, contextElement) {\r\n  const { _globalObject, _ownerDocument } = contextElement;\r\n\r\n  const fragment = DocumentFragment.createImpl(_globalObject, [], { ownerDocument: _ownerDocument });\r\n\r\n  // Only parseFragment needs resolvePrefix per the saxes documentation:\r\n  // https://github.com/lddubeau/saxes#parsing-xml-fragments\r\n  const parser = createParser(fragment, _globalObject, {\r\n    fragment: true,\r\n    resolvePrefix(prefix) {\r\n      // saxes wants undefined as the return value if the prefix is not defined, not null.\r\n      return contextElement.lookupNamespaceURI(prefix) || undefined;\r\n    }\r\n  });\r\n\r\n  parser.write(markup).close();\r\n\r\n  return fragment;\r\n}\r\n\r\nfunction parseIntoDocument(markup, ownerDocument) {\r\n  const { _globalObject } = ownerDocument;\r\n\r\n  const parser = createParser(ownerDocument, _globalObject, {\r\n    fileName: ownerDocument.location && ownerDocument.location.href\r\n  });\r\n\r\n  parser.write(markup).close();\r\n\r\n  return ownerDocument;\r\n}\r\n\r\nmodule.exports = {\r\n  parseFragment,\r\n  parseIntoDocument\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}