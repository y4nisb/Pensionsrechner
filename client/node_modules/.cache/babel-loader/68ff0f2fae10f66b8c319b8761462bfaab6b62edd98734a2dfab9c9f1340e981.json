{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\nconst {\n  fileURLToPath\n} = require(\"url\");\nconst {\n  parseURL\n} = require(\"whatwg-url\");\nconst dataURLFromRecord = require(\"data-urls\").fromURLRecord;\nconst packageVersion = require(\"../../../../package.json\").version;\nconst agentFactory = require(\"../../living/helpers/agent-factory\");\nconst Request = require(\"../../living/helpers/http-request\");\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\nmodule.exports = class ResourceLoader {\n  constructor() {\n    let {\n      strictSSL = true,\n      proxy = undefined,\n      userAgent = `Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 ` + `(KHTML, like Gecko) jsdom/${packageVersion}`\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._strictSSL = strictSSL;\n    this._proxy = proxy;\n    this._userAgent = userAgent;\n  }\n  _readDataURL(urlRecord) {\n    const dataURL = dataURLFromRecord(urlRecord);\n    let timeoutId;\n    const promise = new Promise(resolve => {\n      timeoutId = setTimeout(resolve, 0, dataURL.body);\n    });\n    promise.abort = () => {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    };\n    return promise;\n  }\n  _readFile(filePath) {\n    let readableStream, abort; // Native Promises doesn't have an \"abort\" method.\n\n    // Creating a promise for two reason:\n    //   1. fetch always return a promise.\n    //   2. We need to add an abort handler.\n    const promise = new Promise((resolve, reject) => {\n      readableStream = fs.createReadStream(filePath);\n      let data = Buffer.alloc(0);\n      abort = reject;\n      readableStream.on(\"error\", reject);\n      readableStream.on(\"data\", chunk => {\n        data = Buffer.concat([data, chunk]);\n      });\n      readableStream.on(\"end\", () => {\n        resolve(data);\n      });\n    });\n    promise.abort = () => {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      abort(error);\n    };\n    return promise;\n  }\n  fetch(urlString) {\n    let {\n      accept,\n      cookieJar,\n      referrer\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const url = parseURL(urlString);\n    if (!url) {\n      return Promise.reject(new Error(`Tried to fetch invalid URL ${urlString}`));\n    }\n    switch (url.scheme) {\n      case \"data\":\n        {\n          return this._readDataURL(url);\n        }\n      case \"http\":\n      case \"https\":\n        {\n          const agents = agentFactory(this._proxy, this._strictSSL);\n          const headers = {\n            \"User-Agent\": this._userAgent,\n            \"Accept-Language\": \"en\",\n            \"Accept-Encoding\": \"gzip\",\n            \"Accept\": accept || \"*/*\"\n          };\n          if (referrer && !IS_BROWSER) {\n            headers.Referer = referrer;\n          }\n          const requestClient = new Request(urlString, {\n            followRedirects: true,\n            cookieJar,\n            agents\n          }, {\n            headers\n          });\n          const promise = new Promise((resolve, reject) => {\n            const accumulated = [];\n            requestClient.once(\"response\", res => {\n              promise.response = res;\n              const {\n                statusCode\n              } = res;\n              // TODO This deviates from the spec when it comes to\n              // loading resources such as images\n              if (statusCode < 200 || statusCode > 299) {\n                requestClient.abort();\n                reject(new Error(`Resource was not loaded. Status: ${statusCode}`));\n              }\n            });\n            requestClient.on(\"data\", chunk => {\n              accumulated.push(chunk);\n            });\n            requestClient.on(\"end\", () => resolve(Buffer.concat(accumulated)));\n            requestClient.on(\"error\", reject);\n          });\n          // The method fromURL in lib/api.js crashes without the following four\n          // properties defined on the Promise instance, causing the test suite to halt\n          requestClient.on(\"end\", () => {\n            promise.href = requestClient.currentURL;\n          });\n          promise.abort = requestClient.abort.bind(requestClient);\n          promise.getHeader = name => headers[name] || requestClient.getHeader(name);\n          requestClient.end();\n          return promise;\n        }\n      case \"file\":\n        {\n          try {\n            return this._readFile(fileURLToPath(urlString));\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }\n      default:\n        {\n          return Promise.reject(new Error(`Tried to fetch URL ${urlString} with invalid scheme ${url.scheme}`));\n        }\n    }\n  }\n};","map":{"version":3,"names":["fs","require","fileURLToPath","parseURL","dataURLFromRecord","fromURLRecord","packageVersion","version","agentFactory","Request","IS_BROWSER","Object","prototype","toString","call","process","module","exports","ResourceLoader","constructor","strictSSL","proxy","undefined","userAgent","platform","arguments","length","_strictSSL","_proxy","_userAgent","_readDataURL","urlRecord","dataURL","timeoutId","promise","Promise","resolve","setTimeout","body","abort","clearTimeout","_readFile","filePath","readableStream","reject","createReadStream","data","Buffer","alloc","on","chunk","concat","destroy","error","Error","isAbortError","fetch","urlString","accept","cookieJar","referrer","url","scheme","agents","headers","Referer","requestClient","followRedirects","accumulated","once","res","response","statusCode","push","href","currentURL","bind","getHeader","name","end","e"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/jsdom/browser/resources/resource-loader.js"],"sourcesContent":["\"use strict\";\r\nconst fs = require(\"fs\");\r\nconst { fileURLToPath } = require(\"url\");\r\nconst { parseURL } = require(\"whatwg-url\");\r\nconst dataURLFromRecord = require(\"data-urls\").fromURLRecord;\r\nconst packageVersion = require(\"../../../../package.json\").version;\r\nconst agentFactory = require(\"../../living/helpers/agent-factory\");\r\nconst Request = require(\"../../living/helpers/http-request\");\r\n\r\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\r\n\r\nmodule.exports = class ResourceLoader {\r\n  constructor({\r\n    strictSSL = true,\r\n    proxy = undefined,\r\n    userAgent = `Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 ` +\r\n                `(KHTML, like Gecko) jsdom/${packageVersion}`\r\n  } = {}) {\r\n    this._strictSSL = strictSSL;\r\n    this._proxy = proxy;\r\n    this._userAgent = userAgent;\r\n  }\r\n\r\n  _readDataURL(urlRecord) {\r\n    const dataURL = dataURLFromRecord(urlRecord);\r\n    let timeoutId;\r\n    const promise = new Promise(resolve => {\r\n      timeoutId = setTimeout(resolve, 0, dataURL.body);\r\n    });\r\n    promise.abort = () => {\r\n      if (timeoutId !== undefined) {\r\n        clearTimeout(timeoutId);\r\n      }\r\n    };\r\n    return promise;\r\n  }\r\n\r\n  _readFile(filePath) {\r\n    let readableStream, abort; // Native Promises doesn't have an \"abort\" method.\r\n\r\n    // Creating a promise for two reason:\r\n    //   1. fetch always return a promise.\r\n    //   2. We need to add an abort handler.\r\n    const promise = new Promise((resolve, reject) => {\r\n      readableStream = fs.createReadStream(filePath);\r\n      let data = Buffer.alloc(0);\r\n\r\n      abort = reject;\r\n\r\n      readableStream.on(\"error\", reject);\r\n\r\n      readableStream.on(\"data\", chunk => {\r\n        data = Buffer.concat([data, chunk]);\r\n      });\r\n\r\n      readableStream.on(\"end\", () => {\r\n        resolve(data);\r\n      });\r\n    });\r\n\r\n    promise.abort = () => {\r\n      readableStream.destroy();\r\n      const error = new Error(\"request canceled by user\");\r\n      error.isAbortError = true;\r\n      abort(error);\r\n    };\r\n\r\n    return promise;\r\n  }\r\n\r\n  fetch(urlString, { accept, cookieJar, referrer } = {}) {\r\n    const url = parseURL(urlString);\r\n\r\n    if (!url) {\r\n      return Promise.reject(new Error(`Tried to fetch invalid URL ${urlString}`));\r\n    }\r\n\r\n    switch (url.scheme) {\r\n      case \"data\": {\r\n        return this._readDataURL(url);\r\n      }\r\n\r\n      case \"http\":\r\n      case \"https\": {\r\n        const agents = agentFactory(this._proxy, this._strictSSL);\r\n        const headers = {\r\n          \"User-Agent\": this._userAgent,\r\n          \"Accept-Language\": \"en\",\r\n          \"Accept-Encoding\": \"gzip\",\r\n          \"Accept\": accept || \"*/*\"\r\n        };\r\n        if (referrer && !IS_BROWSER) {\r\n          headers.Referer = referrer;\r\n        }\r\n        const requestClient = new Request(\r\n          urlString,\r\n          { followRedirects: true, cookieJar, agents },\r\n          { headers }\r\n        );\r\n        const promise = new Promise((resolve, reject) => {\r\n          const accumulated = [];\r\n          requestClient.once(\"response\", res => {\r\n            promise.response = res;\r\n            const { statusCode } = res;\r\n            // TODO This deviates from the spec when it comes to\r\n            // loading resources such as images\r\n            if (statusCode < 200 || statusCode > 299) {\r\n              requestClient.abort();\r\n              reject(new Error(`Resource was not loaded. Status: ${statusCode}`));\r\n            }\r\n          });\r\n          requestClient.on(\"data\", chunk => {\r\n            accumulated.push(chunk);\r\n          });\r\n          requestClient.on(\"end\", () => resolve(Buffer.concat(accumulated)));\r\n          requestClient.on(\"error\", reject);\r\n        });\r\n        // The method fromURL in lib/api.js crashes without the following four\r\n        // properties defined on the Promise instance, causing the test suite to halt\r\n        requestClient.on(\"end\", () => {\r\n          promise.href = requestClient.currentURL;\r\n        });\r\n        promise.abort = requestClient.abort.bind(requestClient);\r\n        promise.getHeader = name => headers[name] || requestClient.getHeader(name);\r\n        requestClient.end();\r\n        return promise;\r\n      }\r\n\r\n      case \"file\": {\r\n        try {\r\n          return this._readFile(fileURLToPath(urlString));\r\n        } catch (e) {\r\n          return Promise.reject(e);\r\n        }\r\n      }\r\n\r\n      default: {\r\n        return Promise.reject(new Error(`Tried to fetch URL ${urlString} with invalid scheme ${url.scheme}`));\r\n      }\r\n    }\r\n  }\r\n};\r\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AACxB,MAAM;EAAEC;AAAc,CAAC,GAAGD,OAAO,CAAC,KAAK,CAAC;AACxC,MAAM;EAAEE;AAAS,CAAC,GAAGF,OAAO,CAAC,YAAY,CAAC;AAC1C,MAAMG,iBAAiB,GAAGH,OAAO,CAAC,WAAW,CAAC,CAACI,aAAa;AAC5D,MAAMC,cAAc,GAAGL,OAAO,CAAC,0BAA0B,CAAC,CAACM,OAAO;AAClE,MAAMC,YAAY,GAAGP,OAAO,CAAC,oCAAoC,CAAC;AAClE,MAAMQ,OAAO,GAAGR,OAAO,CAAC,mCAAmC,CAAC;AAE5D,MAAMS,UAAU,GAAGC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACC,OAAO,CAAC,KAAK,kBAAkB;AAEjFC,MAAM,CAACC,OAAO,GAAG,MAAMC,cAAc,CAAC;EACpCC,WAAWA,CAAA,EAKH;IAAA,IALI;MACVC,SAAS,GAAG,IAAI;MAChBC,KAAK,GAAGC,SAAS;MACjBC,SAAS,GAAI,gBAAeR,OAAO,CAACS,QAAQ,IAAI,YAAa,uBAAsB,GACtE,6BAA4BlB,cAAe;IAC1D,CAAC,GAAAmB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,CAAC,CAAC;IACJ,IAAI,CAACE,UAAU,GAAGP,SAAS;IAC3B,IAAI,CAACQ,MAAM,GAAGP,KAAK;IACnB,IAAI,CAACQ,UAAU,GAAGN,SAAS;EAC7B;EAEAO,YAAYA,CAACC,SAAS,EAAE;IACtB,MAAMC,OAAO,GAAG5B,iBAAiB,CAAC2B,SAAS,CAAC;IAC5C,IAAIE,SAAS;IACb,MAAMC,OAAO,GAAG,IAAIC,OAAO,CAACC,OAAO,IAAI;MACrCH,SAAS,GAAGI,UAAU,CAACD,OAAO,EAAE,CAAC,EAAEJ,OAAO,CAACM,IAAI,CAAC;IAClD,CAAC,CAAC;IACFJ,OAAO,CAACK,KAAK,GAAG,MAAM;MACpB,IAAIN,SAAS,KAAKX,SAAS,EAAE;QAC3BkB,YAAY,CAACP,SAAS,CAAC;MACzB;IACF,CAAC;IACD,OAAOC,OAAO;EAChB;EAEAO,SAASA,CAACC,QAAQ,EAAE;IAClB,IAAIC,cAAc,EAAEJ,KAAK,CAAC,CAAC;;IAE3B;IACA;IACA;IACA,MAAML,OAAO,GAAG,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEQ,MAAM,KAAK;MAC/CD,cAAc,GAAG3C,EAAE,CAAC6C,gBAAgB,CAACH,QAAQ,CAAC;MAC9C,IAAII,IAAI,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;MAE1BT,KAAK,GAAGK,MAAM;MAEdD,cAAc,CAACM,EAAE,CAAC,OAAO,EAAEL,MAAM,CAAC;MAElCD,cAAc,CAACM,EAAE,CAAC,MAAM,EAAEC,KAAK,IAAI;QACjCJ,IAAI,GAAGC,MAAM,CAACI,MAAM,CAAC,CAACL,IAAI,EAAEI,KAAK,CAAC,CAAC;MACrC,CAAC,CAAC;MAEFP,cAAc,CAACM,EAAE,CAAC,KAAK,EAAE,MAAM;QAC7Bb,OAAO,CAACU,IAAI,CAAC;MACf,CAAC,CAAC;IACJ,CAAC,CAAC;IAEFZ,OAAO,CAACK,KAAK,GAAG,MAAM;MACpBI,cAAc,CAACS,OAAO,EAAE;MACxB,MAAMC,KAAK,GAAG,IAAIC,KAAK,CAAC,0BAA0B,CAAC;MACnDD,KAAK,CAACE,YAAY,GAAG,IAAI;MACzBhB,KAAK,CAACc,KAAK,CAAC;IACd,CAAC;IAED,OAAOnB,OAAO;EAChB;EAEAsB,KAAKA,CAACC,SAAS,EAAwC;IAAA,IAAtC;MAAEC,MAAM;MAAEC,SAAS;MAAEC;IAAS,CAAC,GAAAnC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,CAAC,CAAC;IACnD,MAAMoC,GAAG,GAAG1D,QAAQ,CAACsD,SAAS,CAAC;IAE/B,IAAI,CAACI,GAAG,EAAE;MACR,OAAO1B,OAAO,CAACS,MAAM,CAAC,IAAIU,KAAK,CAAE,8BAA6BG,SAAU,EAAC,CAAC,CAAC;IAC7E;IAEA,QAAQI,GAAG,CAACC,MAAM;MAChB,KAAK,MAAM;QAAE;UACX,OAAO,IAAI,CAAChC,YAAY,CAAC+B,GAAG,CAAC;QAC/B;MAEA,KAAK,MAAM;MACX,KAAK,OAAO;QAAE;UACZ,MAAME,MAAM,GAAGvD,YAAY,CAAC,IAAI,CAACoB,MAAM,EAAE,IAAI,CAACD,UAAU,CAAC;UACzD,MAAMqC,OAAO,GAAG;YACd,YAAY,EAAE,IAAI,CAACnC,UAAU;YAC7B,iBAAiB,EAAE,IAAI;YACvB,iBAAiB,EAAE,MAAM;YACzB,QAAQ,EAAE6B,MAAM,IAAI;UACtB,CAAC;UACD,IAAIE,QAAQ,IAAI,CAAClD,UAAU,EAAE;YAC3BsD,OAAO,CAACC,OAAO,GAAGL,QAAQ;UAC5B;UACA,MAAMM,aAAa,GAAG,IAAIzD,OAAO,CAC/BgD,SAAS,EACT;YAAEU,eAAe,EAAE,IAAI;YAAER,SAAS;YAAEI;UAAO,CAAC,EAC5C;YAAEC;UAAQ,CAAC,CACZ;UACD,MAAM9B,OAAO,GAAG,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEQ,MAAM,KAAK;YAC/C,MAAMwB,WAAW,GAAG,EAAE;YACtBF,aAAa,CAACG,IAAI,CAAC,UAAU,EAAEC,GAAG,IAAI;cACpCpC,OAAO,CAACqC,QAAQ,GAAGD,GAAG;cACtB,MAAM;gBAAEE;cAAW,CAAC,GAAGF,GAAG;cAC1B;cACA;cACA,IAAIE,UAAU,GAAG,GAAG,IAAIA,UAAU,GAAG,GAAG,EAAE;gBACxCN,aAAa,CAAC3B,KAAK,EAAE;gBACrBK,MAAM,CAAC,IAAIU,KAAK,CAAE,oCAAmCkB,UAAW,EAAC,CAAC,CAAC;cACrE;YACF,CAAC,CAAC;YACFN,aAAa,CAACjB,EAAE,CAAC,MAAM,EAAEC,KAAK,IAAI;cAChCkB,WAAW,CAACK,IAAI,CAACvB,KAAK,CAAC;YACzB,CAAC,CAAC;YACFgB,aAAa,CAACjB,EAAE,CAAC,KAAK,EAAE,MAAMb,OAAO,CAACW,MAAM,CAACI,MAAM,CAACiB,WAAW,CAAC,CAAC,CAAC;YAClEF,aAAa,CAACjB,EAAE,CAAC,OAAO,EAAEL,MAAM,CAAC;UACnC,CAAC,CAAC;UACF;UACA;UACAsB,aAAa,CAACjB,EAAE,CAAC,KAAK,EAAE,MAAM;YAC5Bf,OAAO,CAACwC,IAAI,GAAGR,aAAa,CAACS,UAAU;UACzC,CAAC,CAAC;UACFzC,OAAO,CAACK,KAAK,GAAG2B,aAAa,CAAC3B,KAAK,CAACqC,IAAI,CAACV,aAAa,CAAC;UACvDhC,OAAO,CAAC2C,SAAS,GAAGC,IAAI,IAAId,OAAO,CAACc,IAAI,CAAC,IAAIZ,aAAa,CAACW,SAAS,CAACC,IAAI,CAAC;UAC1EZ,aAAa,CAACa,GAAG,EAAE;UACnB,OAAO7C,OAAO;QAChB;MAEA,KAAK,MAAM;QAAE;UACX,IAAI;YACF,OAAO,IAAI,CAACO,SAAS,CAACvC,aAAa,CAACuD,SAAS,CAAC,CAAC;UACjD,CAAC,CAAC,OAAOuB,CAAC,EAAE;YACV,OAAO7C,OAAO,CAACS,MAAM,CAACoC,CAAC,CAAC;UAC1B;QACF;MAEA;QAAS;UACP,OAAO7C,OAAO,CAACS,MAAM,CAAC,IAAIU,KAAK,CAAE,sBAAqBG,SAAU,wBAAuBI,GAAG,CAACC,MAAO,EAAC,CAAC,CAAC;QACvG;IAAC;EAEL;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}