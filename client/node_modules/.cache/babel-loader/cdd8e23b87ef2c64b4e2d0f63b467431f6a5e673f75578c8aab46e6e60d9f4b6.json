{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\r\n * Swap the elements indexed by `x` and `y` in the array `ary`.\r\n *\r\n * @param {Array} ary\r\n *        The array.\r\n * @param {Number} x\r\n *        The index of the first item.\r\n * @param {Number} y\r\n *        The index of the second item.\r\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\r\n * Returns a random integer within the range `low .. high` inclusive.\r\n *\r\n * @param {Number} low\r\n *        The lower bound on the range.\r\n * @param {Number} high\r\n *        The upper bound on the range.\r\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + Math.random() * (high - low));\n}\n\n/**\r\n * The Quick Sort algorithm.\r\n *\r\n * @param {Array} ary\r\n *        An array to sort.\r\n * @param {function} comparator\r\n *        Function to use to compare two items.\r\n * @param {Number} p\r\n *        Start index of the array\r\n * @param {Number} r\r\n *        End index of the array\r\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\r\n * Sort the given array in-place with the given comparator function.\r\n *\r\n * @param {Array} ary\r\n *        An array to sort.\r\n * @param {function} comparator\r\n *        Function to use to compare two items.\r\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};","map":{"version":3,"names":["swap","ary","x","y","temp","randomIntInRange","low","high","Math","round","random","doQuickSort","comparator","p","r","pivotIndex","i","pivot","j","q","exports","quickSort","length"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/escodegen/node_modules/source-map/lib/quick-sort.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\n// It turns out that some (most?) JavaScript engines don't self-host\r\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\r\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\r\n// custom comparator function, calling back and forth between the VM's C++ and\r\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\r\n// worse generated code for the comparator function than would be optimal. In\r\n// fact, when sorting with a comparator, these costs outweigh the benefits of\r\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\r\n// a ~3500ms mean speed-up in `bench/bench.html`.\r\n\r\n/**\r\n * Swap the elements indexed by `x` and `y` in the array `ary`.\r\n *\r\n * @param {Array} ary\r\n *        The array.\r\n * @param {Number} x\r\n *        The index of the first item.\r\n * @param {Number} y\r\n *        The index of the second item.\r\n */\r\nfunction swap(ary, x, y) {\r\n  var temp = ary[x];\r\n  ary[x] = ary[y];\r\n  ary[y] = temp;\r\n}\r\n\r\n/**\r\n * Returns a random integer within the range `low .. high` inclusive.\r\n *\r\n * @param {Number} low\r\n *        The lower bound on the range.\r\n * @param {Number} high\r\n *        The upper bound on the range.\r\n */\r\nfunction randomIntInRange(low, high) {\r\n  return Math.round(low + (Math.random() * (high - low)));\r\n}\r\n\r\n/**\r\n * The Quick Sort algorithm.\r\n *\r\n * @param {Array} ary\r\n *        An array to sort.\r\n * @param {function} comparator\r\n *        Function to use to compare two items.\r\n * @param {Number} p\r\n *        Start index of the array\r\n * @param {Number} r\r\n *        End index of the array\r\n */\r\nfunction doQuickSort(ary, comparator, p, r) {\r\n  // If our lower bound is less than our upper bound, we (1) partition the\r\n  // array into two pieces and (2) recurse on each half. If it is not, this is\r\n  // the empty array and our base case.\r\n\r\n  if (p < r) {\r\n    // (1) Partitioning.\r\n    //\r\n    // The partitioning chooses a pivot between `p` and `r` and moves all\r\n    // elements that are less than or equal to the pivot to the before it, and\r\n    // all the elements that are greater than it after it. The effect is that\r\n    // once partition is done, the pivot is in the exact place it will be when\r\n    // the array is put in sorted order, and it will not need to be moved\r\n    // again. This runs in O(n) time.\r\n\r\n    // Always choose a random pivot so that an input array which is reverse\r\n    // sorted does not cause O(n^2) running time.\r\n    var pivotIndex = randomIntInRange(p, r);\r\n    var i = p - 1;\r\n\r\n    swap(ary, pivotIndex, r);\r\n    var pivot = ary[r];\r\n\r\n    // Immediately after `j` is incremented in this loop, the following hold\r\n    // true:\r\n    //\r\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\r\n    //\r\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\r\n    for (var j = p; j < r; j++) {\r\n      if (comparator(ary[j], pivot) <= 0) {\r\n        i += 1;\r\n        swap(ary, i, j);\r\n      }\r\n    }\r\n\r\n    swap(ary, i + 1, j);\r\n    var q = i + 1;\r\n\r\n    // (2) Recurse on each half.\r\n\r\n    doQuickSort(ary, comparator, p, q - 1);\r\n    doQuickSort(ary, comparator, q + 1, r);\r\n  }\r\n}\r\n\r\n/**\r\n * Sort the given array in-place with the given comparator function.\r\n *\r\n * @param {Array} ary\r\n *        An array to sort.\r\n * @param {function} comparator\r\n *        Function to use to compare two items.\r\n */\r\nexports.quickSort = function (ary, comparator) {\r\n  doQuickSort(ary, comparator, 0, ary.length - 1);\r\n};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,IAAIA,CAACC,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAE;EACvB,IAAIC,IAAI,GAAGH,GAAG,CAACC,CAAC,CAAC;EACjBD,GAAG,CAACC,CAAC,CAAC,GAAGD,GAAG,CAACE,CAAC,CAAC;EACfF,GAAG,CAACE,CAAC,CAAC,GAAGC,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAACC,GAAG,EAAEC,IAAI,EAAE;EACnC,OAAOC,IAAI,CAACC,KAAK,CAACH,GAAG,GAAIE,IAAI,CAACE,MAAM,EAAE,IAAIH,IAAI,GAAGD,GAAG,CAAE,CAAC;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,WAAWA,CAACV,GAAG,EAAEW,UAAU,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAC1C;EACA;EACA;;EAEA,IAAID,CAAC,GAAGC,CAAC,EAAE;IACT;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA,IAAIC,UAAU,GAAGV,gBAAgB,CAACQ,CAAC,EAAEC,CAAC,CAAC;IACvC,IAAIE,CAAC,GAAGH,CAAC,GAAG,CAAC;IAEbb,IAAI,CAACC,GAAG,EAAEc,UAAU,EAAED,CAAC,CAAC;IACxB,IAAIG,KAAK,GAAGhB,GAAG,CAACa,CAAC,CAAC;;IAElB;IACA;IACA;IACA;IACA;IACA;IACA,KAAK,IAAII,CAAC,GAAGL,CAAC,EAAEK,CAAC,GAAGJ,CAAC,EAAEI,CAAC,EAAE,EAAE;MAC1B,IAAIN,UAAU,CAACX,GAAG,CAACiB,CAAC,CAAC,EAAED,KAAK,CAAC,IAAI,CAAC,EAAE;QAClCD,CAAC,IAAI,CAAC;QACNhB,IAAI,CAACC,GAAG,EAAEe,CAAC,EAAEE,CAAC,CAAC;MACjB;IACF;IAEAlB,IAAI,CAACC,GAAG,EAAEe,CAAC,GAAG,CAAC,EAAEE,CAAC,CAAC;IACnB,IAAIC,CAAC,GAAGH,CAAC,GAAG,CAAC;;IAEb;;IAEAL,WAAW,CAACV,GAAG,EAAEW,UAAU,EAAEC,CAAC,EAAEM,CAAC,GAAG,CAAC,CAAC;IACtCR,WAAW,CAACV,GAAG,EAAEW,UAAU,EAAEO,CAAC,GAAG,CAAC,EAAEL,CAAC,CAAC;EACxC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAM,OAAO,CAACC,SAAS,GAAG,UAAUpB,GAAG,EAAEW,UAAU,EAAE;EAC7CD,WAAW,CAACV,GAAG,EAAEW,UAAU,EAAE,CAAC,EAAEX,GAAG,CAACqB,MAAM,GAAG,CAAC,CAAC;AACjD,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}