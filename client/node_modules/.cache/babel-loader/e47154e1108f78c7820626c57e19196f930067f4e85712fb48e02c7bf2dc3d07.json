{"ast":null,"code":"\"use strict\";\n\nconst {\n  removeLeadingAndTrailingHTTPWhitespace,\n  removeTrailingHTTPWhitespace,\n  isHTTPWhitespaceChar,\n  solelyContainsHTTPTokenCodePoints,\n  soleyContainsHTTPQuotedStringTokenCodePoints,\n  asciiLowercase\n} = require(\"./utils.js\");\nmodule.exports = input => {\n  input = removeLeadingAndTrailingHTTPWhitespace(input);\n  let position = 0;\n  let type = \"\";\n  while (position < input.length && input[position] !== \"/\") {\n    type += input[position];\n    ++position;\n  }\n  if (type.length === 0 || !solelyContainsHTTPTokenCodePoints(type)) {\n    return null;\n  }\n  if (position >= input.length) {\n    return null;\n  }\n\n  // Skips past \"/\"\n  ++position;\n  let subtype = \"\";\n  while (position < input.length && input[position] !== \";\") {\n    subtype += input[position];\n    ++position;\n  }\n  subtype = removeTrailingHTTPWhitespace(subtype);\n  if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints(subtype)) {\n    return null;\n  }\n  const mimeType = {\n    type: asciiLowercase(type),\n    subtype: asciiLowercase(subtype),\n    parameters: new Map()\n  };\n  while (position < input.length) {\n    // Skip past \";\"\n    ++position;\n    while (isHTTPWhitespaceChar(input[position])) {\n      ++position;\n    }\n    let parameterName = \"\";\n    while (position < input.length && input[position] !== \";\" && input[position] !== \"=\") {\n      parameterName += input[position];\n      ++position;\n    }\n    parameterName = asciiLowercase(parameterName);\n    if (position < input.length) {\n      if (input[position] === \";\") {\n        continue;\n      }\n\n      // Skip past \"=\"\n      ++position;\n    }\n    let parameterValue = \"\";\n    if (input[position] === \"\\\"\") {\n      ++position;\n      while (true) {\n        while (position < input.length && input[position] !== \"\\\"\" && input[position] !== \"\\\\\") {\n          parameterValue += input[position];\n          ++position;\n        }\n        if (position < input.length && input[position] === \"\\\\\") {\n          ++position;\n          if (position < input.length) {\n            parameterValue += input[position];\n            ++position;\n            continue;\n          } else {\n            parameterValue += \"\\\\\";\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n      while (position < input.length && input[position] !== \";\") {\n        ++position;\n      }\n    } else {\n      while (position < input.length && input[position] !== \";\") {\n        parameterValue += input[position];\n        ++position;\n      }\n      parameterValue = removeTrailingHTTPWhitespace(parameterValue);\n      if (parameterValue === \"\") {\n        continue;\n      }\n    }\n    if (parameterName.length > 0 && solelyContainsHTTPTokenCodePoints(parameterName) && soleyContainsHTTPQuotedStringTokenCodePoints(parameterValue) && !mimeType.parameters.has(parameterName)) {\n      mimeType.parameters.set(parameterName, parameterValue);\n    }\n  }\n  return mimeType;\n};","map":{"version":3,"names":["removeLeadingAndTrailingHTTPWhitespace","removeTrailingHTTPWhitespace","isHTTPWhitespaceChar","solelyContainsHTTPTokenCodePoints","soleyContainsHTTPQuotedStringTokenCodePoints","asciiLowercase","require","module","exports","input","position","type","length","subtype","mimeType","parameters","Map","parameterName","parameterValue","has","set"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/whatwg-mimetype/lib/parser.js"],"sourcesContent":["\"use strict\";\r\nconst {\r\n  removeLeadingAndTrailingHTTPWhitespace,\r\n  removeTrailingHTTPWhitespace,\r\n  isHTTPWhitespaceChar,\r\n  solelyContainsHTTPTokenCodePoints,\r\n  soleyContainsHTTPQuotedStringTokenCodePoints,\r\n  asciiLowercase\r\n} = require(\"./utils.js\");\r\n\r\nmodule.exports = input => {\r\n  input = removeLeadingAndTrailingHTTPWhitespace(input);\r\n\r\n  let position = 0;\r\n  let type = \"\";\r\n  while (position < input.length && input[position] !== \"/\") {\r\n    type += input[position];\r\n    ++position;\r\n  }\r\n\r\n  if (type.length === 0 || !solelyContainsHTTPTokenCodePoints(type)) {\r\n    return null;\r\n  }\r\n\r\n  if (position >= input.length) {\r\n    return null;\r\n  }\r\n\r\n  // Skips past \"/\"\r\n  ++position;\r\n\r\n  let subtype = \"\";\r\n  while (position < input.length && input[position] !== \";\") {\r\n    subtype += input[position];\r\n    ++position;\r\n  }\r\n\r\n  subtype = removeTrailingHTTPWhitespace(subtype);\r\n\r\n  if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints(subtype)) {\r\n    return null;\r\n  }\r\n\r\n  const mimeType = {\r\n    type: asciiLowercase(type),\r\n    subtype: asciiLowercase(subtype),\r\n    parameters: new Map()\r\n  };\r\n\r\n  while (position < input.length) {\r\n    // Skip past \";\"\r\n    ++position;\r\n\r\n    while (isHTTPWhitespaceChar(input[position])) {\r\n      ++position;\r\n    }\r\n\r\n    let parameterName = \"\";\r\n    while (position < input.length && input[position] !== \";\" && input[position] !== \"=\") {\r\n      parameterName += input[position];\r\n      ++position;\r\n    }\r\n    parameterName = asciiLowercase(parameterName);\r\n\r\n    if (position < input.length) {\r\n      if (input[position] === \";\") {\r\n        continue;\r\n      }\r\n\r\n      // Skip past \"=\"\r\n      ++position;\r\n    }\r\n\r\n    let parameterValue = \"\";\r\n    if (input[position] === \"\\\"\") {\r\n      ++position;\r\n\r\n      while (true) {\r\n        while (position < input.length && input[position] !== \"\\\"\" && input[position] !== \"\\\\\") {\r\n          parameterValue += input[position];\r\n          ++position;\r\n        }\r\n\r\n        if (position < input.length && input[position] === \"\\\\\") {\r\n          ++position;\r\n          if (position < input.length) {\r\n            parameterValue += input[position];\r\n            ++position;\r\n            continue;\r\n          } else {\r\n            parameterValue += \"\\\\\";\r\n            break;\r\n          }\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n\r\n      while (position < input.length && input[position] !== \";\") {\r\n        ++position;\r\n      }\r\n    } else {\r\n      while (position < input.length && input[position] !== \";\") {\r\n        parameterValue += input[position];\r\n        ++position;\r\n      }\r\n\r\n      parameterValue = removeTrailingHTTPWhitespace(parameterValue);\r\n\r\n      if (parameterValue === \"\") {\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if (parameterName.length > 0 &&\r\n        solelyContainsHTTPTokenCodePoints(parameterName) &&\r\n        soleyContainsHTTPQuotedStringTokenCodePoints(parameterValue) &&\r\n        !mimeType.parameters.has(parameterName)) {\r\n      mimeType.parameters.set(parameterName, parameterValue);\r\n    }\r\n  }\r\n\r\n  return mimeType;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}