{"ast":null,"code":"/** Here is yet another implementation of XPath 1.0 in Javascript.\r\n *\r\n * My goal was to make it relatively compact, but as I fixed all the axis bugs\r\n * the axes became more and more complicated. :-(.\r\n *\r\n * I have not implemented namespaces or case-sensitive axes for XML yet.\r\n *\r\n * How to test it in Chrome: You can make a Chrome extension that replaces\r\n * the WebKit XPath parser with this one. But it takes a bit of effort to\r\n * get around isolated world and same-origin restrictions:\r\n * manifest.json:\r\n    {\r\n      \"name\": \"XPathTest\",\r\n      \"version\": \"0.1\",\r\n      \"content_scripts\": [{\r\n        \"matches\": [\"http://localhost/*\"],  // or wildcard host\r\n        \"js\": [\"xpath.js\", \"injection.js\"],\r\n        \"all_frames\": true, \"run_at\": \"document_start\"\r\n      }]\r\n    }\r\n * injection.js:\r\n    // goal: give my xpath object to the website's JS context.\r\n    var script = document.createElement('script');\r\n    script.textContent =\r\n        \"document.addEventListener('xpathextend', function(e) {\\n\" +\r\n        \"  console.log('extending document with xpath...');\\n\" +\r\n        \"  e.detail(window);\" +\r\n        \"});\";\r\n    document.documentElement.appendChild(script);\r\n    document.documentElement.removeChild(script);\r\n    var evt = document.createEvent('CustomEvent');\r\n    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);\r\n    document.dispatchEvent(evt);\r\n */\nmodule.exports = core => {\n  var xpath = {};\n\n  // Helper function to deal with the migration of Attr to no longer have a nodeName property despite this codebase\n  // assuming it does.\n  function getNodeName(nodeOrAttr) {\n    return nodeOrAttr.constructor.name === 'Attr' ? nodeOrAttr.name : nodeOrAttr.nodeName;\n  }\n\n  /***************************************************************************\r\n   *                            Tokenization                                 *\r\n   ***************************************************************************/\n  /**\r\n   * The XPath lexer is basically a single regular expression, along with\r\n   * some helper functions to pop different types.\r\n   */\n  var Stream = xpath.Stream = function Stream(str) {\n    this.original = this.str = str;\n    this.peeked = null;\n    // TODO: not really needed, but supposedly tokenizer also disambiguates\n    // a * b vs. node test *\n    this.prev = null; // for debugging\n    this.prevprev = null;\n  };\n  Stream.prototype = {\n    peek: function () {\n      if (this.peeked) return this.peeked;\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      this.str = this.str.substr(m[0].length);\n      return this.peeked = m[1];\n    },\n    /** Peek 2 tokens ahead. */\n    peek2: function () {\n      this.peek(); // make sure this.peeked is set\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      return m[1];\n    },\n    pop: function () {\n      var r = this.peek();\n      this.peeked = null;\n      this.prevprev = this.prev;\n      this.prev = r;\n      return r;\n    },\n    trypop: function (tokens) {\n      var tok = this.peek();\n      if (tok === tokens) return this.pop();\n      if (Array.isArray(tokens)) {\n        for (var i = 0; i < tokens.length; ++i) {\n          var t = tokens[i];\n          if (t == tok) return this.pop();\n          ;\n        }\n      }\n    },\n    trypopfuncname: function () {\n      var tok = this.peek();\n      if (!this.isQnameRe.test(tok)) return null;\n      switch (tok) {\n        case 'comment':\n        case 'text':\n        case 'processing-instruction':\n        case 'node':\n          return null;\n      }\n      if ('(' != this.peek2()) return null;\n      return this.pop();\n    },\n    trypopaxisname: function () {\n      var tok = this.peek();\n      switch (tok) {\n        case 'ancestor':\n        case 'ancestor-or-self':\n        case 'attribute':\n        case 'child':\n        case 'descendant':\n        case 'descendant-or-self':\n        case 'following':\n        case 'following-sibling':\n        case 'namespace':\n        case 'parent':\n        case 'preceding':\n        case 'preceding-sibling':\n        case 'self':\n          if ('::' == this.peek2()) return this.pop();\n      }\n      return null;\n    },\n    trypopnametest: function () {\n      var tok = this.peek();\n      if ('*' === tok || this.startsWithNcNameRe.test(tok)) return this.pop();\n      return null;\n    },\n    trypopliteral: function () {\n      var tok = this.peek();\n      if (null == tok) return null;\n      var first = tok.charAt(0);\n      var last = tok.charAt(tok.length - 1);\n      if ('\"' === first && '\"' === last || \"'\" === first && \"'\" === last) {\n        this.pop();\n        return tok.substr(1, tok.length - 2);\n      }\n    },\n    trypopnumber: function () {\n      var tok = this.peek();\n      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());else return null;\n    },\n    trypopvarref: function () {\n      var tok = this.peek();\n      if (null == tok) return null;\n      if ('$' === tok.charAt(0)) return this.pop().substr(1);else return null;\n    },\n    position: function () {\n      return this.original.length - this.str.length;\n    }\n  };\n  (function () {\n    // http://www.w3.org/TR/REC-xml-names/#NT-NCName\n    var nameStartCharsExceptColon = 'A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF' + '\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF' + '\\uFDF0-\\uFFFD'; // JS doesn't support [#x10000-#xEFFFF]\n    var nameCharExceptColon = nameStartCharsExceptColon + '\\\\-\\\\.0-9\\xb7\\u0300-\\u036F\\u203F-\\u2040';\n    var ncNameChars = '[' + nameStartCharsExceptColon + '][' + nameCharExceptColon + ']*';\n    // http://www.w3.org/TR/REC-xml-names/#NT-QName\n    var qNameChars = ncNameChars + '(?::' + ncNameChars + ')?';\n    var otherChars = '\\\\.\\\\.|[\\\\(\\\\)\\\\[\\\\].@,]|::'; // .. must come before [.]\n    var operatorChars = 'and|or|mod|div|' + '//|!=|<=|>=|[*/|+\\\\-=<>]'; // //, !=, <=, >= before individual ones.\n    var literal = '\"[^\"]*\"|' + \"'[^']*'\";\n    var numberChars = '[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9]+';\n    var variableReference = '\\\\$' + qNameChars;\n    var nameTestChars = '\\\\*|' + ncNameChars + ':\\\\*|' + qNameChars;\n    var optionalSpace = '[ \\t\\r\\n]*'; // stricter than regexp \\s.\n    var nodeType = 'comment|text|processing-instruction|node';\n    var re = new RegExp(\n    // numberChars before otherChars so that leading-decimal doesn't become .\n    '^' + optionalSpace + '(' + numberChars + '|' + otherChars + '|' + nameTestChars + '|' + operatorChars + '|' + literal + '|' + variableReference + ')'\n    // operatorName | nodeType | functionName | axisName are lumped into\n    // qName for now; we'll check them on pop.\n    );\n\n    Stream.prototype.re = re;\n    Stream.prototype.startsWithNcNameRe = new RegExp('^' + ncNameChars);\n    Stream.prototype.isQnameRe = new RegExp('^' + qNameChars + '$');\n    Stream.prototype.isNumberRe = new RegExp('^' + numberChars + '$');\n  })();\n\n  /***************************************************************************\r\n   *                               Parsing                                   *\r\n   ***************************************************************************/\n  var parse = xpath.parse = function parse(stream, a) {\n    var r = orExpr(stream, a);\n    var x,\n      unparsed = [];\n    while (x = stream.pop()) {\n      unparsed.push(x);\n    }\n    if (unparsed.length) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Unparsed tokens: ' + unparsed.join(' '));\n    return r;\n  };\n\n  /**\r\n   * binaryL  ::= subExpr\r\n   *            | binaryL op subExpr\r\n   * so a op b op c becomes ((a op b) op c)\r\n   */\n  function binaryL(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op;\n    while (op = stream.trypop(ops)) {\n      var rhs = subExpr(stream, a);\n      if (rhs == null) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected something after ' + op);\n      lhs = a.node(op, lhs, rhs);\n    }\n    return lhs;\n  }\n  /**\r\n   * Too bad this is never used. If they made a ** operator (raise to power),\r\n   ( we would use it.\r\n   * binaryR  ::= subExpr\r\n   *            | subExpr op binaryR\r\n   * so a op b op c becomes (a op (b op c))\r\n   */\n  function binaryR(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op = stream.trypop(ops);\n    if (op) {\n      var rhs = binaryR(stream, a);\n      if (rhs == null) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected something after ' + op);\n      return a.node(op, lhs, rhs);\n    } else {\n      return lhs; // TODO\n    }\n  }\n  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath\r\n   * e.g. a, a/b, //a/b\r\n   */\n  function locationPath(stream, a) {\n    return absoluteLocationPath(stream, a) || relativeLocationPath(null, stream, a);\n  }\n  /** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath\r\n   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath\r\n   */\n  function absoluteLocationPath(stream, a) {\n    var op = stream.peek();\n    if ('/' === op || '//' === op) {\n      var lhs = a.node('Root');\n      return relativeLocationPath(lhs, stream, a, true);\n    } else {\n      return null;\n    }\n  }\n  /** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |\r\n   *                            | AbbreviatedRelativeLocationPath\r\n   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step\r\n   * e.g. p/a, etc.\r\n   */\n  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {\n    if (null == lhs) {\n      lhs = step(stream, a);\n      if (null == lhs) return lhs;\n    }\n    var op;\n    while (op = stream.trypop(['/', '//'])) {\n      if ('//' === op) {\n        lhs = a.node('/', lhs, a.node('Axis', 'descendant-or-self', 'node', undefined));\n      }\n      var rhs = step(stream, a);\n      if (null == rhs && '/' === op && isOnlyRootOk) return lhs;else isOnlyRootOk = false;\n      if (null == rhs) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected step after ' + op);\n      lhs = a.node('/', lhs, rhs);\n    }\n    return lhs;\n  }\n  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep\r\n   *  [12] AbbreviatedStep::= '.' | '..'\r\n   * e.g. @href, self::p, p, a[@href], ., ..\r\n   */\n  function step(stream, a) {\n    var abbrStep = stream.trypop(['.', '..']);\n    if ('.' === abbrStep)\n      // A location step of . is short for self::node().\n      return a.node('Axis', 'self', 'node');\n    if ('..' === abbrStep)\n      // A location step of .. is short for parent::node()\n      return a.node('Axis', 'parent', 'node');\n    var axis = axisSpecifier(stream, a);\n    var nodeType = nodeTypeTest(stream, a);\n    var nodeName;\n    if (null == nodeType) nodeName = nodeNameTest(stream, a);\n    if (null == axis && null == nodeType && null == nodeName) return null;\n    if (null == nodeType && null == nodeName) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected nodeTest after axisSpecifier ' + axis);\n    if (null == axis) axis = 'child';\n    if (null == nodeType) {\n      // When there's only a node name, then the node type is forced to be the\n      // principal node type of the axis.\n      // see http://www.w3.org/TR/xpath/#dt-principal-node-type\n      if ('attribute' === axis) nodeType = 'attribute';else if ('namespace' === axis) nodeType = 'namespace';else nodeType = 'element';\n    }\n    var lhs = a.node('Axis', axis, nodeType, nodeName);\n    var pred;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n  /** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier\r\n   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'\r\n   *                | 'descendant' | 'descendant-or-self' | 'following'\r\n   *                | 'following-sibling' | 'namespace' | 'parent' |\r\n   *                | 'preceding' | 'preceding-sibling' | 'self'\r\n   *  [13] AbbreviatedAxisSpecifier::= '@'?\r\n   */\n  function axisSpecifier(stream, a) {\n    var attr = stream.trypop('@');\n    if (null != attr) return 'attribute';\n    var axisName = stream.trypopaxisname();\n    if (null != axisName) {\n      var coloncolon = stream.trypop('::');\n      if (null == coloncolon) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Should not happen. Should be ::.');\n      return axisName;\n    }\n  }\n  /** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'\r\n   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'\r\n   * I've split nodeTypeTest from nodeNameTest for convenience.\r\n   */\n  function nodeTypeTest(stream, a) {\n    if ('(' !== stream.peek2()) {\n      return null;\n    }\n    var type = stream.trypop(['comment', 'text', 'processing-instruction', 'node']);\n    if (null != type) {\n      if (null == stream.trypop('(')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Should not happen.');\n      var param = undefined;\n      if (type == 'processing-instruction') {\n        param = stream.trypopliteral();\n      }\n      if (null == stream.trypop(')')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected close parens.');\n      return type;\n    }\n  }\n  function nodeNameTest(stream, a) {\n    var name = stream.trypopnametest();\n    if (name != null) return name;else return null;\n  }\n  /** [8] Predicate::= '[' PredicateExpr ']'\r\n   *  [9] PredicateExpr::= Expr\r\n   */\n  function predicate(lhs, stream, a) {\n    if (null == stream.trypop('[')) return null;\n    var expr = orExpr(stream, a);\n    if (null == expr) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected expression after [');\n    if (null == stream.trypop(']')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected ] after expression.');\n    return a.node('Predicate', lhs, expr);\n  }\n  /** [14] Expr::= OrExpr\r\n   */\n  /** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall\r\n   * e.g. $x,  (3+4),  \"hi\",  32,  f(x)\r\n   */\n  function primaryExpr(stream, a) {\n    var x = stream.trypopliteral();\n    if (null == x) x = stream.trypopnumber();\n    if (null != x) {\n      return x;\n    }\n    var varRef = stream.trypopvarref();\n    if (null != varRef) return a.node('VariableReference', varRef);\n    var funCall = functionCall(stream, a);\n    if (null != funCall) {\n      return funCall;\n    }\n    if (stream.trypop('(')) {\n      var e = orExpr(stream, a);\n      if (null == e) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected expression after (.');\n      if (null == stream.trypop(')')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected ) after expression.');\n      return e;\n    }\n    return null;\n  }\n  /** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'\r\n   *  [17] Argument::= Expr\r\n   */\n  function functionCall(stream, a) {\n    var name = stream.trypopfuncname(stream, a);\n    if (null == name) return null;\n    if (null == stream.trypop('(')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected ( ) after function name.');\n    var params = [];\n    var first = true;\n    while (null == stream.trypop(')')) {\n      if (!first && null == stream.trypop(',')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected , between arguments of the function.');\n      first = false;\n      var param = orExpr(stream, a);\n      if (param == null) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected expression as argument of function.');\n      params.push(param);\n    }\n    return a.node('FunctionCall', name, params);\n  }\n\n  /** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr\r\n   */\n  function unionExpr(stream, a) {\n    return binaryL(pathExpr, stream, a, '|');\n  }\n  /** [19] PathExpr ::= LocationPath\r\n   *                  | FilterExpr\r\n   *                  | FilterExpr '/' RelativeLocationPath\r\n   *                  | FilterExpr '//' RelativeLocationPath\r\n   * Unlike most other nodes, this one always generates a node because\r\n   * at this point all reverse nodesets must turn into a forward nodeset\r\n   */\n  function pathExpr(stream, a) {\n    // We have to do FilterExpr before LocationPath because otherwise\n    // LocationPath will eat up the name from a function call.\n    var filter = filterExpr(stream, a);\n    if (null == filter) {\n      var loc = locationPath(stream, a);\n      if (null == loc) {\n        throw new Error();\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': The expression shouldn\\'t be empty...');\n      }\n      return a.node('PathExpr', loc);\n    }\n    var rel = relativeLocationPath(filter, stream, a, false);\n    if (filter === rel) return rel;else return a.node('PathExpr', rel);\n  }\n  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate\r\n   * aka. FilterExpr ::= PrimaryExpr Predicate*\r\n   */\n  function filterExpr(stream, a) {\n    var primary = primaryExpr(stream, a);\n    if (primary == null) return null;\n    var pred,\n      lhs = primary;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n\n  /** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr\r\n   */\n  function orExpr(stream, a) {\n    var orig = (stream.peeked || '') + stream.str;\n    var r = binaryL(andExpr, stream, a, 'or');\n    var now = (stream.peeked || '') + stream.str;\n    return r;\n  }\n  /** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr\r\n   */\n  function andExpr(stream, a) {\n    return binaryL(equalityExpr, stream, a, 'and');\n  }\n  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr\r\n   *                     | EqualityExpr '!=' RelationalExpr\r\n   */\n  function equalityExpr(stream, a) {\n    return binaryL(relationalExpr, stream, a, ['=', '!=']);\n  }\n  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '<' AdditiveExpr\r\n   *                       | RelationalExpr '>' AdditiveExpr\r\n   *                       | RelationalExpr '<=' AdditiveExpr\r\n   *                       | RelationalExpr '>=' AdditiveExpr\r\n   */\n  function relationalExpr(stream, a) {\n    return binaryL(additiveExpr, stream, a, ['<', '>', '<=', '>=']);\n  }\n  /** [25] AdditiveExpr::= MultiplicativeExpr\r\n   *                     | AdditiveExpr '+' MultiplicativeExpr\r\n   *                     | AdditiveExpr '-' MultiplicativeExpr\r\n   */\n  function additiveExpr(stream, a) {\n    return binaryL(multiplicativeExpr, stream, a, ['+', '-']);\n  }\n  /** [26] MultiplicativeExpr::= UnaryExpr\r\n   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr\r\n   *                           | MultiplicativeExpr 'div' UnaryExpr\r\n   *                           | MultiplicativeExpr 'mod' UnaryExpr\r\n   */\n  function multiplicativeExpr(stream, a) {\n    return binaryL(unaryExpr, stream, a, ['*', 'div', 'mod']);\n  }\n  /** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr\r\n   */\n  function unaryExpr(stream, a) {\n    if (stream.trypop('-')) {\n      var e = unaryExpr(stream, a);\n      if (null == e) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected unary expression after -');\n      return a.node('UnaryMinus', e);\n    } else return unionExpr(stream, a);\n  }\n  var astFactory = {\n    node: function () {\n      return Array.prototype.slice.call(arguments);\n    }\n  };\n\n  /***************************************************************************\r\n   *                            Optimizations (TODO)                         *\r\n   ***************************************************************************/\n  /**\r\n   * Some things I've been considering:\r\n   * 1) a//b becomes a/descendant::b if there's no predicate that uses\r\n   *    position() or last()\r\n   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per\r\n   *    node in the node-set rather than once per (node, position, last).\r\n   * For more optimizations, look up Gecko's optimizer:\r\n   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp\r\n   */\n  // TODO\n  function optimize(ast) {}\n\n  /***************************************************************************\r\n   *                           Evaluation: axes                              *\r\n   ***************************************************************************/\n\n  /**\r\n   * Data types: For string, number, boolean, we just use Javascript types.\r\n   * Node-sets have the form\r\n   *    {nodes: [node, ...]}\r\n   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}\r\n   *\r\n   * Most of the time, only the node is used and the position information is\r\n   * discarded. But if you use a predicate, we need to try every value of\r\n   * position and last in case the predicate calls position() or last().\r\n   */\n\n  /**\r\n   * The NodeMultiSet is a helper class to help generate\r\n   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the\r\n   * descendant, descendant-or-self, following-sibling, and\r\n   * preceding-sibling axes for which we can use a stack to organize things.\r\n   */\n  function NodeMultiSet(isReverseAxis) {\n    this.nodes = [];\n    this.pos = [];\n    this.lasts = [];\n    this.nextPos = [];\n    this.seriesIndexes = []; // index within nodes that each series begins.\n    this.isReverseAxis = isReverseAxis;\n    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;\n  }\n  NodeMultiSet.prototype = {\n    pushSeries: function pushSeries() {\n      this.nextPos.push(1);\n      this.seriesIndexes.push(this.nodes.length);\n    },\n    popSeries: function popSeries() {\n      console.assert(0 < this.nextPos.length, this.nextPos);\n      var last = this.nextPos.pop() - 1,\n        indexInPos = this.nextPos.length,\n        seriesBeginIndex = this.seriesIndexes.pop(),\n        seriesEndIndex = this.nodes.length;\n      for (var i = seriesBeginIndex; i < seriesEndIndex; ++i) {\n        console.assert(indexInPos < this.lasts[i].length);\n        console.assert(undefined === this.lasts[i][indexInPos]);\n        this.lasts[i][indexInPos] = last;\n      }\n    },\n    finalize: function () {\n      if (null == this.nextPos) return this;\n      console.assert(0 === this.nextPos.length);\n      var lastsJSON = JSON.stringify(this.lasts);\n      for (var i = 0; i < this.lasts.length; ++i) {\n        for (var j = 0; j < this.lasts[i].length; ++j) {\n          console.assert(null != this.lasts[i][j], i + ',' + j + ':' + lastsJSON);\n        }\n      }\n      this.pushSeries = this.popSeries = this.addNode = function () {\n        throw new Error('Already finalized.');\n      };\n      return this;\n    },\n    addNode: function addNode(node) {\n      console.assert(node);\n      this._pushToNodes.call(this.nodes, node);\n      this._pushToNodes.call(this.pos, this.nextPos.slice());\n      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));\n      for (var i = 0; i < this.nextPos.length; ++i) this.nextPos[i]++;\n    },\n    simplify: function () {\n      this.finalize();\n      return {\n        nodes: this.nodes,\n        pos: this.pos,\n        lasts: this.lasts\n      };\n    }\n  };\n  function eachContext(nodeMultiSet) {\n    var r = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var node = nodeMultiSet.nodes[i];\n      if (!nodeMultiSet.pos) {\n        r.push({\n          nodes: [node],\n          pos: [[i + 1]],\n          lasts: [[nodeMultiSet.nodes.length]]\n        });\n      } else {\n        for (var j = 0; j < nodeMultiSet.pos[i].length; ++j) {\n          r.push({\n            nodes: [node],\n            pos: [[nodeMultiSet.pos[i][j]]],\n            lasts: [[nodeMultiSet.lasts[i][j]]]\n          });\n        }\n      }\n    }\n    return r;\n  }\n  /** Matcher used in the axes.\r\n   */\n  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {\n    this.nodeTypeNum = nodeTypeNum;\n    this.nodeName = nodeName;\n    this.shouldLowerCase = shouldLowerCase;\n    this.nodeNameTest = null == nodeName ? this._alwaysTrue : shouldLowerCase ? this._nodeNameLowerCaseEquals : this._nodeNameEquals;\n  }\n  NodeMatcher.prototype = {\n    matches: function matches(node) {\n      if (0 === this.nodeTypeNum || this._nodeTypeMatches(node)) {\n        return this.nodeNameTest(getNodeName(node));\n      }\n      return false;\n    },\n    _nodeTypeMatches(nodeOrAttr) {\n      if (nodeOrAttr.constructor.name === 'Attr' && this.nodeTypeNum === 2) {\n        return true;\n      }\n      return nodeOrAttr.nodeType === this.nodeTypeNum;\n    },\n    _alwaysTrue: function (name) {\n      return true;\n    },\n    _nodeNameEquals: function _nodeNameEquals(name) {\n      return this.nodeName === name;\n    },\n    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {\n      return this.nodeName === name.toLowerCase();\n    }\n  };\n  function followingSiblingHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(isReverseAxis);\n    while (0 < nodeList.length) {\n      // can be if for following, preceding\n      var node = shift.call(nodeList);\n      console.assert(node != null);\n      node = followingNode(node);\n      nodeMultiSet.pushSeries();\n      var numPushed = 1;\n      while (null != node) {\n        if (!andSelf && matcher.matches(node)) nodeMultiSet.addNode(node);\n        if (node === peek.call(nodeList)) {\n          shift.call(nodeList);\n          nodeMultiSet.pushSeries();\n          numPushed++;\n        }\n        if (andSelf && matcher.matches(node)) nodeMultiSet.addNode(node);\n        node = followingNode(node);\n      }\n      while (0 < numPushed--) nodeMultiSet.popSeries();\n    }\n    return nodeMultiSet;\n  }\n\n  /** Returns the next non-descendant node in document order.\r\n   * This is the first node in following::node(), if node is the context.\r\n   */\n  function followingNonDescendantNode(node) {\n    if (node.ownerElement) {\n      if (node.ownerElement.firstChild) return node.ownerElement.firstChild;\n      node = node.ownerElement;\n    }\n    do {\n      if (node.nextSibling) return node.nextSibling;\n    } while (node = node.parentNode);\n    return null;\n  }\n\n  /** Returns the next node in a document-order depth-first search.\r\n   * See the definition of document order[1]:\r\n   *   1) element\r\n   *   2) namespace nodes\r\n   *   3) attributes\r\n   *   4) children\r\n   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order\r\n   */\n  function followingNode(node) {\n    if (node.ownerElement)\n      // attributes: following node of element.\n      node = node.ownerElement;\n    if (null != node.firstChild) return node.firstChild;\n    do {\n      if (null != node.nextSibling) {\n        return node.nextSibling;\n      }\n      node = node.parentNode;\n    } while (node);\n    return null;\n  }\n  /** Returns the previous node in document order (excluding attributes\r\n   * and namespace nodes).\r\n   */\n  function precedingNode(node) {\n    if (node.ownerElement) return node.ownerElement;\n    if (null != node.previousSibling) {\n      node = node.previousSibling;\n      while (null != node.lastChild) {\n        node = node.lastChild;\n      }\n      return node;\n    }\n    if (null != node.parentNode) {\n      return node.parentNode;\n    }\n    return null;\n  }\n  /** This axis is inefficient if there are many nodes in the nodeList.\r\n   * But I think it's a pretty useless axis so it's ok. */\n  function followingHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var cursor = nodeList[0];\n    var unorderedFollowingStarts = [];\n    for (var i = 0; i < nodeList.length; i++) {\n      var node = nodeList[i];\n      var start = followingNonDescendantNode(node);\n      if (start) unorderedFollowingStarts.push(start);\n    }\n    if (0 === unorderedFollowingStarts.length) return {\n      nodes: []\n    };\n    var pos = [],\n      nextPos = [];\n    var started = 0;\n    while (cursor = followingNode(cursor)) {\n      for (var i = unorderedFollowingStarts.length - 1; i >= 0; i--) {\n        if (cursor === unorderedFollowingStarts[i]) {\n          nodeMultiSet.pushSeries();\n          unorderedFollowingStarts.splice(i, i + 1);\n          started++;\n        }\n      }\n      if (started && matcher.matches(cursor)) {\n        nodeMultiSet.addNode(cursor);\n      }\n    }\n    console.assert(0 === unorderedFollowingStarts.length);\n    for (var i = 0; i < started; i++) nodeMultiSet.popSeries();\n    return nodeMultiSet.finalize();\n  }\n  function precedingHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var cursor = nodeList.pop();\n    if (null == cursor) return {\n      nodes: {}\n    };\n    var r = {\n      nodes: [],\n      pos: [],\n      lasts: []\n    };\n    var nextParents = [cursor.parentNode || cursor.ownerElement],\n      nextPos = [1];\n    while (cursor = precedingNode(cursor)) {\n      if (cursor === nodeList[nodeList.length - 1]) {\n        nextParents.push(nodeList.pop());\n        nextPos.push(1);\n      }\n      var matches = matcher.matches(cursor);\n      var pos,\n        someoneUsed = false;\n      if (matches) pos = nextPos.slice();\n      for (var i = 0; i < nextParents.length; ++i) {\n        if (cursor === nextParents[i]) {\n          nextParents[i] = cursor.parentNode || cursor.ownerElement;\n          if (matches) {\n            pos[i] = null;\n          }\n        } else {\n          if (matches) {\n            pos[i] = nextPos[i]++;\n            someoneUsed = true;\n          }\n        }\n      }\n      if (someoneUsed) {\n        r.nodes.unshift(cursor);\n        r.pos.unshift(pos);\n      }\n    }\n    for (var i = 0; i < r.pos.length; ++i) {\n      var lasts = [];\n      r.lasts.push(lasts);\n      for (var j = r.pos[i].length - 1; j >= 0; j--) {\n        if (null == r.pos[i][j]) {\n          r.pos[i].splice(j, j + 1);\n        } else {\n          lasts.unshift(nextPos[j] - 1);\n        }\n      }\n    }\n    return r;\n  }\n\n  /** node-set, axis -> node-set */\n  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {\n    while (0 < remaining.length && null != remaining[0].ownerElement) {\n      var attr = remaining.shift();\n      if (andSelf && matcher.matches(attr)) {\n        attrNodes.push(attr);\n        attrIndices.push(nodeMultiSet.nodes.length);\n      }\n    }\n    if (null != node && !andSelf) {\n      if (matcher.matches(node)) nodeMultiSet.addNode(node);\n    }\n    var pushed = false;\n    if (null == node) {\n      if (0 === remaining.length) return;\n      node = remaining.shift();\n      nodeMultiSet.pushSeries();\n      pushed = true;\n    } else if (0 < remaining.length && node === remaining[0]) {\n      nodeMultiSet.pushSeries();\n      pushed = true;\n      remaining.shift();\n    }\n    if (andSelf) {\n      if (matcher.matches(node)) nodeMultiSet.addNode(node);\n    }\n    // TODO: use optimization. Also try element.getElementsByTagName\n    // var nodeList = 1 === nodeTypeNum && null != node.children ? node.children : node.childNodes;\n    var nodeList = node.childNodes;\n    for (var j = 0; j < nodeList.length; ++j) {\n      var child = nodeList[j];\n      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);\n    }\n    if (pushed) {\n      nodeMultiSet.popSeries();\n    }\n  }\n  function descenantHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var attrIndices = [],\n      attrNodes = [];\n    while (0 < nodeList.length) {\n      // var node = nodeList.shift();\n      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);\n    }\n    nodeMultiSet.finalize();\n    for (var i = attrNodes.length - 1; i >= 0; --i) {\n      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);\n      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);\n      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);\n    }\n    return nodeMultiSet;\n  }\n  /**\r\n   */\n  function ancestorHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var ancestors = []; // array of non-empty arrays of matching ancestors\n    for (var i = 0; i < nodeList.length; ++i) {\n      var node = nodeList[i];\n      var isFirst = true;\n      var a = [];\n      while (null != node) {\n        if (!isFirst || andSelf) {\n          if (matcher.matches(node)) a.push(node);\n        }\n        isFirst = false;\n        node = node.parentNode || node.ownerElement;\n      }\n      if (0 < a.length) ancestors.push(a);\n    }\n    var lasts = [];\n    for (var i = 0; i < ancestors.length; ++i) lasts.push(ancestors[i].length);\n    var nodeMultiSet = new NodeMultiSet(true);\n    var newCtx = {\n      nodes: [],\n      pos: [],\n      lasts: []\n    };\n    while (0 < ancestors.length) {\n      var pos = [ancestors[0].length];\n      var last = [lasts[0]];\n      var node = ancestors[0].pop();\n      for (var i = ancestors.length - 1; i > 0; --i) {\n        if (node === ancestors[i][ancestors[i].length - 1]) {\n          pos.push(ancestors[i].length);\n          last.push(lasts[i]);\n          ancestors[i].pop();\n          if (0 === ancestors[i].length) {\n            ancestors.splice(i, i + 1);\n            lasts.splice(i, i + 1);\n          }\n        }\n      }\n      if (0 === ancestors[0].length) {\n        ancestors.shift();\n        lasts.shift();\n      }\n      newCtx.nodes.push(node);\n      newCtx.pos.push(pos);\n      newCtx.lasts.push(last);\n    }\n    return newCtx;\n  }\n  /** Helper function for sortDocumentOrder. Returns a list of indices, from the\r\n   * node to the root, of positions within parent.\r\n   * For convenience, the node is the first element of the array.\r\n   */\n  function addressVector(node) {\n    var r = [node];\n    if (null != node.ownerElement) {\n      node = node.ownerElement;\n      r.push(-1);\n    }\n    while (null != node) {\n      var i = 0;\n      while (null != node.previousSibling) {\n        node = node.previousSibling;\n        i++;\n      }\n      r.push(i);\n      node = node.parentNode;\n    }\n    return r;\n  }\n  function addressComparator(a, b) {\n    var minlen = Math.min(a.length - 1, b.length - 1),\n      // not including [0]=node\n      alen = a.length,\n      blen = b.length;\n    if (a[0] === b[0]) return 0;\n    var c;\n    for (var i = 0; i < minlen; ++i) {\n      c = a[alen - i - 1] - b[blen - i - 1];\n      if (0 !== c) break;\n    }\n    if (null == c || 0 === c) {\n      // All equal until one of the nodes. The longer one is the descendant.\n      c = alen - blen;\n    }\n    if (0 === c) c = getNodeName(a) - getNodeName(b);\n    if (0 === c) c = 1;\n    return c;\n  }\n  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function (nodes) {\n    var a = [];\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var v = addressVector(node);\n      a.push(v);\n    }\n    a.sort(addressComparator);\n    var b = [];\n    for (var i = 0; i < a.length; i++) {\n      if (0 < i && a[i][0] === a[i - 1][0]) continue;\n      b.push(a[i][0]);\n    }\n    return b;\n  };\n  /** Sort node multiset. Does not do any de-duping. */\n  function sortNodeMultiSet(nodeMultiSet) {\n    var a = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var v = addressVector(nodeMultiSet.nodes[i]);\n      a.push({\n        v: v,\n        n: nodeMultiSet.nodes[i],\n        p: nodeMultiSet.pos[i],\n        l: nodeMultiSet.lasts[i]\n      });\n    }\n    a.sort(compare);\n    var r = {\n      nodes: [],\n      pos: [],\n      lasts: []\n    };\n    for (var i = 0; i < a.length; ++i) {\n      r.nodes.push(a[i].n);\n      r.pos.push(a[i].p);\n      r.lasts.push(a[i].l);\n    }\n    function compare(x, y) {\n      return addressComparator(x.v, y.v);\n    }\n    return r;\n  }\n  /** Returns an array containing all the ancestors down to a node.\r\n   * The array starts with document.\r\n   */\n  function nodeAndAncestors(node) {\n    var ancestors = [node];\n    var p = node;\n    while (p = p.parentNode || p.ownerElement) {\n      ancestors.unshift(p);\n    }\n    return ancestors;\n  }\n  function compareSiblings(a, b) {\n    if (a === b) return 0;\n    var c = a;\n    while (c = c.previousSibling) {\n      if (c === b) return 1; // b < a\n    }\n\n    c = b;\n    while (c = c.previousSibling) {\n      if (c === a) return -1; // a < b\n    }\n\n    throw new Error('a and b are not siblings: ' + xpath.stringifyObject(a) + ' vs ' + xpath.stringifyObject(b));\n  }\n  /** The merge in merge-sort.*/\n  function mergeNodeLists(x, y) {\n    var a,\n      b,\n      aanc,\n      banc,\n      r = [];\n    if ('object' !== typeof x) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Invalid LHS for | operator ' + '(expected node-set): ' + x);\n    if ('object' !== typeof y) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Invalid LHS for | operator ' + '(expected node-set): ' + y);\n    while (true) {\n      if (null == a) {\n        a = x.shift();\n        if (null != a) aanc = addressVector(a);\n      }\n      if (null == b) {\n        b = y.shift();\n        if (null != b) banc = addressVector(b);\n      }\n      if (null == a || null == b) break;\n      var c = addressComparator(aanc, banc);\n      if (c < 0) {\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (c > 0) {\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (getNodeName(a) < getNodeName(b)) {\n        // attributes\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (getNodeName(a) > getNodeName(b)) {\n        // attributes\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a !== b) {\n        // choose b arbitrarily\n        r.push(b);\n        b = null;\n        banc = null;\n      } else {\n        console.assert(a === b, c);\n        // just skip b without pushing it.\n        b = null;\n        banc = null;\n      }\n    }\n    while (a) {\n      r.push(a);\n      a = x.shift();\n    }\n    while (b) {\n      r.push(b);\n      b = y.shift();\n    }\n    return r;\n  }\n  function comparisonHelper(test, x, y, isNumericComparison) {\n    var coersion;\n    if (isNumericComparison) coersion = fn.number;else coersion = 'boolean' === typeof x || 'boolean' === typeof y ? fn['boolean'] : 'number' === typeof x || 'number' === typeof y ? fn.number : fn.string;\n    if ('object' === typeof x && 'object' === typeof y) {\n      var aMap = {};\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({\n          nodes: [x.nodes[i]]\n        });\n        for (var j = 0; j < y.nodes.length; ++j) {\n          var yj = coersion({\n            nodes: [y.nodes[j]]\n          });\n          if (test(xi, yj)) return true;\n        }\n      }\n      return false;\n    } else if ('object' === typeof x && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({\n            nodes: [x.nodes[i]]\n          }),\n          yc = coersion(y);\n        if (test(xi, yc)) return true;\n      }\n      return false;\n    } else if ('object' === typeof y && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var yi = coersion({\n            nodes: [y.nodes[i]]\n          }),\n          xc = coersion(x);\n        if (test(xc, yi)) return true;\n      }\n      return false;\n    } else {\n      var xc = coersion(x),\n        yc = coersion(y);\n      return test(xc, yc);\n    }\n  }\n  var axes = xpath.axes = {\n    'ancestor': function ancestor(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      return ancestorHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n    },\n    'ancestor-or-self': function ancestorOrSelf(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      return ancestorHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n    },\n    'attribute': function attribute(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      // TODO: figure out whether positions should be undefined here.\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n      var nodeMultiSet = new NodeMultiSet(false);\n      if (null != nodeName) {\n        // TODO: with namespace\n        for (var i = 0; i < nodeList.length; ++i) {\n          var node = nodeList[i];\n          if (null == node.getAttributeNode) continue; // only Element has .getAttributeNode\n          var attr = node.getAttributeNode(nodeName);\n          if (null != attr && matcher.matches(attr)) {\n            nodeMultiSet.pushSeries();\n            nodeMultiSet.addNode(attr);\n            nodeMultiSet.popSeries();\n          }\n        }\n      } else {\n        for (var i = 0; i < nodeList.length; ++i) {\n          var node = nodeList[i];\n          if (null != node.attributes) {\n            nodeMultiSet.pushSeries();\n            for (var j = 0; j < node.attributes.length; j++) {\n              // all nodes have .attributes\n              var attr = node.attributes[j];\n              if (matcher.matches(attr))\n                // TODO: I think this check is unnecessary\n                nodeMultiSet.addNode(attr);\n            }\n            nodeMultiSet.popSeries();\n          }\n        }\n      }\n      return nodeMultiSet.finalize();\n    },\n    'child': function child(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n      var nodeMultiSet = new NodeMultiSet(false);\n      for (var i = 0; i < nodeList.length; ++i) {\n        var n = nodeList[i];\n        if (n.ownerElement)\n          // skip attribute nodes' text child.\n          continue;\n        if (n.childNodes) {\n          nodeMultiSet.pushSeries();\n          var childList = 1 === nodeTypeNum && null != n.children ? n.children : n.childNodes;\n          for (var j = 0; j < childList.length; ++j) {\n            var child = childList[j];\n            if (matcher.matches(child)) {\n              nodeMultiSet.addNode(child);\n            }\n            // don't have to do de-duping because children have parent,\n            // which are current context.\n          }\n\n          nodeMultiSet.popSeries();\n        }\n      }\n      nodeMultiSet.finalize();\n      return sortNodeMultiSet(nodeMultiSet);\n    },\n    'descendant': function descenant(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      return descenantHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n    },\n    'descendant-or-self': function descenantOrSelf(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      return descenantHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n    },\n    'following': function following(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      return followingHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n    },\n    'following-sibling': function followingSibling(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      return followingSiblingHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, Array.prototype.shift, function () {\n        return this[0];\n      }, function (node) {\n        return node.nextSibling;\n      });\n    },\n    'namespace': function namespace(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      // TODO\n    },\n    'parent': function parent(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n      var nodes = [],\n        pos = [];\n      for (var i = 0; i < nodeList.length; ++i) {\n        var parent = nodeList[i].parentNode || nodeList[i].ownerElement;\n        if (null == parent) continue;\n        if (!matcher.matches(parent)) continue;\n        if (nodes.length > 0 && parent === nodes[nodes.length - 1]) continue;\n        nodes.push(parent);\n        pos.push([1]);\n      }\n      return {\n        nodes: nodes,\n        pos: pos,\n        lasts: pos\n      };\n    },\n    'preceding': function preceding(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      return precedingHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n    },\n    'preceding-sibling': function precedingSibling(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      return followingSiblingHelper(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, Array.prototype.pop, function () {\n        return this[this.length - 1];\n      }, function (node) {\n        return node.previousSibling;\n      }, false, true);\n    },\n    'self': function self(nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n      var nodes = [],\n        pos = [];\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n      for (var i = 0; i < nodeList.length; ++i) {\n        if (matcher.matches(nodeList[i])) {\n          nodes.push(nodeList[i]);\n          pos.push([1]);\n        }\n      }\n      return {\n        nodes: nodes,\n        pos: pos,\n        lasts: pos\n      };\n    }\n  };\n\n  /***************************************************************************\r\n   *                         Evaluation: functions                           *\r\n   ***************************************************************************/\n  var fn = {\n    'number': function number(optObject) {\n      if ('number' === typeof optObject) return optObject;\n      if ('string' === typeof optObject) return parseFloat(optObject); // note: parseFloat(' ') -> NaN, unlike +' ' -> 0.\n      if ('boolean' === typeof optObject) return +optObject;\n      return fn.number(fn.string.call(this, optObject)); // for node-sets\n    },\n\n    'string': function string(optObject) {\n      if (null == optObject) return fn.string(this);\n      if ('string' === typeof optObject || 'boolean' === typeof optObject || 'number' === typeof optObject) return '' + optObject;\n      if (0 == optObject.nodes.length) return '';\n      if (null != optObject.nodes[0].textContent) return optObject.nodes[0].textContent;\n      return optObject.nodes[0].nodeValue;\n    },\n    'boolean': function booleanVal(x) {\n      return 'object' === typeof x ? x.nodes.length > 0 : !!x;\n    },\n    'last': function last() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.lasts[0].length);\n      return this.lasts[0][0];\n    },\n    'position': function position() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.pos[0].length);\n      return this.pos[0][0];\n    },\n    'count': function count(nodeSet) {\n      if ('object' !== typeof nodeSet) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Function count(node-set) ' + 'got wrong argument type: ' + nodeSet);\n      return nodeSet.nodes.length;\n    },\n    'id': function id(object) {\n      var r = {\n        nodes: []\n      };\n      var doc = this.nodes[0].ownerDocument || this.nodes[0];\n      console.assert(doc);\n      var ids;\n      if ('object' === typeof object) {\n        // for node-sets, map id over each node value.\n        ids = [];\n        for (var i = 0; i < object.nodes.length; ++i) {\n          var idNode = object.nodes[i];\n          var idsString = fn.string({\n            nodes: [idNode]\n          });\n          var a = idsString.split(/[ \\t\\r\\n]+/g);\n          Array.prototype.push.apply(ids, a);\n        }\n      } else {\n        var idsString = fn.string(object);\n        var a = idsString.split(/[ \\t\\r\\n]+/g);\n        ids = a;\n      }\n      for (var i = 0; i < ids.length; ++i) {\n        var id = ids[i];\n        if (0 === id.length) continue;\n        var node = doc.getElementById(id);\n        if (null != node) r.nodes.push(node);\n      }\n      r.nodes = sortUniqDocumentOrder(r.nodes);\n      return r;\n    },\n    'local-name': function (nodeSet) {\n      if (null == nodeSet) return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      // TODO: namespaced version\n      return nodeSet.nodes[0].localName;\n    },\n    'namespace-uri': function (nodeSet) {\n      // TODO\n      throw new Error('not implemented yet');\n    },\n    'name': function (nodeSet) {\n      if (null == nodeSet) return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      return nodeSet.nodes[0].name;\n    },\n    'concat': function concat(x) {\n      var l = [];\n      for (var i = 0; i < arguments.length; ++i) {\n        l.push(fn.string(arguments[i]));\n      }\n      return l.join('');\n    },\n    'starts-with': function startsWith(a, b) {\n      var as = fn.string(a),\n        bs = fn.string(b);\n      return as.substr(0, bs.length) === bs;\n    },\n    'contains': function contains(a, b) {\n      var as = fn.string(a),\n        bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return false;\n      return true;\n    },\n    'substring-before': function substringBefore(a, b) {\n      var as = fn.string(a),\n        bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(0, i);\n    },\n    'substring-after': function substringBefore(a, b) {\n      var as = fn.string(a),\n        bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(i + bs.length);\n    },\n    'substring': function substring(string, start, optEnd) {\n      if (null == string || null == start) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Must be at least 2 arguments to string()');\n      }\n      var sString = fn.string(string),\n        iStart = fn.round(start),\n        iEnd = optEnd == null ? null : fn.round(optEnd);\n      // Note that xpath string positions user 1-based index\n      if (iEnd == null) return sString.substr(iStart - 1);else return sString.substr(iStart - 1, iEnd);\n    },\n    'string-length': function stringLength(optString) {\n      return fn.string.call(this, optString).length;\n    },\n    'normalize-space': function normalizeSpace(optString) {\n      var s = fn.string.call(this, optString);\n      return s.replace(/[ \\t\\r\\n]+/g, ' ').replace(/^ | $/g, '');\n    },\n    'translate': function translate(string, from, to) {\n      var sString = fn.string.call(this, string),\n        sFrom = fn.string(from),\n        sTo = fn.string(to);\n      var eachCharRe = [];\n      var map = {};\n      for (var i = 0; i < sFrom.length; ++i) {\n        var c = sFrom.charAt(i);\n        map[c] = sTo.charAt(i); // returns '' if beyond length of sTo.\n        // copied from goog.string.regExpEscape in the Closure library.\n        eachCharRe.push(c.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').replace(/\\x08/g, '\\\\x08'));\n      }\n      var re = new RegExp(eachCharRe.join('|'), 'g');\n      return sString.replace(re, function (c) {\n        return map[c];\n      });\n    },\n    /// Boolean functions\n    'not': function not(x) {\n      var bx = fn['boolean'](x);\n      return !bx;\n    },\n    'true': function trueVal() {\n      return true;\n    },\n    'false': function falseVal() {\n      return false;\n    },\n    // TODO\n    'lang': function lang(string) {\n      throw new Error('Not implemented');\n    },\n    'sum': function sum(optNodeSet) {\n      if (null == optNodeSet) return fn.sum(this);\n      // for node-sets, map id over each node value.\n      var sum = 0;\n      for (var i = 0; i < optNodeSet.nodes.length; ++i) {\n        var node = optNodeSet.nodes[i];\n        var x = fn.number({\n          nodes: [node]\n        });\n        sum += x;\n      }\n      return sum;\n    },\n    'floor': function floor(number) {\n      return Math.floor(fn.number(number));\n    },\n    'ceiling': function ceiling(number) {\n      return Math.ceil(fn.number(number));\n    },\n    'round': function round(number) {\n      return Math.round(fn.number(number));\n    }\n  };\n  /***************************************************************************\r\n   *                         Evaluation: operators                           *\r\n   ***************************************************************************/\n  var more = {\n    UnaryMinus: function (x) {\n      return -fn.number(x);\n    },\n    '+': function (x, y) {\n      return fn.number(x) + fn.number(y);\n    },\n    '-': function (x, y) {\n      return fn.number(x) - fn.number(y);\n    },\n    '*': function (x, y) {\n      return fn.number(x) * fn.number(y);\n    },\n    'div': function (x, y) {\n      return fn.number(x) / fn.number(y);\n    },\n    'mod': function (x, y) {\n      return fn.number(x) % fn.number(y);\n    },\n    '<': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) < fn.number(y);\n      }, x, y, true);\n    },\n    '<=': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) <= fn.number(y);\n      }, x, y, true);\n    },\n    '>': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) > fn.number(y);\n      }, x, y, true);\n    },\n    '>=': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) >= fn.number(y);\n      }, x, y, true);\n    },\n    'and': function (x, y) {\n      return fn['boolean'](x) && fn['boolean'](y);\n    },\n    'or': function (x, y) {\n      return fn['boolean'](x) || fn['boolean'](y);\n    },\n    '|': function (x, y) {\n      return {\n        nodes: mergeNodeLists(x.nodes, y.nodes)\n      };\n    },\n    '=': function (x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [x.nodes[i]]\n          });\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [y.nodes[i]]\n          });\n          if (aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function (x, y) {\n          return x === y;\n        }, x, y);\n      }\n    },\n    '!=': function (x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        if (0 === x.nodes.length || 0 === y.nodes.length) return false;\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [x.nodes[i]]\n          });\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [y.nodes[i]]\n          });\n          if (!aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function (x, y) {\n          return x !== y;\n        }, x, y);\n      }\n    }\n  };\n  var nodeTypes = xpath.nodeTypes = {\n    'node': 0,\n    'attribute': 2,\n    'comment': 8,\n    // this.doc.COMMENT_NODE,\n    'text': 3,\n    // this.doc.TEXT_NODE,\n    'processing-instruction': 7,\n    // this.doc.PROCESSING_INSTRUCTION_NODE,\n    'element': 1 //this.doc.ELEMENT_NODE\n  };\n  /** For debugging and unit tests: returnjs a stringified version of the\r\n   * argument. */\n  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {\n    var seenKey = 'seen' + Math.floor(Math.random() * 1000000000);\n    return JSON.stringify(helper(ctx));\n    function helper(ctx) {\n      if (Array.isArray(ctx)) {\n        return ctx.map(function (x) {\n          return helper(x);\n        });\n      }\n      if ('object' !== typeof ctx) return ctx;\n      if (null == ctx) return ctx;\n      //  if (ctx.toString) return ctx.toString();\n      if (null != ctx.outerHTML) return ctx.outerHTML;\n      if (null != ctx.nodeValue) return ctx.nodeName + '=' + ctx.nodeValue;\n      if (ctx[seenKey]) return '[circular]';\n      ctx[seenKey] = true;\n      var nicer = {};\n      for (var key in ctx) {\n        if (seenKey === key) continue;\n        try {\n          nicer[key] = helper(ctx[key]);\n        } catch (e) {\n          nicer[key] = '[exception: ' + e.message + ']';\n        }\n      }\n      delete ctx[seenKey];\n      return nicer;\n    }\n  };\n  var Evaluator = xpath.Evaluator = function Evaluator(doc) {\n    this.doc = doc;\n  };\n  Evaluator.prototype = {\n    val: function val(ast, ctx) {\n      console.assert(ctx.nodes);\n      if ('number' === typeof ast || 'string' === typeof ast) return ast;\n      if (more[ast[0]]) {\n        var evaluatedParams = [];\n        for (var i = 1; i < ast.length; ++i) {\n          evaluatedParams.push(this.val(ast[i], ctx));\n        }\n        var r = more[ast[0]].apply(ctx, evaluatedParams);\n        return r;\n      }\n      switch (ast[0]) {\n        case 'Root':\n          return {\n            nodes: [this.doc]\n          };\n        case 'FunctionCall':\n          var functionName = ast[1],\n            functionParams = ast[2];\n          if (null == fn[functionName]) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Unknown function: ' + functionName);\n          var evaluatedParams = [];\n          for (var i = 0; i < functionParams.length; ++i) {\n            evaluatedParams.push(this.val(functionParams[i], ctx));\n          }\n          var r = fn[functionName].apply(ctx, evaluatedParams);\n          return r;\n        case 'Predicate':\n          var lhs = this.val(ast[1], ctx);\n          var ret = {\n            nodes: []\n          };\n          var contexts = eachContext(lhs);\n          for (var i = 0; i < contexts.length; ++i) {\n            var singleNodeSet = contexts[i];\n            var rhs = this.val(ast[2], singleNodeSet);\n            var success;\n            if ('number' === typeof rhs) {\n              success = rhs === singleNodeSet.pos[0][0];\n            } else {\n              success = fn['boolean'](rhs);\n            }\n            if (success) {\n              var node = singleNodeSet.nodes[0];\n              ret.nodes.push(node);\n              // skip over all the rest of the same node.\n              while (i + 1 < contexts.length && node === contexts[i + 1].nodes[0]) {\n                i++;\n              }\n            }\n          }\n          return ret;\n        case 'PathExpr':\n          // turn the path into an expressoin; i.e., remove the position\n          // information of the last axis.\n          var x = this.val(ast[1], ctx);\n          // Make the nodeset a forward-direction-only one.\n          if (x.finalize) {\n            // it is a NodeMultiSet\n            return {\n              nodes: x.nodes\n            };\n          } else {\n            return x;\n          }\n        case '/':\n          // TODO: don't generate '/' nodes, just Axis nodes.\n          var lhs = this.val(ast[1], ctx);\n          console.assert(null != lhs);\n          var r = this.val(ast[2], lhs);\n          console.assert(null != r);\n          return r;\n        case 'Axis':\n          // All the axis tests from Step. We only get AxisSpecifier NodeTest,\n          // not the predicate (which is applied later)\n          var axis = ast[1],\n            nodeType = ast[2],\n            nodeTypeNum = nodeTypes[nodeType],\n            shouldLowerCase = true,\n            // TODO: give option\n            nodeName = ast[3] && shouldLowerCase ? ast[3].toLowerCase() : ast[3];\n          nodeName = nodeName === '*' ? null : nodeName;\n          if ('object' !== typeof ctx) return {\n            nodes: [],\n            pos: []\n          };\n          var nodeList = ctx.nodes.slice(); // TODO: is copy needed?\n          var r = axes[axis](nodeList /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n          return r;\n      }\n    }\n  };\n  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {\n    //var astFactory = new AstEvaluatorFactory(doc, context);\n    var stream = new Stream(expr);\n    var ast = parse(stream, astFactory);\n    var val = new Evaluator(doc).val(ast, {\n      nodes: [context]\n    });\n    return val;\n  };\n\n  /***************************************************************************\r\n   *                           DOM interface                                 *\r\n   ***************************************************************************/\n  var XPathException = xpath.XPathException = function XPathException(code, message) {\n    var e = new Error(message);\n    e.name = 'XPathException';\n    e.code = code;\n    return e;\n  };\n  XPathException.INVALID_EXPRESSION_ERR = 51;\n  XPathException.TYPE_ERR = 52;\n  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {};\n  XPathEvaluator.prototype = {\n    createExpression: function (expression, resolver) {\n      return new XPathExpression(expression, resolver);\n    },\n    createNSResolver: function (nodeResolver) {\n      // TODO\n    },\n    evaluate: function evaluate(expression, contextNode, resolver, type, result) {\n      var expr = new XPathExpression(expression, resolver);\n      return expr.evaluate(contextNode, type, result);\n    }\n  };\n  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {\n    var stream = new Stream(expression);\n    this._ast = parse(stream, astFactory);\n    this._doc = optDoc;\n  };\n  XPathExpression.prototype = {\n    evaluate: function evaluate(contextNode, type, result) {\n      if (null == contextNode.nodeType) throw new Error('bad argument (expected context node): ' + contextNode);\n      var doc = contextNode.ownerDocument || contextNode;\n      if (null != this._doc && this._doc !== doc) {\n        throw new core.DOMException(core.DOMException.WRONG_DOCUMENT_ERR, 'The document must be the same as the context node\\'s document.');\n      }\n      var evaluator = new Evaluator(doc);\n      var value = evaluator.val(this._ast, {\n        nodes: [contextNode]\n      });\n      if (XPathResult.NUMBER_TYPE === type) value = fn.number(value);else if (XPathResult.STRING_TYPE === type) value = fn.string(value);else if (XPathResult.BOOLEAN_TYPE === type) value = fn['boolean'](value);else if (XPathResult.ANY_TYPE !== type && XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type && XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type && XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type && XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type && XPathResult.ANY_UNORDERED_NODE_TYPE !== type && XPathResult.FIRST_ORDERED_NODE_TYPE !== type) throw new core.DOMException(core.DOMException.NOT_SUPPORTED_ERR, 'You must provide an XPath result type (0=any).');else if (XPathResult.ANY_TYPE !== type && 'object' !== typeof value) throw new XPathException(XPathException.TYPE_ERR, 'Value should be a node-set: ' + value);\n      return new XPathResult(doc, value, type);\n    }\n  };\n  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {\n    this._value = value;\n    this._resultType = resultType;\n    this._i = 0;\n\n    // TODO: we removed mutation events but didn't take care of this. No tests fail, so that's nice, but eventually we\n    // should fix this, preferably by entirely replacing our XPath implementation.\n    // this._invalidated = false;\n    // if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||\n    //     this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\n    //   doc.addEventListener('DOMSubtreeModified', invalidate, true);\n    //   var self = this;\n    //   function invalidate() {\n    //     self._invalidated = true;\n    //     doc.removeEventListener('DOMSubtreeModified', invalidate, true);\n    //   }\n    // }\n  };\n\n  XPathResult.ANY_TYPE = 0;\n  XPathResult.NUMBER_TYPE = 1;\n  XPathResult.STRING_TYPE = 2;\n  XPathResult.BOOLEAN_TYPE = 3;\n  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\n  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\n  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\n  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;\n  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;\n  var proto = {\n    // XPathResultType\n    get resultType() {\n      if (this._resultType) return this._resultType;\n      switch (typeof this._value) {\n        case 'number':\n          return XPathResult.NUMBER_TYPE;\n        case 'string':\n          return XPathResult.STRING_TYPE;\n        case 'boolean':\n          return XPathResult.BOOLEAN_TYPE;\n        default:\n          return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\n      }\n    },\n    get numberValue() {\n      if (XPathResult.NUMBER_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a NUMBER_TYPE.');\n      return this._value;\n    },\n    get stringValue() {\n      if (XPathResult.STRING_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a STRING_TYPE.');\n      return this._value;\n    },\n    get booleanValue() {\n      if (XPathResult.BOOLEAN_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a BOOLEAN_TYPE.');\n      return this._value;\n    },\n    get singleNodeValue() {\n      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType && XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a FIRST_ORDERED_NODE_TYPE.');\n      return this._value.nodes[0] || null;\n    },\n    get invalidIteratorState() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType && XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType) return false;\n      return !!this._invalidated;\n    },\n    get snapshotLength() {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType && XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes.length;\n    },\n    iterateNext: function iterateNext() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType && XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.');\n      if (this.invalidIteratorState) throw new core.DOMException(core.DOMException.INVALID_STATE_ERR, 'The document has been mutated since the result was returned');\n      return this._value.nodes[this._i++] || null;\n    },\n    snapshotItem: function snapshotItem(index) {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType && XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes[index] || null;\n    }\n  };\n  // so you can access ANY_TYPE etc. from the instances:\n  XPathResult.prototype = Object.create(XPathResult, Object.keys(proto).reduce(function (descriptors, name) {\n    descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);\n    return descriptors;\n  }, {\n    constructor: {\n      value: XPathResult,\n      writable: true,\n      configurable: true\n    }\n  }));\n  core.XPathException = XPathException;\n  core.XPathExpression = XPathExpression;\n  core.XPathResult = XPathResult;\n  core.XPathEvaluator = XPathEvaluator;\n  core.Document.prototype.createExpression = XPathEvaluator.prototype.createExpression;\n  core.Document.prototype.createNSResolver = XPathEvaluator.prototype.createNSResolver;\n  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;\n  return xpath; // for tests\n};","map":{"version":3,"names":["module","exports","core","xpath","getNodeName","nodeOrAttr","constructor","name","nodeName","Stream","str","original","peeked","prev","prevprev","prototype","peek","m","re","exec","substr","length","peek2","pop","r","trypop","tokens","tok","Array","isArray","i","t","trypopfuncname","isQnameRe","test","trypopaxisname","trypopnametest","startsWithNcNameRe","trypopliteral","first","charAt","last","trypopnumber","isNumberRe","parseFloat","trypopvarref","position","nameStartCharsExceptColon","nameCharExceptColon","ncNameChars","qNameChars","otherChars","operatorChars","literal","numberChars","variableReference","nameTestChars","optionalSpace","nodeType","RegExp","parse","stream","a","orExpr","x","unparsed","push","XPathException","INVALID_EXPRESSION_ERR","join","binaryL","subExpr","ops","lhs","op","rhs","node","binaryR","locationPath","absoluteLocationPath","relativeLocationPath","isOnlyRootOk","step","undefined","abbrStep","axis","axisSpecifier","nodeTypeTest","nodeNameTest","pred","predicate","attr","axisName","coloncolon","type","param","expr","primaryExpr","varRef","funCall","functionCall","e","params","unionExpr","pathExpr","filter","filterExpr","loc","Error","rel","primary","orig","andExpr","now","equalityExpr","relationalExpr","additiveExpr","multiplicativeExpr","unaryExpr","astFactory","slice","call","arguments","optimize","ast","NodeMultiSet","isReverseAxis","nodes","pos","lasts","nextPos","seriesIndexes","_pushToNodes","unshift","pushSeries","popSeries","console","assert","indexInPos","seriesBeginIndex","seriesEndIndex","finalize","lastsJSON","JSON","stringify","j","addNode","simplify","eachContext","nodeMultiSet","NodeMatcher","nodeTypeNum","shouldLowerCase","_alwaysTrue","_nodeNameLowerCaseEquals","_nodeNameEquals","matches","_nodeTypeMatches","toLowerCase","followingSiblingHelper","nodeList","shift","followingNode","andSelf","matcher","numPushed","followingNonDescendantNode","ownerElement","firstChild","nextSibling","parentNode","precedingNode","previousSibling","lastChild","followingHelper","cursor","unorderedFollowingStarts","start","started","splice","precedingHelper","nextParents","someoneUsed","descendantDfs","remaining","attrIndices","attrNodes","pushed","childNodes","child","descenantHelper","ancestorHelper","ancestors","isFirst","newCtx","addressVector","addressComparator","b","minlen","Math","min","alen","blen","c","sortUniqDocumentOrder","v","sort","sortNodeMultiSet","n","p","l","compare","y","nodeAndAncestors","compareSiblings","stringifyObject","mergeNodeLists","aanc","banc","comparisonHelper","isNumericComparison","coersion","fn","number","string","aMap","xi","yj","yc","yi","xc","axes","ancestor","ancestorOrSelf","attribute","getAttributeNode","attributes","childList","children","descenant","descenantOrSelf","following","followingSibling","namespace","parent","preceding","precedingSibling","self","optObject","textContent","nodeValue","booleanVal","count","nodeSet","id","object","doc","ownerDocument","ids","idNode","idsString","split","apply","getElementById","local-name","localName","namespace-uri","concat","startsWith","as","bs","contains","indexOf","substringBefore","substring","optEnd","sString","iStart","round","iEnd","stringLength","optString","normalizeSpace","s","replace","translate","from","to","sFrom","sTo","eachCharRe","map","not","bx","trueVal","falseVal","lang","sum","optNodeSet","floor","ceiling","ceil","more","UnaryMinus","+","-","*","div","mod","<","<=",">",">=","and","or","|","=","!=","nodeTypes","ctx","seenKey","random","helper","outerHTML","nicer","key","message","Evaluator","val","evaluatedParams","functionName","functionParams","ret","contexts","singleNodeSet","success","evaluate","context","code","TYPE_ERR","XPathEvaluator","createExpression","expression","resolver","XPathExpression","createNSResolver","nodeResolver","contextNode","result","optDoc","_ast","_doc","DOMException","WRONG_DOCUMENT_ERR","evaluator","value","XPathResult","NUMBER_TYPE","STRING_TYPE","BOOLEAN_TYPE","ANY_TYPE","UNORDERED_NODE_ITERATOR_TYPE","ORDERED_NODE_ITERATOR_TYPE","UNORDERED_NODE_SNAPSHOT_TYPE","ORDERED_NODE_SNAPSHOT_TYPE","ANY_UNORDERED_NODE_TYPE","FIRST_ORDERED_NODE_TYPE","NOT_SUPPORTED_ERR","resultType","_value","_resultType","_i","proto","numberValue","stringValue","booleanValue","singleNodeValue","invalidIteratorState","_invalidated","snapshotLength","iterateNext","INVALID_STATE_ERR","snapshotItem","index","Object","create","keys","reduce","descriptors","getOwnPropertyDescriptor","writable","configurable","Document"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/jsdom/level3/xpath.js"],"sourcesContent":["/** Here is yet another implementation of XPath 1.0 in Javascript.\r\n *\r\n * My goal was to make it relatively compact, but as I fixed all the axis bugs\r\n * the axes became more and more complicated. :-(.\r\n *\r\n * I have not implemented namespaces or case-sensitive axes for XML yet.\r\n *\r\n * How to test it in Chrome: You can make a Chrome extension that replaces\r\n * the WebKit XPath parser with this one. But it takes a bit of effort to\r\n * get around isolated world and same-origin restrictions:\r\n * manifest.json:\r\n    {\r\n      \"name\": \"XPathTest\",\r\n      \"version\": \"0.1\",\r\n      \"content_scripts\": [{\r\n        \"matches\": [\"http://localhost/*\"],  // or wildcard host\r\n        \"js\": [\"xpath.js\", \"injection.js\"],\r\n        \"all_frames\": true, \"run_at\": \"document_start\"\r\n      }]\r\n    }\r\n * injection.js:\r\n    // goal: give my xpath object to the website's JS context.\r\n    var script = document.createElement('script');\r\n    script.textContent =\r\n        \"document.addEventListener('xpathextend', function(e) {\\n\" +\r\n        \"  console.log('extending document with xpath...');\\n\" +\r\n        \"  e.detail(window);\" +\r\n        \"});\";\r\n    document.documentElement.appendChild(script);\r\n    document.documentElement.removeChild(script);\r\n    var evt = document.createEvent('CustomEvent');\r\n    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);\r\n    document.dispatchEvent(evt);\r\n */\r\nmodule.exports = core => {\r\n  var xpath = {};\r\n\r\n  // Helper function to deal with the migration of Attr to no longer have a nodeName property despite this codebase\r\n  // assuming it does.\r\n  function getNodeName(nodeOrAttr) {\r\n    return nodeOrAttr.constructor.name === 'Attr' ? nodeOrAttr.name : nodeOrAttr.nodeName;\r\n  }\r\n\r\n  /***************************************************************************\r\n   *                            Tokenization                                 *\r\n   ***************************************************************************/\r\n  /**\r\n   * The XPath lexer is basically a single regular expression, along with\r\n   * some helper functions to pop different types.\r\n   */\r\n  var Stream = xpath.Stream = function Stream(str) {\r\n    this.original = this.str = str;\r\n    this.peeked = null;\r\n    // TODO: not really needed, but supposedly tokenizer also disambiguates\r\n    // a * b vs. node test *\r\n    this.prev = null;  // for debugging\r\n    this.prevprev = null;\r\n  }\r\n  Stream.prototype = {\r\n    peek: function() {\r\n      if (this.peeked) return this.peeked;\r\n      var m = this.re.exec(this.str);\r\n      if (!m) return null;\r\n      this.str = this.str.substr(m[0].length);\r\n      return this.peeked = m[1];\r\n    },\r\n    /** Peek 2 tokens ahead. */\r\n    peek2: function() {\r\n      this.peek();  // make sure this.peeked is set\r\n      var m = this.re.exec(this.str);\r\n      if (!m) return null;\r\n      return m[1];\r\n    },\r\n    pop: function() {\r\n      var r = this.peek();\r\n      this.peeked = null;\r\n      this.prevprev = this.prev;\r\n      this.prev = r;\r\n      return r;\r\n    },\r\n    trypop: function(tokens) {\r\n      var tok = this.peek();\r\n      if (tok === tokens) return this.pop();\r\n      if (Array.isArray(tokens)) {\r\n        for (var i = 0; i < tokens.length; ++i) {\r\n          var t = tokens[i];\r\n          if (t == tok) return this.pop();;\r\n        }\r\n      }\r\n    },\r\n    trypopfuncname: function() {\r\n      var tok = this.peek();\r\n      if (!this.isQnameRe.test(tok))\r\n        return null;\r\n      switch (tok) {\r\n        case 'comment': case 'text': case 'processing-instruction': case 'node':\r\n          return null;\r\n      }\r\n      if ('(' != this.peek2()) return null;\r\n      return this.pop();\r\n    },\r\n    trypopaxisname: function() {\r\n      var tok = this.peek();\r\n      switch (tok) {\r\n        case 'ancestor': case 'ancestor-or-self': case 'attribute':\r\n        case 'child': case 'descendant': case 'descendant-or-self':\r\n        case 'following': case 'following-sibling': case 'namespace':\r\n        case 'parent': case 'preceding': case 'preceding-sibling': case 'self':\r\n          if ('::' == this.peek2()) return this.pop();\r\n      }\r\n      return null;\r\n    },\r\n    trypopnametest: function() {\r\n      var tok = this.peek();\r\n      if ('*' === tok || this.startsWithNcNameRe.test(tok)) return this.pop();\r\n      return null;\r\n    },\r\n    trypopliteral: function() {\r\n      var tok = this.peek();\r\n      if (null == tok) return null;\r\n      var first = tok.charAt(0);\r\n      var last = tok.charAt(tok.length - 1);\r\n      if ('\"' === first && '\"' === last ||\r\n          \"'\" === first && \"'\" === last) {\r\n        this.pop();\r\n        return tok.substr(1, tok.length - 2);\r\n      }\r\n    },\r\n    trypopnumber: function() {\r\n      var tok = this.peek();\r\n      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());\r\n      else return null;\r\n    },\r\n    trypopvarref: function() {\r\n      var tok = this.peek();\r\n      if (null == tok) return null;\r\n      if ('$' === tok.charAt(0)) return this.pop().substr(1);\r\n      else return null;\r\n    },\r\n    position: function() {\r\n      return this.original.length - this.str.length;\r\n    }\r\n  };\r\n  (function() {\r\n    // http://www.w3.org/TR/REC-xml-names/#NT-NCName\r\n    var nameStartCharsExceptColon =\r\n        'A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF' +\r\n        '\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF' +\r\n        '\\uFDF0-\\uFFFD';  // JS doesn't support [#x10000-#xEFFFF]\r\n    var nameCharExceptColon = nameStartCharsExceptColon +\r\n        '\\\\-\\\\.0-9\\xb7\\u0300-\\u036F\\u203F-\\u2040';\r\n    var ncNameChars = '[' + nameStartCharsExceptColon +\r\n        '][' + nameCharExceptColon + ']*'\r\n    // http://www.w3.org/TR/REC-xml-names/#NT-QName\r\n    var qNameChars = ncNameChars + '(?::' + ncNameChars + ')?';\r\n    var otherChars = '\\\\.\\\\.|[\\\\(\\\\)\\\\[\\\\].@,]|::';  // .. must come before [.]\r\n    var operatorChars =\r\n        'and|or|mod|div|' +\r\n        '//|!=|<=|>=|[*/|+\\\\-=<>]';  // //, !=, <=, >= before individual ones.\r\n    var literal = '\"[^\"]*\"|' + \"'[^']*'\";\r\n    var numberChars = '[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9]+';\r\n    var variableReference = '\\\\$' + qNameChars;\r\n    var nameTestChars = '\\\\*|' + ncNameChars + ':\\\\*|' + qNameChars;\r\n    var optionalSpace = '[ \\t\\r\\n]*';  // stricter than regexp \\s.\r\n    var nodeType = 'comment|text|processing-instruction|node';\r\n    var re = new RegExp(\r\n        // numberChars before otherChars so that leading-decimal doesn't become .\r\n        '^' + optionalSpace + '(' + numberChars + '|' + otherChars + '|' +\r\n        nameTestChars + '|' + operatorChars + '|' + literal + '|' +\r\n        variableReference + ')'\r\n        // operatorName | nodeType | functionName | axisName are lumped into\r\n        // qName for now; we'll check them on pop.\r\n    );\r\n    Stream.prototype.re = re;\r\n    Stream.prototype.startsWithNcNameRe = new RegExp('^' + ncNameChars);\r\n    Stream.prototype.isQnameRe = new RegExp('^' + qNameChars + '$');\r\n    Stream.prototype.isNumberRe = new RegExp('^' + numberChars + '$');\r\n  })();\r\n\r\n  /***************************************************************************\r\n   *                               Parsing                                   *\r\n   ***************************************************************************/\r\n  var parse = xpath.parse = function parse(stream, a) {\r\n    var r = orExpr(stream,a);\r\n    var x, unparsed = [];\r\n    while (x = stream.pop()) {\r\n      unparsed.push(x);\r\n    }\r\n    if (unparsed.length)\r\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                               'Position ' + stream.position() +\r\n                               ': Unparsed tokens: ' + unparsed.join(' '));\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * binaryL  ::= subExpr\r\n   *            | binaryL op subExpr\r\n   * so a op b op c becomes ((a op b) op c)\r\n   */\r\n  function binaryL(subExpr, stream, a, ops) {\r\n    var lhs = subExpr(stream, a);\r\n    if (lhs == null) return null;\r\n    var op;\r\n    while (op = stream.trypop(ops)) {\r\n      var rhs = subExpr(stream, a);\r\n      if (rhs == null)\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Expected something after ' + op);\r\n      lhs = a.node(op, lhs, rhs);\r\n    }\r\n    return lhs;\r\n  }\r\n  /**\r\n   * Too bad this is never used. If they made a ** operator (raise to power),\r\n   ( we would use it.\r\n   * binaryR  ::= subExpr\r\n   *            | subExpr op binaryR\r\n   * so a op b op c becomes (a op (b op c))\r\n   */\r\n  function binaryR(subExpr, stream, a, ops) {\r\n    var lhs = subExpr(stream, a);\r\n    if (lhs == null) return null;\r\n    var op = stream.trypop(ops);\r\n    if (op) {\r\n      var rhs = binaryR(stream, a);\r\n      if (rhs == null)\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Expected something after ' + op);\r\n      return a.node(op, lhs, rhs);\r\n    } else {\r\n      return lhs;// TODO\r\n    }\r\n  }\r\n  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath\r\n   * e.g. a, a/b, //a/b\r\n   */\r\n  function locationPath(stream, a) {\r\n    return absoluteLocationPath(stream, a) ||\r\n           relativeLocationPath(null, stream, a);\r\n  }\r\n  /** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath\r\n   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath\r\n   */\r\n  function absoluteLocationPath(stream, a) {\r\n    var op = stream.peek();\r\n    if ('/' === op || '//' === op) {\r\n      var lhs = a.node('Root');\r\n      return relativeLocationPath(lhs, stream, a, true);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  /** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |\r\n   *                            | AbbreviatedRelativeLocationPath\r\n   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step\r\n   * e.g. p/a, etc.\r\n   */\r\n  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {\r\n    if (null == lhs) {\r\n      lhs = step(stream, a);\r\n      if (null == lhs) return lhs;\r\n    }\r\n    var op;\r\n    while (op = stream.trypop(['/', '//'])) {\r\n      if ('//' === op) {\r\n        lhs = a.node('/', lhs,\r\n                     a.node('Axis', 'descendant-or-self', 'node', undefined));\r\n      }\r\n      var rhs = step(stream, a);\r\n      if (null == rhs && '/' === op && isOnlyRootOk) return lhs;\r\n      else isOnlyRootOk = false;\r\n      if (null == rhs)\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Expected step after ' + op);\r\n      lhs = a.node('/', lhs, rhs);\r\n    }\r\n    return lhs;\r\n  }\r\n  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep\r\n   *  [12] AbbreviatedStep::= '.' | '..'\r\n   * e.g. @href, self::p, p, a[@href], ., ..\r\n   */\r\n  function step(stream, a) {\r\n    var abbrStep = stream.trypop(['.', '..']);\r\n    if ('.' === abbrStep)  // A location step of . is short for self::node().\r\n      return a.node('Axis', 'self', 'node');\r\n    if ('..' === abbrStep)  // A location step of .. is short for parent::node()\r\n      return a.node('Axis', 'parent', 'node');\r\n\r\n    var axis = axisSpecifier(stream, a);\r\n    var nodeType = nodeTypeTest(stream, a);\r\n    var nodeName;\r\n    if (null == nodeType) nodeName = nodeNameTest(stream, a);\r\n    if (null == axis && null == nodeType && null == nodeName) return null;\r\n    if (null == nodeType && null == nodeName)\r\n        throw new XPathException(\r\n            XPathException.INVALID_EXPRESSION_ERR,\r\n            'Position ' + stream.position() +\r\n            ': Expected nodeTest after axisSpecifier ' + axis);\r\n    if (null == axis) axis = 'child';\r\n    if (null == nodeType) {\r\n      // When there's only a node name, then the node type is forced to be the\r\n      // principal node type of the axis.\r\n      // see http://www.w3.org/TR/xpath/#dt-principal-node-type\r\n      if ('attribute' === axis) nodeType = 'attribute';\r\n      else if ('namespace' === axis) nodeType = 'namespace';\r\n      else nodeType = 'element';\r\n    }\r\n    var lhs = a.node('Axis', axis, nodeType, nodeName);\r\n    var pred;\r\n    while (null != (pred = predicate(lhs, stream, a))) {\r\n      lhs = pred;\r\n    }\r\n    return lhs;\r\n  }\r\n  /** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier\r\n   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'\r\n   *                | 'descendant' | 'descendant-or-self' | 'following'\r\n   *                | 'following-sibling' | 'namespace' | 'parent' |\r\n   *                | 'preceding' | 'preceding-sibling' | 'self'\r\n   *  [13] AbbreviatedAxisSpecifier::= '@'?\r\n   */\r\n  function axisSpecifier(stream, a) {\r\n    var attr = stream.trypop('@');\r\n    if (null != attr) return 'attribute';\r\n    var axisName = stream.trypopaxisname();\r\n    if (null != axisName) {\r\n      var coloncolon = stream.trypop('::');\r\n      if (null == coloncolon)\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Should not happen. Should be ::.');\r\n      return axisName;\r\n    }\r\n  }\r\n  /** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'\r\n   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'\r\n   * I've split nodeTypeTest from nodeNameTest for convenience.\r\n   */\r\n  function nodeTypeTest(stream, a) {\r\n    if ('(' !== stream.peek2()) {\r\n      return null;\r\n    }\r\n    var type = stream.trypop(['comment', 'text', 'processing-instruction', 'node']);\r\n    if (null != type) {\r\n      if (null == stream.trypop('('))\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Should not happen.');\r\n      var param = undefined;\r\n      if (type == 'processing-instruction') {\r\n        param = stream.trypopliteral();\r\n      }\r\n      if (null == stream.trypop(')'))\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Expected close parens.');\r\n      return type\r\n    }\r\n  }\r\n  function nodeNameTest(stream, a) {\r\n    var name = stream.trypopnametest();\r\n    if (name != null) return name;\r\n    else return null;\r\n  }\r\n  /** [8] Predicate::= '[' PredicateExpr ']'\r\n   *  [9] PredicateExpr::= Expr\r\n   */\r\n  function predicate(lhs, stream, a) {\r\n    if (null == stream.trypop('[')) return null;\r\n    var expr = orExpr(stream, a);\r\n    if (null == expr)\r\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                               'Position ' + stream.position() +\r\n                               ': Expected expression after [');\r\n    if (null == stream.trypop(']'))\r\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                               'Position ' + stream.position() +\r\n                               ': Expected ] after expression.');\r\n    return a.node('Predicate', lhs, expr);\r\n  }\r\n  /** [14] Expr::= OrExpr\r\n   */\r\n  /** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall\r\n   * e.g. $x,  (3+4),  \"hi\",  32,  f(x)\r\n   */\r\n  function primaryExpr(stream, a) {\r\n    var x = stream.trypopliteral();\r\n    if (null == x)\r\n      x = stream.trypopnumber();\r\n    if (null != x) {\r\n      return x;\r\n    }\r\n    var varRef = stream.trypopvarref();\r\n    if (null != varRef) return a.node('VariableReference', varRef);\r\n    var funCall = functionCall(stream, a);\r\n    if (null != funCall) {\r\n      return funCall;\r\n    }\r\n    if (stream.trypop('(')) {\r\n      var e = orExpr(stream, a);\r\n      if (null == e)\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Expected expression after (.');\r\n      if (null == stream.trypop(')'))\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Expected ) after expression.');\r\n      return e;\r\n    }\r\n    return null;\r\n  }\r\n  /** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'\r\n   *  [17] Argument::= Expr\r\n   */\r\n  function functionCall(stream, a) {\r\n    var name = stream.trypopfuncname(stream, a);\r\n    if (null == name) return null;\r\n    if (null == stream.trypop('('))\r\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                               'Position ' + stream.position() +\r\n                               ': Expected ( ) after function name.');\r\n    var params = [];\r\n    var first = true;\r\n    while (null == stream.trypop(')')) {\r\n      if (!first && null == stream.trypop(','))\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Expected , between arguments of the function.');\r\n      first = false;\r\n      var param = orExpr(stream, a);\r\n      if (param == null)\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Expected expression as argument of function.');\r\n      params.push(param);\r\n    }\r\n    return a.node('FunctionCall', name, params);\r\n  }\r\n\r\n  /** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr\r\n   */\r\n  function unionExpr(stream, a) { return binaryL(pathExpr, stream, a, '|'); }\r\n  /** [19] PathExpr ::= LocationPath\r\n   *                  | FilterExpr\r\n   *                  | FilterExpr '/' RelativeLocationPath\r\n   *                  | FilterExpr '//' RelativeLocationPath\r\n   * Unlike most other nodes, this one always generates a node because\r\n   * at this point all reverse nodesets must turn into a forward nodeset\r\n   */\r\n  function pathExpr(stream, a) {\r\n    // We have to do FilterExpr before LocationPath because otherwise\r\n    // LocationPath will eat up the name from a function call.\r\n    var filter = filterExpr(stream, a);\r\n    if (null == filter) {\r\n      var loc = locationPath(stream, a);\r\n      if (null == loc) {\r\n        throw new Error\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': The expression shouldn\\'t be empty...');\r\n      }\r\n      return a.node('PathExpr', loc);\r\n    }\r\n    var rel = relativeLocationPath(filter, stream, a, false);\r\n    if (filter === rel) return rel;\r\n    else return a.node('PathExpr', rel);\r\n  }\r\n  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate\r\n   * aka. FilterExpr ::= PrimaryExpr Predicate*\r\n   */\r\n  function filterExpr(stream, a) {\r\n    var primary = primaryExpr(stream, a);\r\n    if (primary == null) return null;\r\n    var pred, lhs = primary;\r\n    while (null != (pred = predicate(lhs, stream, a))) {\r\n      lhs = pred;\r\n    }\r\n    return lhs;\r\n  }\r\n\r\n  /** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr\r\n   */\r\n  function orExpr(stream, a) {\r\n    var orig = (stream.peeked || '') + stream.str\r\n    var r = binaryL(andExpr, stream, a, 'or');\r\n    var now = (stream.peeked || '') + stream.str;\r\n    return r;\r\n  }\r\n  /** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr\r\n   */\r\n  function andExpr(stream, a) { return binaryL(equalityExpr, stream, a, 'and'); }\r\n  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr\r\n   *                     | EqualityExpr '!=' RelationalExpr\r\n   */\r\n  function equalityExpr(stream, a) { return binaryL(relationalExpr, stream, a, ['=','!=']); }\r\n  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '<' AdditiveExpr\r\n   *                       | RelationalExpr '>' AdditiveExpr\r\n   *                       | RelationalExpr '<=' AdditiveExpr\r\n   *                       | RelationalExpr '>=' AdditiveExpr\r\n   */\r\n  function relationalExpr(stream, a) { return binaryL(additiveExpr, stream, a, ['<','>','<=','>=']); }\r\n  /** [25] AdditiveExpr::= MultiplicativeExpr\r\n   *                     | AdditiveExpr '+' MultiplicativeExpr\r\n   *                     | AdditiveExpr '-' MultiplicativeExpr\r\n   */\r\n  function additiveExpr(stream, a) { return binaryL(multiplicativeExpr, stream, a, ['+','-']); }\r\n  /** [26] MultiplicativeExpr::= UnaryExpr\r\n   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr\r\n   *                           | MultiplicativeExpr 'div' UnaryExpr\r\n   *                           | MultiplicativeExpr 'mod' UnaryExpr\r\n   */\r\n  function multiplicativeExpr(stream, a) { return binaryL(unaryExpr, stream, a, ['*','div','mod']); }\r\n  /** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr\r\n   */\r\n  function unaryExpr(stream, a) {\r\n    if (stream.trypop('-')) {\r\n      var e = unaryExpr(stream, a);\r\n      if (null == e)\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Expected unary expression after -');\r\n      return a.node('UnaryMinus', e);\r\n    }\r\n    else return unionExpr(stream, a);\r\n  }\r\n  var astFactory = {\r\n    node: function() {return Array.prototype.slice.call(arguments);}\r\n  };\r\n\r\n\r\n  /***************************************************************************\r\n   *                            Optimizations (TODO)                         *\r\n   ***************************************************************************/\r\n  /**\r\n   * Some things I've been considering:\r\n   * 1) a//b becomes a/descendant::b if there's no predicate that uses\r\n   *    position() or last()\r\n   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per\r\n   *    node in the node-set rather than once per (node, position, last).\r\n   * For more optimizations, look up Gecko's optimizer:\r\n   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp\r\n   */\r\n  // TODO\r\n  function optimize(ast) {\r\n  }\r\n\r\n  /***************************************************************************\r\n   *                           Evaluation: axes                              *\r\n   ***************************************************************************/\r\n\r\n  /**\r\n   * Data types: For string, number, boolean, we just use Javascript types.\r\n   * Node-sets have the form\r\n   *    {nodes: [node, ...]}\r\n   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}\r\n   *\r\n   * Most of the time, only the node is used and the position information is\r\n   * discarded. But if you use a predicate, we need to try every value of\r\n   * position and last in case the predicate calls position() or last().\r\n   */\r\n\r\n  /**\r\n   * The NodeMultiSet is a helper class to help generate\r\n   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the\r\n   * descendant, descendant-or-self, following-sibling, and\r\n   * preceding-sibling axes for which we can use a stack to organize things.\r\n   */\r\n  function NodeMultiSet(isReverseAxis) {\r\n    this.nodes = [];\r\n    this.pos = [];\r\n    this.lasts = [];\r\n    this.nextPos = [];\r\n    this.seriesIndexes = [];  // index within nodes that each series begins.\r\n    this.isReverseAxis = isReverseAxis;\r\n    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;\r\n  }\r\n  NodeMultiSet.prototype = {\r\n    pushSeries: function pushSeries() {\r\n      this.nextPos.push(1);\r\n      this.seriesIndexes.push(this.nodes.length);\r\n    },\r\n    popSeries: function popSeries() {\r\n      console.assert(0 < this.nextPos.length, this.nextPos);\r\n      var last = this.nextPos.pop() - 1,\r\n          indexInPos = this.nextPos.length,\r\n          seriesBeginIndex = this.seriesIndexes.pop(),\r\n          seriesEndIndex = this.nodes.length;\r\n      for (var i = seriesBeginIndex; i < seriesEndIndex; ++i) {\r\n        console.assert(indexInPos < this.lasts[i].length);\r\n        console.assert(undefined === this.lasts[i][indexInPos]);\r\n        this.lasts[i][indexInPos] = last;\r\n      }\r\n    },\r\n    finalize: function() {\r\n      if (null == this.nextPos) return this;\r\n      console.assert(0 === this.nextPos.length);\r\n      var lastsJSON = JSON.stringify(this.lasts);\r\n      for (var i = 0; i < this.lasts.length; ++i) {\r\n        for (var j = 0; j < this.lasts[i].length; ++j) {\r\n          console.assert(null != this.lasts[i][j], i + ',' + j + ':' + lastsJSON);\r\n        }\r\n      }\r\n      this.pushSeries = this.popSeries = this.addNode = function() {\r\n        throw new Error('Already finalized.');\r\n      };\r\n      return this;\r\n    },\r\n    addNode: function addNode(node) {\r\n      console.assert(node);\r\n      this._pushToNodes.call(this.nodes, node)\r\n      this._pushToNodes.call(this.pos, this.nextPos.slice());\r\n      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));\r\n      for (var i = 0; i < this.nextPos.length; ++i) this.nextPos[i]++;\r\n    },\r\n    simplify: function() {\r\n      this.finalize();\r\n      return {nodes:this.nodes, pos:this.pos, lasts:this.lasts};\r\n    }\r\n  };\r\n  function eachContext(nodeMultiSet) {\r\n    var r = [];\r\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\r\n      var node = nodeMultiSet.nodes[i];\r\n      if (!nodeMultiSet.pos) {\r\n        r.push({nodes:[node], pos: [[i + 1]], lasts: [[nodeMultiSet.nodes.length]]});\r\n      } else {\r\n        for (var j = 0; j < nodeMultiSet.pos[i].length; ++j) {\r\n          r.push({nodes:[node], pos: [[nodeMultiSet.pos[i][j]]], lasts: [[nodeMultiSet.lasts[i][j]]]});\r\n        }\r\n      }\r\n    }\r\n    return r;\r\n  }\r\n  /** Matcher used in the axes.\r\n   */\r\n  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {\r\n    this.nodeTypeNum = nodeTypeNum;\r\n    this.nodeName = nodeName;\r\n    this.shouldLowerCase = shouldLowerCase;\r\n    this.nodeNameTest =\r\n      null == nodeName ? this._alwaysTrue :\r\n      shouldLowerCase ? this._nodeNameLowerCaseEquals :\r\n      this._nodeNameEquals;\r\n  }\r\n  NodeMatcher.prototype = {\r\n    matches: function matches(node) {\r\n      if (0 === this.nodeTypeNum || this._nodeTypeMatches(node)) {\r\n        return this.nodeNameTest(getNodeName(node));\r\n      }\r\n\r\n      return false;\r\n    },\r\n    _nodeTypeMatches(nodeOrAttr) {\r\n      if (nodeOrAttr.constructor.name === 'Attr' && this.nodeTypeNum === 2) {\r\n        return true;\r\n      }\r\n      return nodeOrAttr.nodeType === this.nodeTypeNum;\r\n    },\r\n    _alwaysTrue: function(name) {return true;},\r\n    _nodeNameEquals: function _nodeNameEquals(name) {\r\n      return this.nodeName === name;\r\n    },\r\n    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {\r\n      return this.nodeName === name.toLowerCase();\r\n    }\r\n  };\r\n\r\n  function followingSiblingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {\r\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\r\n    var nodeMultiSet = new NodeMultiSet(isReverseAxis);\r\n    while (0 < nodeList.length) {  // can be if for following, preceding\r\n      var node = shift.call(nodeList);\r\n      console.assert(node != null);\r\n      node = followingNode(node);\r\n      nodeMultiSet.pushSeries();\r\n      var numPushed = 1;\r\n      while (null != node) {\r\n        if (! andSelf && matcher.matches(node))\r\n          nodeMultiSet.addNode(node);\r\n        if (node === peek.call(nodeList)) {\r\n          shift.call(nodeList);\r\n          nodeMultiSet.pushSeries();\r\n          numPushed++;\r\n        }\r\n        if (andSelf && matcher.matches(node))\r\n          nodeMultiSet.addNode(node);\r\n        node = followingNode(node);\r\n      }\r\n      while (0 < numPushed--)\r\n        nodeMultiSet.popSeries();\r\n    }\r\n    return nodeMultiSet;\r\n  }\r\n\r\n  /** Returns the next non-descendant node in document order.\r\n   * This is the first node in following::node(), if node is the context.\r\n   */\r\n  function followingNonDescendantNode(node) {\r\n    if (node.ownerElement) {\r\n      if (node.ownerElement.firstChild)\r\n        return node.ownerElement.firstChild;\r\n      node = node.ownerElement;\r\n    }\r\n    do {\r\n      if (node.nextSibling) return node.nextSibling;\r\n    } while (node = node.parentNode);\r\n    return null;\r\n  }\r\n\r\n  /** Returns the next node in a document-order depth-first search.\r\n   * See the definition of document order[1]:\r\n   *   1) element\r\n   *   2) namespace nodes\r\n   *   3) attributes\r\n   *   4) children\r\n   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order\r\n   */\r\n  function followingNode(node) {\r\n    if (node.ownerElement)  // attributes: following node of element.\r\n      node = node.ownerElement;\r\n    if (null != node.firstChild)\r\n      return node.firstChild;\r\n    do {\r\n      if (null != node.nextSibling) {\r\n        return node.nextSibling;\r\n      }\r\n      node = node.parentNode;\r\n    } while (node);\r\n    return null;\r\n  }\r\n  /** Returns the previous node in document order (excluding attributes\r\n   * and namespace nodes).\r\n   */\r\n  function precedingNode(node) {\r\n    if (node.ownerElement)\r\n      return node.ownerElement;\r\n    if (null != node.previousSibling) {\r\n      node = node.previousSibling;\r\n      while (null != node.lastChild) {\r\n        node = node.lastChild;\r\n      }\r\n      return node;\r\n    }\r\n    if (null != node.parentNode) {\r\n      return node.parentNode;\r\n    }\r\n    return null;\r\n  }\r\n  /** This axis is inefficient if there are many nodes in the nodeList.\r\n   * But I think it's a pretty useless axis so it's ok. */\r\n  function followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\r\n    var nodeMultiSet = new NodeMultiSet(false);\r\n    var cursor = nodeList[0];\r\n    var unorderedFollowingStarts = [];\r\n    for (var i = 0; i < nodeList.length; i++) {\r\n      var node = nodeList[i];\r\n      var start = followingNonDescendantNode(node);\r\n      if (start)\r\n        unorderedFollowingStarts.push(start);\r\n    }\r\n    if (0 === unorderedFollowingStarts.length)\r\n      return {nodes:[]};\r\n    var pos = [], nextPos = [];\r\n    var started = 0;\r\n    while (cursor = followingNode(cursor)) {\r\n      for (var i = unorderedFollowingStarts.length - 1; i >= 0; i--){\r\n        if (cursor === unorderedFollowingStarts[i]) {\r\n          nodeMultiSet.pushSeries();\r\n          unorderedFollowingStarts.splice(i,i+1);\r\n          started++;\r\n        }\r\n      }\r\n      if (started && matcher.matches(cursor)) {\r\n        nodeMultiSet.addNode(cursor);\r\n      }\r\n    }\r\n    console.assert(0 === unorderedFollowingStarts.length);\r\n    for (var i = 0; i < started; i++)\r\n      nodeMultiSet.popSeries();\r\n    return nodeMultiSet.finalize();\r\n  }\r\n  function precedingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\r\n    var cursor = nodeList.pop();\r\n    if (null == cursor) return {nodes:{}};\r\n    var r = {nodes:[], pos:[], lasts:[]};\r\n    var nextParents = [cursor.parentNode || cursor.ownerElement], nextPos = [1];\r\n    while (cursor = precedingNode(cursor)) {\r\n      if (cursor === nodeList[nodeList.length - 1]) {\r\n        nextParents.push(nodeList.pop());\r\n        nextPos.push(1);\r\n      }\r\n      var matches = matcher.matches(cursor);\r\n      var pos, someoneUsed = false;\r\n      if (matches)\r\n        pos = nextPos.slice();\r\n\r\n      for (var i = 0; i < nextParents.length; ++i) {\r\n        if (cursor === nextParents[i]) {\r\n          nextParents[i] = cursor.parentNode || cursor.ownerElement;\r\n          if (matches) {\r\n            pos[i] = null;\r\n          }\r\n        } else {\r\n          if (matches) {\r\n            pos[i] = nextPos[i]++;\r\n            someoneUsed = true;\r\n          }\r\n        }\r\n      }\r\n      if (someoneUsed) {\r\n        r.nodes.unshift(cursor);\r\n        r.pos.unshift(pos);\r\n      }\r\n    }\r\n    for (var i = 0; i < r.pos.length; ++i) {\r\n      var lasts = [];\r\n      r.lasts.push(lasts);\r\n      for (var j = r.pos[i].length - 1; j >= 0; j--) {\r\n        if (null == r.pos[i][j]) {\r\n          r.pos[i].splice(j, j+1);\r\n        } else {\r\n          lasts.unshift(nextPos[j] - 1);\r\n        }\r\n      }\r\n    }\r\n    return r;\r\n  }\r\n\r\n  /** node-set, axis -> node-set */\r\n  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {\r\n    while (0 < remaining.length && null != remaining[0].ownerElement) {\r\n      var attr = remaining.shift();\r\n      if (andSelf && matcher.matches(attr)) {\r\n        attrNodes.push(attr);\r\n        attrIndices.push(nodeMultiSet.nodes.length);\r\n      }\r\n    }\r\n    if (null != node && !andSelf) {\r\n      if (matcher.matches(node))\r\n        nodeMultiSet.addNode(node);\r\n    }\r\n    var pushed = false;\r\n    if (null == node) {\r\n      if (0 === remaining.length) return;\r\n      node = remaining.shift();\r\n      nodeMultiSet.pushSeries();\r\n      pushed = true;\r\n    } else if (0 < remaining.length && node === remaining[0]) {\r\n      nodeMultiSet.pushSeries();\r\n      pushed = true;\r\n      remaining.shift();\r\n    }\r\n    if (andSelf) {\r\n      if (matcher.matches(node))\r\n        nodeMultiSet.addNode(node);\r\n    }\r\n    // TODO: use optimization. Also try element.getElementsByTagName\r\n    // var nodeList = 1 === nodeTypeNum && null != node.children ? node.children : node.childNodes;\r\n    var nodeList = node.childNodes;\r\n    for (var j = 0; j < nodeList.length; ++j) {\r\n      var child = nodeList[j];\r\n      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);\r\n    }\r\n    if (pushed) {\r\n      nodeMultiSet.popSeries();\r\n    }\r\n  }\r\n  function descenantHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\r\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\r\n    var nodeMultiSet = new NodeMultiSet(false);\r\n    var attrIndices = [], attrNodes = [];\r\n    while (0 < nodeList.length) {\r\n      // var node = nodeList.shift();\r\n      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);\r\n    }\r\n    nodeMultiSet.finalize();\r\n    for (var i = attrNodes.length-1; i >= 0; --i) {\r\n      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);\r\n      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);\r\n      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);\r\n    }\r\n    return nodeMultiSet;\r\n  }\r\n  /**\r\n   */\r\n  function ancestorHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\r\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\r\n    var ancestors = []; // array of non-empty arrays of matching ancestors\r\n    for (var i = 0; i < nodeList.length; ++i) {\r\n      var node = nodeList[i];\r\n      var isFirst = true;\r\n      var a = [];\r\n      while (null != node) {\r\n        if (!isFirst || andSelf) {\r\n          if (matcher.matches(node))\r\n            a.push(node);\r\n        }\r\n        isFirst = false;\r\n        node = node.parentNode || node.ownerElement;\r\n      }\r\n      if (0 < a.length)\r\n        ancestors.push(a);\r\n    }\r\n    var lasts = [];\r\n    for (var i = 0; i < ancestors.length; ++i) lasts.push(ancestors[i].length);\r\n    var nodeMultiSet = new NodeMultiSet(true);\r\n    var newCtx = {nodes:[], pos:[], lasts:[]};\r\n    while (0 < ancestors.length) {\r\n      var pos = [ancestors[0].length];\r\n      var last = [lasts[0]];\r\n      var node = ancestors[0].pop();\r\n      for (var i = ancestors.length - 1; i > 0; --i) {\r\n        if (node === ancestors[i][ancestors[i].length - 1]) {\r\n          pos.push(ancestors[i].length);\r\n          last.push(lasts[i]);\r\n          ancestors[i].pop();\r\n          if (0 === ancestors[i].length) {\r\n            ancestors.splice(i, i+1);\r\n            lasts.splice(i, i+1);\r\n          }\r\n        }\r\n      }\r\n      if (0 === ancestors[0].length) {\r\n        ancestors.shift();\r\n        lasts.shift();\r\n      }\r\n      newCtx.nodes.push(node);\r\n      newCtx.pos.push(pos);\r\n      newCtx.lasts.push(last);\r\n    }\r\n    return newCtx;\r\n  }\r\n  /** Helper function for sortDocumentOrder. Returns a list of indices, from the\r\n   * node to the root, of positions within parent.\r\n   * For convenience, the node is the first element of the array.\r\n   */\r\n  function addressVector(node) {\r\n    var r = [node];\r\n    if (null != node.ownerElement) {\r\n      node = node.ownerElement;\r\n      r.push(-1);\r\n    }\r\n    while (null != node) {\r\n      var i = 0;\r\n      while (null != node.previousSibling) {\r\n        node = node.previousSibling;\r\n        i++;\r\n      }\r\n      r.push(i);\r\n      node = node.parentNode\r\n    }\r\n    return r;\r\n  }\r\n  function addressComparator(a, b) {\r\n    var minlen = Math.min(a.length - 1, b.length - 1),  // not including [0]=node\r\n        alen = a.length,\r\n        blen = b.length;\r\n    if (a[0] === b[0]) return 0;\r\n    var c;\r\n    for (var i = 0; i < minlen; ++i) {\r\n      c = a[alen - i - 1] - b[blen - i - 1];\r\n      if (0 !== c)\r\n        break;\r\n    }\r\n    if (null == c || 0 === c) {\r\n      // All equal until one of the nodes. The longer one is the descendant.\r\n      c = alen - blen;\r\n    }\r\n    if (0 === c)\r\n      c = getNodeName(a) - getNodeName(b);\r\n    if (0 === c)\r\n      c = 1;\r\n    return c;\r\n  }\r\n  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function(nodes) {\r\n    var a = [];\r\n    for (var i = 0; i < nodes.length; i++) {\r\n      var node = nodes[i];\r\n      var v = addressVector(node);\r\n      a.push(v);\r\n    }\r\n    a.sort(addressComparator);\r\n    var b = [];\r\n    for (var i = 0; i < a.length; i++) {\r\n      if (0 < i && a[i][0] === a[i - 1][0])\r\n        continue;\r\n      b.push(a[i][0]);\r\n    }\r\n    return b;\r\n  }\r\n  /** Sort node multiset. Does not do any de-duping. */\r\n  function sortNodeMultiSet(nodeMultiSet) {\r\n    var a = [];\r\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\r\n      var v = addressVector(nodeMultiSet.nodes[i]);\r\n      a.push({v:v, n:nodeMultiSet.nodes[i],\r\n              p:nodeMultiSet.pos[i], l:nodeMultiSet.lasts[i]});\r\n    }\r\n    a.sort(compare);\r\n    var r = {nodes:[], pos:[], lasts:[]};\r\n    for (var i = 0; i < a.length; ++i) {\r\n      r.nodes.push(a[i].n);\r\n      r.pos.push(a[i].p);\r\n      r.lasts.push(a[i].l);\r\n    }\r\n    function compare(x, y) {\r\n      return addressComparator(x.v, y.v);\r\n    }\r\n    return r;\r\n  }\r\n  /** Returns an array containing all the ancestors down to a node.\r\n   * The array starts with document.\r\n   */\r\n  function nodeAndAncestors(node) {\r\n    var ancestors = [node];\r\n    var p = node;\r\n    while (p = p.parentNode || p.ownerElement) {\r\n      ancestors.unshift(p);\r\n    }\r\n    return ancestors;\r\n  }\r\n  function compareSiblings(a, b) {\r\n    if (a === b) return 0;\r\n    var c = a;\r\n    while (c = c.previousSibling) {\r\n      if (c === b)\r\n        return 1;  // b < a\r\n    }\r\n    c = b;\r\n    while (c = c.previousSibling) {\r\n      if (c === a)\r\n        return -1;  // a < b\r\n    }\r\n    throw new Error('a and b are not siblings: ' + xpath.stringifyObject(a) + ' vs ' + xpath.stringifyObject(b));\r\n  }\r\n  /** The merge in merge-sort.*/\r\n  function mergeNodeLists(x, y) {\r\n    var a, b, aanc, banc, r = [];\r\n    if ('object' !== typeof x)\r\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                               'Invalid LHS for | operator ' +\r\n                               '(expected node-set): ' + x);\r\n    if ('object' !== typeof y)\r\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                               'Invalid LHS for | operator ' +\r\n                               '(expected node-set): ' + y);\r\n    while (true) {\r\n      if (null == a) {\r\n        a = x.shift();\r\n        if (null != a)\r\n          aanc = addressVector(a);\r\n      }\r\n      if (null == b) {\r\n        b = y.shift();\r\n        if (null != b)\r\n          banc = addressVector(b);\r\n      }\r\n      if (null == a || null == b) break;\r\n      var c = addressComparator(aanc, banc);\r\n      if (c < 0) {\r\n        r.push(a);\r\n        a = null;\r\n        aanc = null;\r\n      } else if (c > 0) {\r\n        r.push(b);\r\n        b = null;\r\n        banc = null;\r\n      } else if (getNodeName(a) < getNodeName(b)) {  // attributes\r\n        r.push(a);\r\n        a = null;\r\n        aanc = null;\r\n      } else if (getNodeName(a) > getNodeName(b)) {  // attributes\r\n        r.push(b);\r\n        b = null;\r\n        banc = null;\r\n      } else if (a !== b) {\r\n        // choose b arbitrarily\r\n        r.push(b);\r\n        b = null;\r\n        banc = null;\r\n      } else {\r\n        console.assert(a === b, c);\r\n        // just skip b without pushing it.\r\n        b = null;\r\n        banc = null;\r\n      }\r\n    }\r\n    while (a) {\r\n      r.push(a);\r\n      a = x.shift();\r\n    }\r\n    while (b) {\r\n      r.push(b);\r\n      b = y.shift();\r\n    }\r\n    return r;\r\n  }\r\n  function comparisonHelper(test, x, y, isNumericComparison) {\r\n    var coersion;\r\n    if (isNumericComparison)\r\n      coersion = fn.number;\r\n    else coersion =\r\n      'boolean' === typeof x || 'boolean' === typeof y ? fn['boolean'] :\r\n      'number' === typeof x || 'number' === typeof y ? fn.number :\r\n      fn.string;\r\n    if ('object' === typeof x && 'object' === typeof y) {\r\n      var aMap = {};\r\n      for (var i = 0; i < x.nodes.length; ++i) {\r\n        var xi = coersion({nodes:[x.nodes[i]]});\r\n        for (var j = 0; j < y.nodes.length; ++j) {\r\n          var yj = coersion({nodes:[y.nodes[j]]});\r\n          if (test(xi, yj)) return true;\r\n        }\r\n      }\r\n      return false;\r\n    } else if ('object' === typeof x && x.nodes && x.nodes.length) {\r\n      for (var i = 0; i < x.nodes.length; ++i) {\r\n        var xi = coersion({nodes:[x.nodes[i]]}), yc = coersion(y);\r\n        if (test(xi, yc))\r\n          return true;\r\n      }\r\n      return false;\r\n    } else if ('object' === typeof y && x.nodes && x.nodes.length) {\r\n      for (var i = 0; i < x.nodes.length; ++i) {\r\n        var yi = coersion({nodes:[y.nodes[i]]}), xc = coersion(x);\r\n        if (test(xc, yi))\r\n          return true;\r\n      }\r\n      return false;\r\n    } else {\r\n      var xc = coersion(x), yc = coersion(y);\r\n      return test(xc, yc);\r\n    }\r\n  }\r\n  var axes = xpath.axes = {\r\n    'ancestor':\r\n      function ancestor(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        return ancestorHelper(\r\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\r\n      },\r\n    'ancestor-or-self':\r\n      function ancestorOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        return ancestorHelper(\r\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\r\n      },\r\n    'attribute':\r\n      function attribute(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        // TODO: figure out whether positions should be undefined here.\r\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\r\n        var nodeMultiSet = new NodeMultiSet(false);\r\n        if (null != nodeName) {\r\n          // TODO: with namespace\r\n          for (var i = 0; i < nodeList.length; ++i) {\r\n            var node = nodeList[i];\r\n            if (null == node.getAttributeNode)\r\n              continue;  // only Element has .getAttributeNode\r\n            var attr = node.getAttributeNode(nodeName);\r\n            if (null != attr && matcher.matches(attr)) {\r\n              nodeMultiSet.pushSeries();\r\n              nodeMultiSet.addNode(attr);\r\n              nodeMultiSet.popSeries();\r\n            }\r\n          }\r\n        } else {\r\n          for (var i = 0; i < nodeList.length; ++i) {\r\n            var node = nodeList[i];\r\n            if (null != node.attributes) {\r\n              nodeMultiSet.pushSeries();\r\n              for (var j = 0; j < node.attributes.length; j++) {  // all nodes have .attributes\r\n                var attr = node.attributes[j];\r\n                if (matcher.matches(attr))  // TODO: I think this check is unnecessary\r\n                  nodeMultiSet.addNode(attr);\r\n              }\r\n              nodeMultiSet.popSeries();\r\n            }\r\n          }\r\n        }\r\n        return nodeMultiSet.finalize();\r\n      },\r\n    'child':\r\n      function child(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\r\n        var nodeMultiSet = new NodeMultiSet(false);\r\n        for (var i = 0; i < nodeList.length; ++i) {\r\n          var n = nodeList[i];\r\n          if (n.ownerElement)  // skip attribute nodes' text child.\r\n            continue;\r\n          if (n.childNodes) {\r\n            nodeMultiSet.pushSeries();\r\n            var childList = 1 === nodeTypeNum && null != n.children ?\r\n                n.children : n.childNodes;\r\n            for (var j = 0; j < childList.length; ++j) {\r\n              var child = childList[j];\r\n              if (matcher.matches(child)) {\r\n                nodeMultiSet.addNode(child);\r\n              }\r\n              // don't have to do de-duping because children have parent,\r\n              // which are current context.\r\n            }\r\n            nodeMultiSet.popSeries();\r\n          }\r\n        }\r\n        nodeMultiSet.finalize();\r\n        return sortNodeMultiSet(nodeMultiSet);\r\n      },\r\n    'descendant':\r\n      function descenant(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        return descenantHelper(\r\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\r\n      },\r\n    'descendant-or-self':\r\n      function descenantOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        return descenantHelper(\r\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\r\n      },\r\n    'following':\r\n      function following(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        return followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\r\n      },\r\n    'following-sibling':\r\n      function followingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        return followingSiblingHelper(\r\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\r\n          Array.prototype.shift, function() {return this[0];},\r\n          function(node) {return node.nextSibling;});\r\n      },\r\n    'namespace':\r\n      function namespace(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        // TODO\r\n      },\r\n    'parent':\r\n      function parent(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\r\n        var nodes = [], pos = [];\r\n        for (var i = 0; i < nodeList.length; ++i) {\r\n          var parent = nodeList[i].parentNode || nodeList[i].ownerElement;\r\n          if (null == parent)\r\n            continue;\r\n          if (!matcher.matches(parent))\r\n            continue;\r\n          if (nodes.length > 0 && parent === nodes[nodes.length-1])\r\n            continue;\r\n          nodes.push(parent);\r\n          pos.push([1]);\r\n        }\r\n        return {nodes:nodes, pos:pos, lasts:pos};\r\n      },\r\n    'preceding':\r\n      function preceding(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        return precedingHelper(\r\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\r\n      },\r\n    'preceding-sibling':\r\n      function precedingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        return followingSiblingHelper(\r\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\r\n          Array.prototype.pop, function() {return this[this.length-1];},\r\n          function(node) {return node.previousSibling},\r\n          false, true);\r\n      },\r\n    'self':\r\n      function self(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\r\n        var nodes = [], pos = [];\r\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\r\n        for (var i = 0; i < nodeList.length; ++i) {\r\n          if (matcher.matches(nodeList[i])) {\r\n            nodes.push(nodeList[i]);\r\n            pos.push([1]);\r\n          }\r\n        }\r\n        return {nodes: nodes, pos: pos, lasts: pos}\r\n      }\r\n  };\r\n\r\n  /***************************************************************************\r\n   *                         Evaluation: functions                           *\r\n   ***************************************************************************/\r\n  var fn = {\r\n    'number': function number(optObject) {\r\n      if ('number' === typeof optObject)\r\n        return optObject;\r\n      if ('string' === typeof optObject)\r\n        return parseFloat(optObject);  // note: parseFloat(' ') -> NaN, unlike +' ' -> 0.\r\n      if ('boolean' === typeof optObject)\r\n        return +optObject;\r\n      return fn.number(fn.string.call(this, optObject));  // for node-sets\r\n    },\r\n    'string': function string(optObject) {\r\n      if (null == optObject)\r\n        return fn.string(this);\r\n      if ('string' === typeof optObject || 'boolean' === typeof optObject ||\r\n          'number' === typeof optObject)\r\n        return '' + optObject;\r\n      if (0 == optObject.nodes.length) return '';\r\n      if (null != optObject.nodes[0].textContent)\r\n        return optObject.nodes[0].textContent;\r\n      return optObject.nodes[0].nodeValue;\r\n    },\r\n    'boolean': function booleanVal(x) {\r\n      return 'object' === typeof x ? x.nodes.length > 0 : !!x;\r\n    },\r\n    'last': function last() {\r\n      console.assert(Array.isArray(this.pos));\r\n      console.assert(Array.isArray(this.lasts));\r\n      console.assert(1 === this.pos.length);\r\n      console.assert(1 === this.lasts.length);\r\n      console.assert(1 === this.lasts[0].length);\r\n      return this.lasts[0][0];\r\n    },\r\n    'position': function position() {\r\n      console.assert(Array.isArray(this.pos));\r\n      console.assert(Array.isArray(this.lasts));\r\n      console.assert(1 === this.pos.length);\r\n      console.assert(1 === this.lasts.length);\r\n      console.assert(1 === this.pos[0].length);\r\n      return this.pos[0][0];\r\n    },\r\n    'count': function count(nodeSet) {\r\n      if ('object' !== typeof nodeSet)\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Position ' + stream.position() +\r\n                                 ': Function count(node-set) ' +\r\n                                 'got wrong argument type: ' + nodeSet);\r\n      return nodeSet.nodes.length;\r\n    },\r\n    'id': function id(object) {\r\n      var r = {nodes: []};\r\n      var doc = this.nodes[0].ownerDocument || this.nodes[0];\r\n      console.assert(doc);\r\n      var ids;\r\n      if ('object' === typeof object) {\r\n        // for node-sets, map id over each node value.\r\n        ids = [];\r\n        for (var i = 0; i < object.nodes.length; ++i) {\r\n          var idNode = object.nodes[i];\r\n          var idsString = fn.string({nodes:[idNode]});\r\n          var a = idsString.split(/[ \\t\\r\\n]+/g);\r\n          Array.prototype.push.apply(ids, a);\r\n        }\r\n      } else {\r\n        var idsString = fn.string(object);\r\n        var a = idsString.split(/[ \\t\\r\\n]+/g);\r\n        ids = a;\r\n      }\r\n      for (var i = 0; i < ids.length; ++i) {\r\n        var id = ids[i];\r\n        if (0 === id.length)\r\n          continue;\r\n        var node = doc.getElementById(id);\r\n        if (null != node)\r\n          r.nodes.push(node);\r\n      }\r\n      r.nodes = sortUniqDocumentOrder(r.nodes);\r\n      return r;\r\n    },\r\n    'local-name': function(nodeSet) {\r\n      if (null == nodeSet)\r\n        return fn.name(this);\r\n      if (null == nodeSet.nodes) {\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'argument to name() must be a node-set. got ' + nodeSet);\r\n      }\r\n      // TODO: namespaced version\r\n      return nodeSet.nodes[0].localName;\r\n    },\r\n    'namespace-uri': function(nodeSet) {\r\n      // TODO\r\n      throw new Error('not implemented yet');\r\n    },\r\n    'name': function(nodeSet) {\r\n      if (null == nodeSet)\r\n        return fn.name(this);\r\n      if (null == nodeSet.nodes) {\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'argument to name() must be a node-set. got ' + nodeSet);\r\n      }\r\n      return nodeSet.nodes[0].name;\r\n    },\r\n    'concat': function concat(x) {\r\n      var l = [];\r\n      for (var i = 0; i < arguments.length; ++i) {\r\n        l.push(fn.string(arguments[i]));\r\n      }\r\n      return l.join('');\r\n    },\r\n    'starts-with': function startsWith(a, b) {\r\n      var as = fn.string(a), bs = fn.string(b);\r\n      return as.substr(0, bs.length) === bs;\r\n    },\r\n    'contains': function contains(a, b) {\r\n      var as = fn.string(a), bs = fn.string(b);\r\n      var i = as.indexOf(bs);\r\n      if (-1 === i) return false;\r\n      return true;\r\n    },\r\n    'substring-before': function substringBefore(a, b) {\r\n      var as = fn.string(a), bs = fn.string(b);\r\n      var i = as.indexOf(bs);\r\n      if (-1 === i) return '';\r\n      return as.substr(0, i);\r\n    },\r\n    'substring-after': function substringBefore(a, b) {\r\n      var as = fn.string(a), bs = fn.string(b);\r\n      var i = as.indexOf(bs);\r\n      if (-1 === i) return '';\r\n      return as.substr(i + bs.length);\r\n    },\r\n    'substring': function substring(string, start, optEnd) {\r\n      if (null == string || null == start) {\r\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                 'Must be at least 2 arguments to string()');\r\n      }\r\n      var sString = fn.string(string),\r\n          iStart = fn.round(start),\r\n          iEnd = optEnd == null ? null : fn.round(optEnd);\r\n      // Note that xpath string positions user 1-based index\r\n      if (iEnd == null)\r\n        return sString.substr(iStart - 1);\r\n      else\r\n        return sString.substr(iStart - 1, iEnd);\r\n    },\r\n    'string-length': function stringLength(optString) {\r\n      return fn.string.call(this, optString).length;\r\n    },\r\n    'normalize-space': function normalizeSpace(optString) {\r\n      var s = fn.string.call(this, optString);\r\n      return s.replace(/[ \\t\\r\\n]+/g, ' ').replace(/^ | $/g, '');\r\n    },\r\n    'translate': function translate(string, from, to) {\r\n      var sString = fn.string.call(this, string),\r\n          sFrom = fn.string(from),\r\n          sTo = fn.string(to);\r\n      var eachCharRe = [];\r\n      var map = {};\r\n      for (var i = 0; i < sFrom.length; ++i) {\r\n        var c = sFrom.charAt(i);\r\n        map[c] = sTo.charAt(i);  // returns '' if beyond length of sTo.\r\n        // copied from goog.string.regExpEscape in the Closure library.\r\n        eachCharRe.push(\r\n          c.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').\r\n            replace(/\\x08/g, '\\\\x08'));\r\n      }\r\n      var re = new RegExp(eachCharRe.join('|'), 'g');\r\n      return sString.replace(re, function(c) {return map[c];});\r\n    },\r\n    /// Boolean functions\r\n    'not': function not(x) {\r\n      var bx = fn['boolean'](x);\r\n      return !bx;\r\n    },\r\n    'true': function trueVal() { return true; },\r\n    'false': function falseVal() { return false; },\r\n    // TODO\r\n    'lang': function lang(string) { throw new Error('Not implemented');},\r\n    'sum': function sum(optNodeSet) {\r\n      if (null == optNodeSet) return fn.sum(this);\r\n      // for node-sets, map id over each node value.\r\n      var sum = 0;\r\n      for (var i = 0; i < optNodeSet.nodes.length; ++i) {\r\n        var node = optNodeSet.nodes[i];\r\n        var x = fn.number({nodes:[node]});\r\n        sum += x;\r\n      }\r\n      return sum;\r\n    },\r\n    'floor': function floor(number) {\r\n      return Math.floor(fn.number(number));\r\n    },\r\n    'ceiling': function ceiling(number) {\r\n      return Math.ceil(fn.number(number));\r\n    },\r\n    'round': function round(number) {\r\n      return Math.round(fn.number(number));\r\n    }\r\n  };\r\n  /***************************************************************************\r\n   *                         Evaluation: operators                           *\r\n   ***************************************************************************/\r\n  var more = {\r\n    UnaryMinus: function(x) { return -fn.number(x); },\r\n    '+': function(x, y) { return fn.number(x) + fn.number(y); },\r\n    '-': function(x, y) { return fn.number(x) - fn.number(y); },\r\n    '*': function(x, y) { return fn.number(x) * fn.number(y); },\r\n    'div': function(x, y) { return fn.number(x) / fn.number(y); },\r\n    'mod': function(x, y) { return fn.number(x) % fn.number(y); },\r\n    '<': function(x, y) {\r\n      return comparisonHelper(function(x, y) { return fn.number(x) < fn.number(y);}, x, y, true);\r\n    },\r\n    '<=': function(x, y) {\r\n      return comparisonHelper(function(x, y) { return fn.number(x) <= fn.number(y);}, x, y, true);\r\n    },\r\n    '>':  function(x, y) {\r\n      return comparisonHelper(function(x, y) { return fn.number(x) > fn.number(y);}, x, y, true);\r\n    },\r\n    '>=': function(x, y) {\r\n      return comparisonHelper(function(x, y) { return fn.number(x) >= fn.number(y);}, x, y, true);\r\n    },\r\n    'and': function(x, y) { return fn['boolean'](x) && fn['boolean'](y); },\r\n    'or': function(x, y) { return fn['boolean'](x) || fn['boolean'](y); },\r\n    '|': function(x, y) { return {nodes: mergeNodeLists(x.nodes, y.nodes)}; },\r\n    '=': function(x, y) {\r\n      // optimization for two node-sets case: avoid n^2 comparisons.\r\n      if ('object' === typeof x && 'object' === typeof y) {\r\n        var aMap = {};\r\n        for (var i = 0; i < x.nodes.length; ++i) {\r\n          var s = fn.string({nodes:[x.nodes[i]]});\r\n          aMap[s] = true;\r\n        }\r\n        for (var i = 0; i < y.nodes.length; ++i) {\r\n          var s = fn.string({nodes:[y.nodes[i]]});\r\n          if (aMap[s]) return true;\r\n        }\r\n        return false;\r\n      } else {\r\n        return comparisonHelper(function(x, y) {return x === y;}, x, y);\r\n      }\r\n    },\r\n    '!=': function(x, y) {\r\n      // optimization for two node-sets case: avoid n^2 comparisons.\r\n      if ('object' === typeof x && 'object' === typeof y) {\r\n        if (0 === x.nodes.length || 0 === y.nodes.length) return false;\r\n        var aMap = {};\r\n        for (var i = 0; i < x.nodes.length; ++i) {\r\n          var s = fn.string({nodes:[x.nodes[i]]});\r\n          aMap[s] = true;\r\n        }\r\n        for (var i = 0; i < y.nodes.length; ++i) {\r\n          var s = fn.string({nodes:[y.nodes[i]]});\r\n          if (!aMap[s]) return true;\r\n        }\r\n        return false;\r\n      } else {\r\n        return comparisonHelper(function(x, y) {return x !== y;}, x, y);\r\n      }\r\n    }\r\n  };\r\n  var nodeTypes = xpath.nodeTypes = {\r\n    'node': 0,\r\n    'attribute': 2,\r\n    'comment': 8, // this.doc.COMMENT_NODE,\r\n    'text': 3, // this.doc.TEXT_NODE,\r\n    'processing-instruction': 7, // this.doc.PROCESSING_INSTRUCTION_NODE,\r\n    'element': 1  //this.doc.ELEMENT_NODE\r\n  };\r\n  /** For debugging and unit tests: returnjs a stringified version of the\r\n   * argument. */\r\n  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {\r\n    var seenKey = 'seen' + Math.floor(Math.random()*1000000000);\r\n    return JSON.stringify(helper(ctx));\r\n\r\n    function helper(ctx) {\r\n      if (Array.isArray(ctx)) {\r\n        return ctx.map(function(x) {return helper(x);});\r\n      }\r\n      if ('object' !== typeof ctx) return ctx;\r\n      if (null == ctx) return ctx;\r\n    //  if (ctx.toString) return ctx.toString();\r\n      if (null != ctx.outerHTML) return ctx.outerHTML;\r\n      if (null != ctx.nodeValue) return ctx.nodeName + '=' + ctx.nodeValue;\r\n      if (ctx[seenKey]) return '[circular]';\r\n      ctx[seenKey] = true;\r\n      var nicer = {};\r\n      for (var key in ctx) {\r\n        if (seenKey === key)\r\n          continue;\r\n        try {\r\n          nicer[key] = helper(ctx[key]);\r\n        } catch (e) {\r\n          nicer[key] = '[exception: ' + e.message + ']';\r\n        }\r\n      }\r\n      delete ctx[seenKey];\r\n      return nicer;\r\n    }\r\n  }\r\n  var Evaluator = xpath.Evaluator = function Evaluator(doc) {\r\n    this.doc = doc;\r\n  }\r\n  Evaluator.prototype = {\r\n    val: function val(ast, ctx) {\r\n      console.assert(ctx.nodes);\r\n\r\n      if ('number' === typeof ast || 'string' === typeof ast) return ast;\r\n      if (more[ast[0]]) {\r\n        var evaluatedParams = [];\r\n        for (var i = 1; i < ast.length; ++i) {\r\n          evaluatedParams.push(this.val(ast[i], ctx));\r\n        }\r\n        var r = more[ast[0]].apply(ctx, evaluatedParams);\r\n        return r;\r\n      }\r\n      switch (ast[0]) {\r\n        case 'Root': return {nodes: [this.doc]};\r\n        case 'FunctionCall':\r\n          var functionName = ast[1], functionParams = ast[2];\r\n          if (null == fn[functionName])\r\n            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\r\n                                     'Unknown function: ' + functionName);\r\n          var evaluatedParams = [];\r\n          for (var i = 0; i < functionParams.length; ++i) {\r\n            evaluatedParams.push(this.val(functionParams[i], ctx));\r\n          }\r\n          var r = fn[functionName].apply(ctx, evaluatedParams);\r\n          return r;\r\n        case 'Predicate':\r\n          var lhs = this.val(ast[1], ctx);\r\n          var ret = {nodes: []};\r\n          var contexts = eachContext(lhs);\r\n          for (var i = 0; i < contexts.length; ++i) {\r\n            var singleNodeSet = contexts[i];\r\n            var rhs = this.val(ast[2], singleNodeSet);\r\n            var success;\r\n            if ('number' === typeof rhs) {\r\n              success = rhs === singleNodeSet.pos[0][0];\r\n            } else {\r\n              success = fn['boolean'](rhs);\r\n            }\r\n            if (success) {\r\n              var node = singleNodeSet.nodes[0];\r\n              ret.nodes.push(node);\r\n              // skip over all the rest of the same node.\r\n              while (i+1 < contexts.length && node === contexts[i+1].nodes[0]) {\r\n                i++;\r\n              }\r\n            }\r\n          }\r\n          return ret;\r\n        case 'PathExpr':\r\n          // turn the path into an expressoin; i.e., remove the position\r\n          // information of the last axis.\r\n          var x = this.val(ast[1], ctx);\r\n          // Make the nodeset a forward-direction-only one.\r\n          if (x.finalize) {  // it is a NodeMultiSet\r\n            return {nodes: x.nodes};\r\n          } else {\r\n            return x;\r\n          }\r\n        case '/':\r\n          // TODO: don't generate '/' nodes, just Axis nodes.\r\n          var lhs = this.val(ast[1], ctx);\r\n          console.assert(null != lhs);\r\n          var r = this.val(ast[2], lhs);\r\n          console.assert(null != r);\r\n          return r;\r\n        case 'Axis':\r\n          // All the axis tests from Step. We only get AxisSpecifier NodeTest,\r\n          // not the predicate (which is applied later)\r\n          var axis = ast[1],\r\n              nodeType = ast[2],\r\n              nodeTypeNum = nodeTypes[nodeType],\r\n              shouldLowerCase = true,  // TODO: give option\r\n              nodeName = ast[3] && shouldLowerCase ? ast[3].toLowerCase() : ast[3];\r\n          nodeName = nodeName === '*' ? null : nodeName;\r\n          if ('object' !== typeof ctx) return {nodes:[], pos:[]};\r\n          var nodeList = ctx.nodes.slice();  // TODO: is copy needed?\r\n          var r = axes[axis](nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\r\n          return r;\r\n      }\r\n    }\r\n  };\r\n  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {\r\n    //var astFactory = new AstEvaluatorFactory(doc, context);\r\n    var stream = new Stream(expr);\r\n    var ast = parse(stream, astFactory);\r\n    var val = new Evaluator(doc).val(ast, {nodes: [context]});\r\n    return val;\r\n  }\r\n\r\n  /***************************************************************************\r\n   *                           DOM interface                                 *\r\n   ***************************************************************************/\r\n  var XPathException = xpath.XPathException = function XPathException(code, message) {\r\n    var e = new Error(message);\r\n    e.name = 'XPathException';\r\n    e.code = code;\r\n    return e;\r\n  }\r\n  XPathException.INVALID_EXPRESSION_ERR = 51;\r\n  XPathException.TYPE_ERR = 52;\r\n\r\n\r\n  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {}\r\n  XPathEvaluator.prototype = {\r\n    createExpression: function(expression, resolver) {\r\n      return new XPathExpression(expression, resolver);\r\n    },\r\n    createNSResolver: function(nodeResolver) {\r\n      // TODO\r\n    },\r\n    evaluate: function evaluate(expression, contextNode, resolver, type, result) {\r\n      var expr = new XPathExpression(expression, resolver);\r\n      return expr.evaluate(contextNode, type, result);\r\n    }\r\n  };\r\n\r\n\r\n  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {\r\n    var stream = new Stream(expression);\r\n    this._ast = parse(stream, astFactory);\r\n    this._doc = optDoc;\r\n  }\r\n  XPathExpression.prototype = {\r\n    evaluate: function evaluate(contextNode, type, result) {\r\n      if (null == contextNode.nodeType)\r\n        throw new Error('bad argument (expected context node): ' + contextNode);\r\n      var doc = contextNode.ownerDocument || contextNode;\r\n      if (null != this._doc && this._doc !== doc) {\r\n        throw new core.DOMException(\r\n            core.DOMException.WRONG_DOCUMENT_ERR,\r\n            'The document must be the same as the context node\\'s document.');\r\n      }\r\n      var evaluator = new Evaluator(doc);\r\n      var value = evaluator.val(this._ast, {nodes: [contextNode]});\r\n      if (XPathResult.NUMBER_TYPE === type)\r\n        value = fn.number(value);\r\n      else if (XPathResult.STRING_TYPE === type)\r\n        value = fn.string(value);\r\n      else if (XPathResult.BOOLEAN_TYPE === type)\r\n        value = fn['boolean'](value);\r\n      else if (XPathResult.ANY_TYPE !== type &&\r\n               XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type &&\r\n               XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type &&\r\n               XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type &&\r\n               XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type &&\r\n               XPathResult.ANY_UNORDERED_NODE_TYPE !== type &&\r\n               XPathResult.FIRST_ORDERED_NODE_TYPE !== type)\r\n        throw new core.DOMException(\r\n            core.DOMException.NOT_SUPPORTED_ERR,\r\n            'You must provide an XPath result type (0=any).');\r\n      else if (XPathResult.ANY_TYPE !== type &&\r\n               'object' !== typeof value)\r\n        throw new XPathException(\r\n            XPathException.TYPE_ERR,\r\n            'Value should be a node-set: ' + value);\r\n      return new XPathResult(doc, value, type);\r\n    }\r\n  }\r\n\r\n  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {\r\n    this._value = value;\r\n    this._resultType = resultType;\r\n    this._i = 0;\r\n\r\n    // TODO: we removed mutation events but didn't take care of this. No tests fail, so that's nice, but eventually we\r\n    // should fix this, preferably by entirely replacing our XPath implementation.\r\n    // this._invalidated = false;\r\n    // if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||\r\n    //     this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\r\n    //   doc.addEventListener('DOMSubtreeModified', invalidate, true);\r\n    //   var self = this;\r\n    //   function invalidate() {\r\n    //     self._invalidated = true;\r\n    //     doc.removeEventListener('DOMSubtreeModified', invalidate, true);\r\n    //   }\r\n    // }\r\n  }\r\n  XPathResult.ANY_TYPE = 0;\r\n  XPathResult.NUMBER_TYPE = 1;\r\n  XPathResult.STRING_TYPE = 2;\r\n  XPathResult.BOOLEAN_TYPE = 3;\r\n  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\r\n  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\r\n  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\r\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\r\n  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;\r\n  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;\r\n  var proto = {\r\n    // XPathResultType\r\n    get resultType() {\r\n      if (this._resultType) return this._resultType;\r\n      switch (typeof this._value) {\r\n        case 'number': return XPathResult.NUMBER_TYPE;\r\n        case 'string': return XPathResult.STRING_TYPE;\r\n        case 'boolean': return XPathResult.BOOLEAN_TYPE;\r\n        default: return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\r\n      }\r\n    },\r\n    get numberValue() {\r\n      if (XPathResult.NUMBER_TYPE !== this.resultType)\r\n        throw new XPathException(XPathException.TYPE_ERR,\r\n                                 'You should have asked for a NUMBER_TYPE.');\r\n      return this._value;\r\n    },\r\n    get stringValue() {\r\n      if (XPathResult.STRING_TYPE !== this.resultType)\r\n        throw new XPathException(XPathException.TYPE_ERR,\r\n                                 'You should have asked for a STRING_TYPE.');\r\n      return this._value;\r\n    },\r\n    get booleanValue() {\r\n      if (XPathResult.BOOLEAN_TYPE !== this.resultType)\r\n        throw new XPathException(XPathException.TYPE_ERR,\r\n                                 'You should have asked for a BOOLEAN_TYPE.');\r\n      return this._value;\r\n    },\r\n    get singleNodeValue() {\r\n      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType &&\r\n          XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType)\r\n        throw new XPathException(\r\n            XPathException.TYPE_ERR,\r\n            'You should have asked for a FIRST_ORDERED_NODE_TYPE.');\r\n      return this._value.nodes[0] || null;\r\n    },\r\n    get invalidIteratorState() {\r\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\r\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\r\n        return false;\r\n      return !!this._invalidated;\r\n    },\r\n    get snapshotLength() {\r\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\r\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\r\n        throw new XPathException(\r\n            XPathException.TYPE_ERR,\r\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\r\n      return this._value.nodes.length;\r\n    },\r\n    iterateNext: function iterateNext() {\r\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\r\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\r\n        throw new XPathException(\r\n            XPathException.TYPE_ERR,\r\n            'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.');\r\n      if (this.invalidIteratorState)\r\n        throw new core.DOMException(\r\n            core.DOMException.INVALID_STATE_ERR,\r\n            'The document has been mutated since the result was returned');\r\n      return this._value.nodes[this._i++] || null;\r\n    },\r\n    snapshotItem: function snapshotItem(index) {\r\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\r\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\r\n        throw new XPathException(\r\n            XPathException.TYPE_ERR,\r\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\r\n      return this._value.nodes[index] || null;\r\n    }\r\n  };\r\n  // so you can access ANY_TYPE etc. from the instances:\r\n  XPathResult.prototype = Object.create(XPathResult,\r\n      Object.keys(proto).reduce(function (descriptors, name) {\r\n        descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);\r\n        return descriptors;\r\n      }, {\r\n        constructor: {\r\n          value: XPathResult,\r\n          writable: true,\r\n          configurable: true\r\n        }\r\n      }));\r\n\r\n  core.XPathException = XPathException;\r\n  core.XPathExpression = XPathExpression;\r\n  core.XPathResult = XPathResult;\r\n  core.XPathEvaluator = XPathEvaluator;\r\n\r\n  core.Document.prototype.createExpression =\r\n    XPathEvaluator.prototype.createExpression;\r\n\r\n  core.Document.prototype.createNSResolver =\r\n      XPathEvaluator.prototype.createNSResolver;\r\n\r\n  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;\r\n\r\n  return xpath; // for tests\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}