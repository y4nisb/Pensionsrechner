{"ast":null,"code":"\"use strict\";\n\nconst whatwgURL = require(\"whatwg-url\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\nconst notImplemented = require(\"../../browser/not-implemented.js\");\nconst idlUtils = require(\"../generated/utils.js\");\nconst {\n  fireAnEvent\n} = require(\"../helpers/events\");\n\n// https://html.spec.whatwg.org/#session-history\nclass SessionHistory {\n  constructor(initialEntry, window) {\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n      fn();\n    }, 0);\n    this._historyTraversalQueue.add(timeoutId);\n  }\n  clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n    this._historyTraversalQueue.clear();\n  }\n  get length() {\n    return this._entries.length;\n  }\n  get currentEntry() {\n    return this._entries[this._currentIndex];\n  }\n\n  // https://html.spec.whatwg.org/#dom-history-pushstate\n  removeAllEntriesAfterCurrentEntry() {\n    this._entries.splice(this._currentIndex + 1, Infinity);\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n  traverseByDelta(delta) {\n    this._queueHistoryTraversalTask(() => {\n      const newIndex = this._currentIndex + delta;\n      if (newIndex < 0 || newIndex >= this.length) {\n        return;\n      }\n      const specifiedEntry = this._entries[newIndex];\n\n      // Not implemented: unload a document guard\n\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n      this._queueHistoryTraversalTask(() => {\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n        // then cancel that attempt to navigate the browsing context.\n\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\n\n        // this.clearHistoryTraversalTasks();\n\n        if (specifiedEntry.document !== this.currentEntry.document) {\n          // TODO: unload the active document with the recycle parameter set to false\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\n        }\n        this.traverseHistory(specifiedEntry);\n      });\n    });\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history\n  traverseHistory(specifiedEntry) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!specifiedEntry.document) {\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n      // to perform an entry update of entry, and abort these steps\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n    }\n    // Not spec compliant, just minimal. Lots of missing steps.\n\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n    const document = idlUtils.implForWrapper(this._window._document);\n    const {\n      currentEntry\n    } = this;\n\n    // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n    // to the value returned by the document.title IDL attribute.\n    if (currentEntry.title === undefined) {\n      currentEntry.title = document.title;\n    }\n    if (specifiedEntry.document !== currentEntry.document) {\n      // If entry has a different Document object than the current entry, then...\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n    }\n    document._URL = specifiedEntry.url;\n    const hashChanged = specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n    let oldURL, newURL;\n    if (hashChanged) {\n      oldURL = currentEntry.url;\n      newURL = specifiedEntry.url;\n    }\n    if (flags.replacement) {\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n      // specified entry in the session history.\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n    }\n    this.updateCurrentEntry(specifiedEntry);\n    const state = specifiedEntry.stateObject; // TODO structured clone\n\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n    document._history._state = state;\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n    specifiedEntry.document._latestEntry = specifiedEntry;\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n    if (nonBlockingEvents) {\n      this._window.setTimeout(fireEvents, 0);\n    } else {\n      fireEvents();\n    }\n  }\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n    if (stateChanged) {\n      fireAnEvent(\"popstate\", this._windowImpl, PopStateEvent, {\n        state\n      });\n    }\n    if (hashChanged) {\n      fireAnEvent(\"hashchange\", this._windowImpl, HashChangeEvent, {\n        oldURL: whatwgURL.serializeURL(oldURL),\n        newURL: whatwgURL.serializeURL(newURL)\n      });\n    }\n  }\n  addEntryAfterCurrentEntry(entry) {\n    this._entries.splice(this._currentIndex + 1, 0, entry);\n  }\n  updateCurrentEntry(entry) {\n    this._currentIndex = this._entries.indexOf(entry);\n  }\n}\nmodule.exports = SessionHistory;","map":{"version":3,"names":["whatwgURL","require","HashChangeEvent","PopStateEvent","notImplemented","idlUtils","fireAnEvent","SessionHistory","constructor","initialEntry","window","_window","_windowImpl","implForWrapper","_historyTraversalQueue","Set","_entries","_currentIndex","_queueHistoryTraversalTask","fn","timeoutId","setTimeout","delete","add","clearHistoryTraversalTasks","clearTimeout","clear","length","currentEntry","removeAllEntriesAfterCurrentEntry","splice","Infinity","traverseByDelta","delta","newIndex","specifiedEntry","document","traverseHistory","flags","arguments","undefined","nonBlockingEvents","Boolean","_document","title","_URL","url","hashChanged","fragment","oldURL","newURL","replacement","indexOf","updateCurrentEntry","state","stateObject","_history","_state","stateChanged","_latestEntry","fireEvents","_fireEvents","serializeURL","addEntryAfterCurrentEntry","entry","module","exports"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/jsdom/living/window/SessionHistory.js"],"sourcesContent":["\"use strict\";\r\nconst whatwgURL = require(\"whatwg-url\");\r\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\r\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\r\nconst notImplemented = require(\"../../browser/not-implemented.js\");\r\nconst idlUtils = require(\"../generated/utils.js\");\r\nconst { fireAnEvent } = require(\"../helpers/events\");\r\n\r\n// https://html.spec.whatwg.org/#session-history\r\nclass SessionHistory {\r\n  constructor(initialEntry, window) {\r\n    this._window = window;\r\n    this._windowImpl = idlUtils.implForWrapper(window);\r\n    this._historyTraversalQueue = new Set();\r\n    this._entries = [initialEntry];\r\n    this._currentIndex = 0;\r\n  }\r\n\r\n  _queueHistoryTraversalTask(fn) {\r\n    const timeoutId = this._window.setTimeout(() => {\r\n      this._historyTraversalQueue.delete(timeoutId);\r\n      fn();\r\n    }, 0);\r\n\r\n    this._historyTraversalQueue.add(timeoutId);\r\n  }\r\n\r\n  clearHistoryTraversalTasks() {\r\n    for (const timeoutId of this._historyTraversalQueue) {\r\n      this._window.clearTimeout(timeoutId);\r\n    }\r\n    this._historyTraversalQueue.clear();\r\n  }\r\n\r\n  get length() {\r\n    return this._entries.length;\r\n  }\r\n\r\n  get currentEntry() {\r\n    return this._entries[this._currentIndex];\r\n  }\r\n\r\n  // https://html.spec.whatwg.org/#dom-history-pushstate\r\n  removeAllEntriesAfterCurrentEntry() {\r\n    this._entries.splice(this._currentIndex + 1, Infinity);\r\n  }\r\n\r\n  // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\r\n  traverseByDelta(delta) {\r\n    this._queueHistoryTraversalTask(() => {\r\n      const newIndex = this._currentIndex + delta;\r\n      if (newIndex < 0 || newIndex >= this.length) {\r\n        return;\r\n      }\r\n\r\n      const specifiedEntry = this._entries[newIndex];\r\n\r\n      // Not implemented: unload a document guard\r\n\r\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\r\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\r\n      this._queueHistoryTraversalTask(() => {\r\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\r\n        // then cancel that attempt to navigate the browsing context.\r\n\r\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\r\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\r\n\r\n        // this.clearHistoryTraversalTasks();\r\n\r\n        if (specifiedEntry.document !== this.currentEntry.document) {\r\n          // TODO: unload the active document with the recycle parameter set to false\r\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\r\n        }\r\n        this.traverseHistory(specifiedEntry);\r\n      });\r\n    });\r\n  }\r\n\r\n  // https://html.spec.whatwg.org/#traverse-the-history\r\n  traverseHistory(specifiedEntry, flags = {}) {\r\n    if (!specifiedEntry.document) {\r\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\r\n      // to perform an entry update of entry, and abort these steps\r\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\r\n    }\r\n    // Not spec compliant, just minimal. Lots of missing steps.\r\n\r\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\r\n\r\n    const document = idlUtils.implForWrapper(this._window._document);\r\n\r\n    const { currentEntry } = this;\r\n\r\n    // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\r\n    // to the value returned by the document.title IDL attribute.\r\n    if (currentEntry.title === undefined) {\r\n      currentEntry.title = document.title;\r\n    }\r\n\r\n\r\n    if (specifiedEntry.document !== currentEntry.document) {\r\n      // If entry has a different Document object than the current entry, then...\r\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\r\n    }\r\n\r\n    document._URL = specifiedEntry.url;\r\n\r\n    const hashChanged =\r\n      specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\r\n    let oldURL, newURL;\r\n    if (hashChanged) {\r\n      oldURL = currentEntry.url;\r\n      newURL = specifiedEntry.url;\r\n    }\r\n\r\n    if (flags.replacement) {\r\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\r\n      // specified entry in the session history.\r\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\r\n    }\r\n\r\n    this.updateCurrentEntry(specifiedEntry);\r\n\r\n    const state = specifiedEntry.stateObject; // TODO structured clone\r\n\r\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\r\n    // but the spec gives them to \"History\" and \"Document\" respecively.\r\n    document._history._state = state;\r\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\r\n    specifiedEntry.document._latestEntry = specifiedEntry;\r\n\r\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\r\n\r\n    if (nonBlockingEvents) {\r\n      this._window.setTimeout(fireEvents, 0);\r\n    } else {\r\n      fireEvents();\r\n    }\r\n  }\r\n\r\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\r\n    if (stateChanged) {\r\n      fireAnEvent(\"popstate\", this._windowImpl, PopStateEvent, { state });\r\n    }\r\n\r\n    if (hashChanged) {\r\n      fireAnEvent(\"hashchange\", this._windowImpl, HashChangeEvent, {\r\n        oldURL: whatwgURL.serializeURL(oldURL),\r\n        newURL: whatwgURL.serializeURL(newURL)\r\n      });\r\n    }\r\n  }\r\n\r\n  addEntryAfterCurrentEntry(entry) {\r\n    this._entries.splice(this._currentIndex + 1, 0, entry);\r\n  }\r\n\r\n  updateCurrentEntry(entry) {\r\n    this._currentIndex = this._entries.indexOf(entry);\r\n  }\r\n}\r\nmodule.exports = SessionHistory;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}