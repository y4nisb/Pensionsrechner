{"ast":null,"code":"\"use strict\";\n\n// https://infra.spec.whatwg.org/#ascii-whitespace\nconst asciiWhitespaceRe = /^[\\t\\n\\f\\r ]$/;\nexports.asciiWhitespaceRe = asciiWhitespaceRe;\n\n// https://infra.spec.whatwg.org/#ascii-lowercase\nexports.asciiLowercase = s => {\n  return s.replace(/[A-Z]/g, l => l.toLowerCase());\n};\n\n// https://infra.spec.whatwg.org/#ascii-uppercase\nexports.asciiUppercase = s => {\n  return s.replace(/[a-z]/g, l => l.toUpperCase());\n};\n\n// https://infra.spec.whatwg.org/#strip-newlines\nexports.stripNewlines = s => {\n  return s.replace(/[\\n\\r]+/g, \"\");\n};\n\n// https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\nexports.stripLeadingAndTrailingASCIIWhitespace = s => {\n  return s.replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\n};\n\n// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\nexports.stripAndCollapseASCIIWhitespace = s => {\n  return s.replace(/[ \\t\\n\\f\\r]+/g, \" \").replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\n};\n\n// https://html.spec.whatwg.org/multipage/infrastructure.html#valid-simple-colour\nexports.isValidSimpleColor = s => {\n  return /^#[a-fA-F\\d]{6}$/.test(s);\n};\n\n// https://infra.spec.whatwg.org/#ascii-case-insensitive\nexports.asciiCaseInsensitiveMatch = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-integers\n// Error is represented as null.\nconst parseInteger = exports.parseInteger = input => {\n  // The implementation here is slightly different from the spec's. We want to use parseInt(), but parseInt() trims\n  // Unicode whitespace in addition to just ASCII ones, so we make sure that the trimmed prefix contains only ASCII\n  // whitespace ourselves.\n  const numWhitespace = input.length - input.trimStart().length;\n  if (/[^\\t\\n\\f\\r ]/.test(input.slice(0, numWhitespace))) {\n    return null;\n  }\n  // We don't allow hexadecimal numbers here.\n  // eslint-disable-next-line radix\n  const value = parseInt(input, 10);\n  if (Number.isNaN(value)) {\n    return null;\n  }\n  // parseInt() returns -0 for \"-0\". Normalize that here.\n  return value === 0 ? 0 : value;\n};\n\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-non-negative-integers\n// Error is represented as null.\nexports.parseNonNegativeInteger = input => {\n  const value = parseInteger(input);\n  if (value === null) {\n    return null;\n  }\n  if (value < 0) {\n    return null;\n  }\n  return value;\n};\n\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#valid-floating-point-number\nconst floatingPointNumRe = /^-?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?$/;\nexports.isValidFloatingPointNumber = str => floatingPointNumRe.test(str);\n\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-floating-point-number-values\n// Error is represented as null.\nexports.parseFloatingPointNumber = str => {\n  // The implementation here is slightly different from the spec's. We need to use parseFloat() in order to retain\n  // accuracy, but parseFloat() trims Unicode whitespace in addition to just ASCII ones, so we make sure that the\n  // trimmed prefix contains only ASCII whitespace ourselves.\n  const numWhitespace = str.length - str.trimStart().length;\n  if (/[^\\t\\n\\f\\r ]/.test(str.slice(0, numWhitespace))) {\n    return null;\n  }\n  const parsed = parseFloat(str);\n  return isFinite(parsed) ? parsed : null;\n};\n\n// https://infra.spec.whatwg.org/#split-on-ascii-whitespace\nexports.splitOnASCIIWhitespace = str => {\n  let position = 0;\n  const tokens = [];\n  while (position < str.length && asciiWhitespaceRe.test(str[position])) {\n    position++;\n  }\n  if (position === str.length) {\n    return tokens;\n  }\n  while (position < str.length) {\n    const start = position;\n    while (position < str.length && !asciiWhitespaceRe.test(str[position])) {\n      position++;\n    }\n    tokens.push(str.slice(start, position));\n    while (position < str.length && asciiWhitespaceRe.test(str[position])) {\n      position++;\n    }\n  }\n  return tokens;\n};\n\n// https://infra.spec.whatwg.org/#split-on-commas\nexports.splitOnCommas = str => {\n  let position = 0;\n  const tokens = [];\n  while (position < str.length) {\n    let start = position;\n    while (position < str.length && str[position] !== \",\") {\n      position++;\n    }\n    let end = position;\n    while (start < str.length && asciiWhitespaceRe.test(str[start])) {\n      start++;\n    }\n    while (end > start && asciiWhitespaceRe.test(str[end - 1])) {\n      end--;\n    }\n    tokens.push(str.slice(start, end));\n    if (position < str.length) {\n      position++;\n    }\n  }\n  return tokens;\n};","map":{"version":3,"names":["asciiWhitespaceRe","exports","asciiLowercase","s","replace","l","toLowerCase","asciiUppercase","toUpperCase","stripNewlines","stripLeadingAndTrailingASCIIWhitespace","stripAndCollapseASCIIWhitespace","isValidSimpleColor","test","asciiCaseInsensitiveMatch","a","b","length","i","charCodeAt","parseInteger","input","numWhitespace","trimStart","slice","value","parseInt","Number","isNaN","parseNonNegativeInteger","floatingPointNumRe","isValidFloatingPointNumber","str","parseFloatingPointNumber","parsed","parseFloat","isFinite","splitOnASCIIWhitespace","position","tokens","start","push","splitOnCommas","end"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/jsdom/living/helpers/strings.js"],"sourcesContent":["\"use strict\";\r\n\r\n// https://infra.spec.whatwg.org/#ascii-whitespace\r\nconst asciiWhitespaceRe = /^[\\t\\n\\f\\r ]$/;\r\nexports.asciiWhitespaceRe = asciiWhitespaceRe;\r\n\r\n// https://infra.spec.whatwg.org/#ascii-lowercase\r\nexports.asciiLowercase = s => {\r\n  return s.replace(/[A-Z]/g, l => l.toLowerCase());\r\n};\r\n\r\n// https://infra.spec.whatwg.org/#ascii-uppercase\r\nexports.asciiUppercase = s => {\r\n  return s.replace(/[a-z]/g, l => l.toUpperCase());\r\n};\r\n\r\n// https://infra.spec.whatwg.org/#strip-newlines\r\nexports.stripNewlines = s => {\r\n  return s.replace(/[\\n\\r]+/g, \"\");\r\n};\r\n\r\n// https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\r\nexports.stripLeadingAndTrailingASCIIWhitespace = s => {\r\n  return s.replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\r\n};\r\n\r\n// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\r\nexports.stripAndCollapseASCIIWhitespace = s => {\r\n  return s.replace(/[ \\t\\n\\f\\r]+/g, \" \").replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\r\n};\r\n\r\n// https://html.spec.whatwg.org/multipage/infrastructure.html#valid-simple-colour\r\nexports.isValidSimpleColor = s => {\r\n  return /^#[a-fA-F\\d]{6}$/.test(s);\r\n};\r\n\r\n// https://infra.spec.whatwg.org/#ascii-case-insensitive\r\nexports.asciiCaseInsensitiveMatch = (a, b) => {\r\n  if (a.length !== b.length) {\r\n    return false;\r\n  }\r\n\r\n  for (let i = 0; i < a.length; ++i) {\r\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-integers\r\n// Error is represented as null.\r\nconst parseInteger = exports.parseInteger = input => {\r\n  // The implementation here is slightly different from the spec's. We want to use parseInt(), but parseInt() trims\r\n  // Unicode whitespace in addition to just ASCII ones, so we make sure that the trimmed prefix contains only ASCII\r\n  // whitespace ourselves.\r\n  const numWhitespace = input.length - input.trimStart().length;\r\n  if (/[^\\t\\n\\f\\r ]/.test(input.slice(0, numWhitespace))) {\r\n    return null;\r\n  }\r\n  // We don't allow hexadecimal numbers here.\r\n  // eslint-disable-next-line radix\r\n  const value = parseInt(input, 10);\r\n  if (Number.isNaN(value)) {\r\n    return null;\r\n  }\r\n  // parseInt() returns -0 for \"-0\". Normalize that here.\r\n  return value === 0 ? 0 : value;\r\n};\r\n\r\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-non-negative-integers\r\n// Error is represented as null.\r\nexports.parseNonNegativeInteger = input => {\r\n  const value = parseInteger(input);\r\n  if (value === null) {\r\n    return null;\r\n  }\r\n  if (value < 0) {\r\n    return null;\r\n  }\r\n  return value;\r\n};\r\n\r\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#valid-floating-point-number\r\nconst floatingPointNumRe = /^-?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?$/;\r\nexports.isValidFloatingPointNumber = str => floatingPointNumRe.test(str);\r\n\r\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-floating-point-number-values\r\n// Error is represented as null.\r\nexports.parseFloatingPointNumber = str => {\r\n  // The implementation here is slightly different from the spec's. We need to use parseFloat() in order to retain\r\n  // accuracy, but parseFloat() trims Unicode whitespace in addition to just ASCII ones, so we make sure that the\r\n  // trimmed prefix contains only ASCII whitespace ourselves.\r\n  const numWhitespace = str.length - str.trimStart().length;\r\n  if (/[^\\t\\n\\f\\r ]/.test(str.slice(0, numWhitespace))) {\r\n    return null;\r\n  }\r\n  const parsed = parseFloat(str);\r\n  return isFinite(parsed) ? parsed : null;\r\n};\r\n\r\n// https://infra.spec.whatwg.org/#split-on-ascii-whitespace\r\nexports.splitOnASCIIWhitespace = str => {\r\n  let position = 0;\r\n  const tokens = [];\r\n  while (position < str.length && asciiWhitespaceRe.test(str[position])) {\r\n    position++;\r\n  }\r\n  if (position === str.length) {\r\n    return tokens;\r\n  }\r\n  while (position < str.length) {\r\n    const start = position;\r\n    while (position < str.length && !asciiWhitespaceRe.test(str[position])) {\r\n      position++;\r\n    }\r\n    tokens.push(str.slice(start, position));\r\n    while (position < str.length && asciiWhitespaceRe.test(str[position])) {\r\n      position++;\r\n    }\r\n  }\r\n  return tokens;\r\n};\r\n\r\n// https://infra.spec.whatwg.org/#split-on-commas\r\nexports.splitOnCommas = str => {\r\n  let position = 0;\r\n  const tokens = [];\r\n  while (position < str.length) {\r\n    let start = position;\r\n    while (position < str.length && str[position] !== \",\") {\r\n      position++;\r\n    }\r\n    let end = position;\r\n    while (start < str.length && asciiWhitespaceRe.test(str[start])) {\r\n      start++;\r\n    }\r\n    while (end > start && asciiWhitespaceRe.test(str[end - 1])) {\r\n      end--;\r\n    }\r\n    tokens.push(str.slice(start, end));\r\n    if (position < str.length) {\r\n      position++;\r\n    }\r\n  }\r\n  return tokens;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}