{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst {\n  clone\n} = require(\"../node\");\nconst NODE_TYPE = require(\"../node-type\");\nconst {\n  parseFragment\n} = require(\"../../browser/parser/index\");\nconst {\n  HTML_NS\n} = require(\"../helpers/namespaces\");\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\nconst {\n  compareBoundaryPointsPosition\n} = require(\"./boundary-point\");\nconst {\n  nodeRoot,\n  nodeLength,\n  isInclusiveAncestor\n} = require(\"../helpers/node\");\nconst {\n  createElement\n} = require(\"../helpers/create-element\");\nconst AbstractRangeImpl = require(\"./AbstractRange-impl\").implementation;\nconst Range = require(\"../generated/Range\");\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\nconst {\n  implForWrapper\n} = require(\"../generated/utils\");\nconst RANGE_COMPARISON_TYPE = {\n  START_TO_START: 0,\n  START_TO_END: 1,\n  END_TO_END: 2,\n  END_TO_START: 3\n};\nclass RangeImpl extends AbstractRangeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n    const defaultBoundaryPoint = {\n      node: implForWrapper(globalObject._document),\n      offset: 0\n    };\n    const {\n      start = defaultBoundaryPoint,\n      end = defaultBoundaryPoint\n    } = privateData;\n    this._setLiveRangeStart(start.node, start.offset);\n    this._setLiveRangeEnd(end.node, end.offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer\n  get commonAncestorContainer() {\n    const {\n      _start,\n      _end\n    } = this;\n    for (const container of domSymbolTree.ancestorsIterator(_start.node)) {\n      if (isInclusiveAncestor(container, _end.node)) {\n        return container;\n      }\n    }\n    return null;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstart\n  setStart(node, offset) {\n    setBoundaryPointStart(this, node, offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setend\n  setEnd(node, offset) {\n    setBoundaryPointEnd(this, node, offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstartbefore\n  setStartBefore(node) {\n    const parent = domSymbolTree.parent(node);\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node));\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstartafter\n  setStartAfter(node) {\n    const parent = domSymbolTree.parent(node);\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setendbefore\n  setEndBefore(node) {\n    const parent = domSymbolTree.parent(node);\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node));\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setendafter\n  setEndAfter(node) {\n    const parent = domSymbolTree.parent(node);\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-collapse\n  collapse(toStart) {\n    if (toStart) {\n      this._setLiveRangeEnd(this._start.node, this._start.offset);\n    } else {\n      this._setLiveRangeStart(this._end.node, this._end.offset);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-selectnode\n  selectNode(node) {\n    selectNodeWithinRange(node, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-selectnodecontents\n  selectNodeContents(node) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      throw DOMException.create(this._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n    }\n    const length = nodeLength(node);\n    this._setLiveRangeStart(node, 0);\n    this._setLiveRangeEnd(node, length);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints\n  compareBoundaryPoints(how, sourceRange) {\n    if (how !== RANGE_COMPARISON_TYPE.START_TO_START && how !== RANGE_COMPARISON_TYPE.START_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_START) {\n      const message = \"The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', \" + \"or 'END_TO_START'.\";\n      throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\n    }\n    if (this._root !== sourceRange._root) {\n      throw DOMException.create(this._globalObject, [\"The two Ranges are not in the same tree.\", \"WrongDocumentError\"]);\n    }\n    let thisPoint, otherPoint;\n    if (how === RANGE_COMPARISON_TYPE.START_TO_START) {\n      thisPoint = this._start;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._end;\n    } else {\n      thisPoint = this._start;\n      otherPoint = sourceRange._end;\n    }\n    return compareBoundaryPointsPosition(thisPoint, otherPoint);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-deletecontents\n  deleteContents() {\n    if (this.collapsed) {\n      return;\n    }\n    const {\n      _start: originalStart,\n      _end: originalEnd\n    } = this;\n    if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n      originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n      return;\n    }\n    const nodesToRemove = [];\n    let currentNode = this._start.node;\n    const endNode = nextNodeDescendant(this._end.node);\n    while (currentNode && currentNode !== endNode) {\n      if (isContained(currentNode, this) && !isContained(domSymbolTree.parent(currentNode), this)) {\n        nodesToRemove.push(currentNode);\n      }\n      currentNode = domSymbolTree.following(currentNode);\n    }\n    let newNode, newOffset;\n    if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n      newNode = originalStart.node;\n      newOffset = originalStart.offset;\n    } else {\n      let referenceNode = originalStart.node;\n      while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n        referenceNode = domSymbolTree.parent(referenceNode);\n      }\n      newNode = domSymbolTree.parent(referenceNode);\n      newOffset = domSymbolTree.index(referenceNode) + 1;\n    }\n    if (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n      originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n    }\n    for (const node of nodesToRemove) {\n      const parent = domSymbolTree.parent(node);\n      parent.removeChild(node);\n    }\n    if (originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE || originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n      originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n    }\n    this._setLiveRangeStart(newNode, newOffset);\n    this._setLiveRangeEnd(newNode, newOffset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-extractcontents\n  extractContents() {\n    return extractRange(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-clonecontents\n  cloneContents() {\n    return cloneRange(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-insertnode\n  insertNode(node) {\n    insertNodeInRange(node, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-surroundcontents\n  surroundContents(newParent) {\n    let node = this.commonAncestorContainer;\n    const endNode = nextNodeDescendant(node);\n    while (node !== endNode) {\n      if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {\n        throw DOMException.create(this._globalObject, [\"The Range has partially contains a non-Text node.\", \"InvalidStateError\"]);\n      }\n      node = domSymbolTree.following(node);\n    }\n    if (newParent.nodeType === NODE_TYPE.DOCUMENT_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      throw DOMException.create(this._globalObject, [\"Invalid element type.\", \"InvalidNodeTypeError\"]);\n    }\n    const fragment = extractRange(this);\n    while (domSymbolTree.firstChild(newParent)) {\n      newParent.removeChild(domSymbolTree.firstChild(newParent));\n    }\n    insertNodeInRange(newParent, this);\n    newParent.appendChild(fragment);\n    selectNodeWithinRange(newParent, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-clonerange\n  cloneRange() {\n    const {\n      _start,\n      _end,\n      _globalObject\n    } = this;\n    return Range.createImpl(_globalObject, [], {\n      start: {\n        node: _start.node,\n        offset: _start.offset\n      },\n      end: {\n        node: _end.node,\n        offset: _end.offset\n      }\n    });\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-detach\n  detach() {\n    // Do nothing by spec!\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-ispointinrange\n  isPointInRange(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n    validateSetBoundaryPoint(node, offset);\n    const bp = {\n      node,\n      offset\n    };\n    if (compareBoundaryPointsPosition(bp, this._start) === -1 || compareBoundaryPointsPosition(bp, this._end) === 1) {\n      return false;\n    }\n    return true;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-comparepoint\n  comparePoint(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      throw DOMException.create(this._globalObject, [\"The given Node and the Range are not in the same tree.\", \"WrongDocumentError\"]);\n    }\n    validateSetBoundaryPoint(node, offset);\n    const bp = {\n      node,\n      offset\n    };\n    if (compareBoundaryPointsPosition(bp, this._start) === -1) {\n      return -1;\n    } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {\n      return 1;\n    }\n    return 0;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-intersectsnode\n  intersectsNode(node) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n    const parent = domSymbolTree.parent(node);\n    if (!parent) {\n      return true;\n    }\n    const offset = domSymbolTree.index(node);\n    return compareBoundaryPointsPosition({\n      node: parent,\n      offset\n    }, this._end) === -1 && compareBoundaryPointsPosition({\n      node: parent,\n      offset: offset + 1\n    }, this._start) === 1;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-stringifier\n  toString() {\n    let s = \"\";\n    const {\n      _start,\n      _end\n    } = this;\n    if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      return _start.node.data.slice(_start.offset, _end.offset);\n    }\n    if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _start.node.data.slice(_start.offset);\n    }\n    let currentNode = _start.node;\n    const endNode = nextNodeDescendant(_end.node);\n    while (currentNode && currentNode !== endNode) {\n      if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {\n        s += currentNode.data;\n      }\n      currentNode = domSymbolTree.following(currentNode);\n    }\n    if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _end.node.data.slice(0, _end.offset);\n    }\n    return s;\n  }\n\n  // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment\n  createContextualFragment(fragment) {\n    const {\n      node\n    } = this._start;\n    let element;\n    switch (node.nodeType) {\n      case NODE_TYPE.DOCUMENT_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        element = null;\n        break;\n      case NODE_TYPE.ELEMENT_NODE:\n        element = node;\n        break;\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        element = node.parentElement;\n        break;\n      default:\n        throw new Error(\"Internal error: Invalid range start node\");\n    }\n    if (element === null || element._ownerDocument._parsingMode === \"html\" && element._localName === \"html\" && element._namespaceURI === HTML_NS) {\n      element = createElement(node._ownerDocument, \"body\", HTML_NS);\n    }\n    return parseFragment(fragment, element);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-range-root\n  get _root() {\n    return nodeRoot(this._start.node);\n  }\n  _setLiveRangeStart(node, offset) {\n    if (this._start && this._start.node !== node) {\n      this._start.node._referencedRanges.delete(this);\n    }\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n    this._start = {\n      node,\n      offset\n    };\n  }\n  _setLiveRangeEnd(node, offset) {\n    if (this._end && this._end.node !== node) {\n      this._end.node._referencedRanges.delete(this);\n    }\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n    this._end = {\n      node,\n      offset\n    };\n  }\n}\nfunction nextNodeDescendant(node) {\n  while (node && !domSymbolTree.nextSibling(node)) {\n    node = domSymbolTree.parent(node);\n  }\n  if (!node) {\n    return null;\n  }\n  return domSymbolTree.nextSibling(node);\n}\n\n// https://dom.spec.whatwg.org/#concept-range-bp-set\nfunction validateSetBoundaryPoint(node, offset) {\n  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n    throw DOMException.create(node._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n  }\n  if (offset > nodeLength(node)) {\n    throw DOMException.create(node._globalObject, [\"Offset out of bound.\", \"IndexSizeError\"]);\n  }\n}\nfunction setBoundaryPointStart(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  const bp = {\n    node,\n    offset\n  };\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._end) === 1) {\n    range._setLiveRangeEnd(node, offset);\n  }\n  range._setLiveRangeStart(node, offset);\n}\nfunction setBoundaryPointEnd(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  const bp = {\n    node,\n    offset\n  };\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._start) === -1) {\n    range._setLiveRangeStart(node, offset);\n  }\n  range._setLiveRangeEnd(node, offset);\n}\n\n// https://dom.spec.whatwg.org/#concept-range-select\nfunction selectNodeWithinRange(node, range) {\n  const parent = domSymbolTree.parent(node);\n  if (!parent) {\n    throw DOMException.create(node._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n  }\n  const index = domSymbolTree.index(node);\n  range._setLiveRangeStart(parent, index);\n  range._setLiveRangeEnd(parent, index + 1);\n}\n\n// https://dom.spec.whatwg.org/#contained\nfunction isContained(node, range) {\n  const {\n    _start,\n    _end\n  } = range;\n  return compareBoundaryPointsPosition({\n    node,\n    offset: 0\n  }, _start) === 1 && compareBoundaryPointsPosition({\n    node,\n    offset: nodeLength(node)\n  }, _end) === -1;\n}\n\n// https://dom.spec.whatwg.org/#partially-contained\nfunction isPartiallyContained(node, range) {\n  const {\n    _start,\n    _end\n  } = range;\n  return isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node) || !isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node);\n}\n\n// https://dom.spec.whatwg.org/#concept-range-insert\nfunction insertNodeInRange(node, range) {\n  const {\n    node: startNode,\n    offset: startOffset\n  } = range._start;\n  if (startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || startNode.nodeType === NODE_TYPE.COMMENT_NODE || startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode) || node === startNode) {\n    throw DOMException.create(node._globalObject, [\"Invalid start node.\", \"HierarchyRequestError\"]);\n  }\n  let referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ? startNode : domSymbolTree.childrenToArray(startNode)[startOffset] || null;\n  const parent = !referenceNode ? startNode : domSymbolTree.parent(referenceNode);\n  parent._preInsertValidity(node, referenceNode);\n  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {\n    referenceNode = startNode.splitText(startOffset);\n  }\n  if (node === referenceNode) {\n    referenceNode = domSymbolTree.nextSibling(referenceNode);\n  }\n  const nodeParent = domSymbolTree.parent(node);\n  if (nodeParent) {\n    nodeParent.removeChild(node);\n  }\n  let newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);\n  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;\n  parent.insertBefore(node, referenceNode);\n  if (range.collapsed) {\n    range._setLiveRangeEnd(parent, newOffset);\n  }\n}\n\n// https://dom.spec.whatwg.org/#concept-range-clone\nfunction cloneRange(range) {\n  const {\n    _start: originalStart,\n    _end: originalEnd,\n    _globalObject\n  } = range;\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n  if (range.collapsed) {\n    return fragment;\n  }\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    return fragment;\n  }\n  let commonAncestor = originalStart.node;\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n  let firstPartialContainedChild = null;\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n  let lastPartiallyContainedChild = null;\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(node => isContained(node, range));\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(cloned);\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n  for (const containedChild of containedChildren) {\n    const cloned = clone(containedChild, undefined, true);\n    fragment.appendChild(cloned);\n  }\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n    fragment.appendChild(cloned);\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n  return fragment;\n}\n\n// https://dom.spec.whatwg.org/#concept-range-extract\nfunction extractRange(range) {\n  const {\n    _start: originalStart,\n    _end: originalEnd,\n    _globalObject\n  } = range;\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n  if (range.collapsed) {\n    return fragment;\n  }\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n    return fragment;\n  }\n  let commonAncestor = originalStart.node;\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n  let firstPartialContainedChild = null;\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n  let lastPartiallyContainedChild = null;\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(node => isContained(node, range));\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n  let newNode, newOffset;\n  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    newNode = originalStart.node;\n    newOffset = originalStart.offset;\n  } else {\n    let referenceNode = originalStart.node;\n    while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n      referenceNode = domSymbolTree.parent(referenceNode);\n    }\n    newNode = domSymbolTree.parent(referenceNode);\n    newOffset = domSymbolTree.index(referenceNode) + 1;\n  }\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n  for (const containedChild of containedChildren) {\n    fragment.appendChild(containedChild);\n  }\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n    fragment.appendChild(cloned);\n    originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n  range._setLiveRangeStart(newNode, newOffset);\n  range._setLiveRangeEnd(newNode, newOffset);\n  return fragment;\n}\nmodule.exports = {\n  implementation: RangeImpl,\n  setBoundaryPointStart,\n  setBoundaryPointEnd\n};","map":{"version":3,"names":["DOMException","require","clone","NODE_TYPE","parseFragment","HTML_NS","domSymbolTree","compareBoundaryPointsPosition","nodeRoot","nodeLength","isInclusiveAncestor","createElement","AbstractRangeImpl","implementation","Range","DocumentFragment","implForWrapper","RANGE_COMPARISON_TYPE","START_TO_START","START_TO_END","END_TO_END","END_TO_START","RangeImpl","constructor","globalObject","args","privateData","defaultBoundaryPoint","node","_document","offset","start","end","_setLiveRangeStart","_setLiveRangeEnd","commonAncestorContainer","_start","_end","container","ancestorsIterator","setStart","setBoundaryPointStart","setEnd","setBoundaryPointEnd","setStartBefore","parent","create","_globalObject","index","setStartAfter","setEndBefore","setEndAfter","collapse","toStart","selectNode","selectNodeWithinRange","selectNodeContents","nodeType","DOCUMENT_TYPE_NODE","length","compareBoundaryPoints","how","sourceRange","message","_root","thisPoint","otherPoint","deleteContents","collapsed","originalStart","originalEnd","TEXT_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","replaceData","nodesToRemove","currentNode","endNode","nextNodeDescendant","isContained","push","following","newNode","newOffset","referenceNode","removeChild","extractContents","extractRange","cloneContents","cloneRange","insertNode","insertNodeInRange","surroundContents","newParent","isPartiallyContained","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","fragment","firstChild","appendChild","createImpl","detach","isPointInRange","validateSetBoundaryPoint","bp","comparePoint","intersectsNode","toString","s","data","slice","createContextualFragment","element","ELEMENT_NODE","parentElement","Error","_ownerDocument","_parsingMode","_localName","_namespaceURI","_referencedRanges","delete","has","add","nextSibling","range","startNode","startOffset","childrenToArray","_preInsertValidity","splitText","nodeParent","insertBefore","ownerDocument","cloned","_data","substringData","commonAncestor","firstPartialContainedChild","candidate","lastPartiallyContainedChild","lastChild","previousSibling","containedChildren","filter","hasDoctypeChildren","some","subrange","subfragment","containedChild","undefined","module","exports"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/jsdom/living/range/Range-impl.js"],"sourcesContent":["\"use strict\";\r\n\r\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\r\n\r\nconst { clone } = require(\"../node\");\r\nconst NODE_TYPE = require(\"../node-type\");\r\nconst { parseFragment } = require(\"../../browser/parser/index\");\r\n\r\nconst { HTML_NS } = require(\"../helpers/namespaces\");\r\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\r\nconst { compareBoundaryPointsPosition } = require(\"./boundary-point\");\r\nconst { nodeRoot, nodeLength, isInclusiveAncestor } = require(\"../helpers/node\");\r\nconst { createElement } = require(\"../helpers/create-element\");\r\n\r\nconst AbstractRangeImpl = require(\"./AbstractRange-impl\").implementation;\r\n\r\nconst Range = require(\"../generated/Range\");\r\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\r\nconst { implForWrapper } = require(\"../generated/utils\");\r\n\r\nconst RANGE_COMPARISON_TYPE = {\r\n  START_TO_START: 0,\r\n  START_TO_END: 1,\r\n  END_TO_END: 2,\r\n  END_TO_START: 3\r\n};\r\n\r\nclass RangeImpl extends AbstractRangeImpl {\r\n  constructor(globalObject, args, privateData) {\r\n    super(globalObject, args, privateData);\r\n\r\n    const defaultBoundaryPoint = {\r\n      node: implForWrapper(globalObject._document),\r\n      offset: 0\r\n    };\r\n\r\n    const {\r\n      start = defaultBoundaryPoint,\r\n      end = defaultBoundaryPoint\r\n    } = privateData;\r\n\r\n    this._setLiveRangeStart(start.node, start.offset);\r\n    this._setLiveRangeEnd(end.node, end.offset);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer\r\n  get commonAncestorContainer() {\r\n    const { _start, _end } = this;\r\n\r\n    for (const container of domSymbolTree.ancestorsIterator(_start.node)) {\r\n      if (isInclusiveAncestor(container, _end.node)) {\r\n        return container;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setstart\r\n  setStart(node, offset) {\r\n    setBoundaryPointStart(this, node, offset);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setend\r\n  setEnd(node, offset) {\r\n    setBoundaryPointEnd(this, node, offset);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setstartbefore\r\n  setStartBefore(node) {\r\n    const parent = domSymbolTree.parent(node);\r\n\r\n    if (!parent) {\r\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\r\n    }\r\n\r\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node));\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setstartafter\r\n  setStartAfter(node) {\r\n    const parent = domSymbolTree.parent(node);\r\n\r\n    if (!parent) {\r\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\r\n    }\r\n\r\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setendbefore\r\n  setEndBefore(node) {\r\n    const parent = domSymbolTree.parent(node);\r\n\r\n    if (!parent) {\r\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\r\n    }\r\n\r\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node));\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-setendafter\r\n  setEndAfter(node) {\r\n    const parent = domSymbolTree.parent(node);\r\n\r\n    if (!parent) {\r\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\r\n    }\r\n\r\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-collapse\r\n  collapse(toStart) {\r\n    if (toStart) {\r\n      this._setLiveRangeEnd(this._start.node, this._start.offset);\r\n    } else {\r\n      this._setLiveRangeStart(this._end.node, this._end.offset);\r\n    }\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-selectnode\r\n  selectNode(node) {\r\n    selectNodeWithinRange(node, this);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-selectnodecontents\r\n  selectNodeContents(node) {\r\n    if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\r\n      throw DOMException.create(this._globalObject, [\r\n        \"DocumentType Node can't be used as boundary point.\",\r\n        \"InvalidNodeTypeError\"\r\n      ]);\r\n    }\r\n\r\n    const length = nodeLength(node);\r\n\r\n    this._setLiveRangeStart(node, 0);\r\n    this._setLiveRangeEnd(node, length);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints\r\n  compareBoundaryPoints(how, sourceRange) {\r\n    if (\r\n      how !== RANGE_COMPARISON_TYPE.START_TO_START &&\r\n      how !== RANGE_COMPARISON_TYPE.START_TO_END &&\r\n      how !== RANGE_COMPARISON_TYPE.END_TO_END &&\r\n      how !== RANGE_COMPARISON_TYPE.END_TO_START\r\n    ) {\r\n      const message = \"The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', \" +\r\n                      \"or 'END_TO_START'.\";\r\n      throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\r\n    }\r\n\r\n    if (this._root !== sourceRange._root) {\r\n      throw DOMException.create(this._globalObject, [\"The two Ranges are not in the same tree.\", \"WrongDocumentError\"]);\r\n    }\r\n\r\n    let thisPoint, otherPoint;\r\n    if (how === RANGE_COMPARISON_TYPE.START_TO_START) {\r\n      thisPoint = this._start;\r\n      otherPoint = sourceRange._start;\r\n    } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {\r\n      thisPoint = this._end;\r\n      otherPoint = sourceRange._start;\r\n    } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {\r\n      thisPoint = this._end;\r\n      otherPoint = sourceRange._end;\r\n    } else {\r\n      thisPoint = this._start;\r\n      otherPoint = sourceRange._end;\r\n    }\r\n\r\n    return compareBoundaryPointsPosition(thisPoint, otherPoint);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-deletecontents\r\n  deleteContents() {\r\n    if (this.collapsed) {\r\n      return;\r\n    }\r\n\r\n    const { _start: originalStart, _end: originalEnd } = this;\r\n\r\n    if (\r\n      originalStart.node === originalEnd.node &&\r\n      (\r\n        originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\r\n        originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n        originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\r\n      )\r\n    ) {\r\n      originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\r\n      return;\r\n    }\r\n\r\n    const nodesToRemove = [];\r\n    let currentNode = this._start.node;\r\n    const endNode = nextNodeDescendant(this._end.node);\r\n    while (currentNode && currentNode !== endNode) {\r\n      if (\r\n        isContained(currentNode, this) &&\r\n        !isContained(domSymbolTree.parent(currentNode), this)\r\n      ) {\r\n        nodesToRemove.push(currentNode);\r\n      }\r\n\r\n      currentNode = domSymbolTree.following(currentNode);\r\n    }\r\n\r\n    let newNode, newOffset;\r\n    if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\r\n      newNode = originalStart.node;\r\n      newOffset = originalStart.offset;\r\n    } else {\r\n      let referenceNode = originalStart.node;\r\n\r\n      while (\r\n        referenceNode &&\r\n        !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)\r\n      ) {\r\n        referenceNode = domSymbolTree.parent(referenceNode);\r\n      }\r\n\r\n      newNode = domSymbolTree.parent(referenceNode);\r\n      newOffset = domSymbolTree.index(referenceNode) + 1;\r\n    }\r\n\r\n    if (\r\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\r\n    ) {\r\n      originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\r\n    }\r\n\r\n    for (const node of nodesToRemove) {\r\n      const parent = domSymbolTree.parent(node);\r\n      parent.removeChild(node);\r\n    }\r\n\r\n    if (\r\n      originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE\r\n    ) {\r\n      originalEnd.node.replaceData(0, originalEnd.offset, \"\");\r\n    }\r\n\r\n    this._setLiveRangeStart(newNode, newOffset);\r\n    this._setLiveRangeEnd(newNode, newOffset);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-extractcontents\r\n  extractContents() {\r\n    return extractRange(this);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-clonecontents\r\n  cloneContents() {\r\n    return cloneRange(this);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-insertnode\r\n  insertNode(node) {\r\n    insertNodeInRange(node, this);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-surroundcontents\r\n  surroundContents(newParent) {\r\n    let node = this.commonAncestorContainer;\r\n    const endNode = nextNodeDescendant(node);\r\n    while (node !== endNode) {\r\n      if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {\r\n        throw DOMException.create(this._globalObject, [\r\n          \"The Range has partially contains a non-Text node.\",\r\n          \"InvalidStateError\"\r\n        ]);\r\n      }\r\n\r\n      node = domSymbolTree.following(node);\r\n    }\r\n\r\n    if (\r\n      newParent.nodeType === NODE_TYPE.DOCUMENT_NODE ||\r\n      newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE ||\r\n      newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE\r\n    ) {\r\n      throw DOMException.create(this._globalObject, [\"Invalid element type.\", \"InvalidNodeTypeError\"]);\r\n    }\r\n\r\n    const fragment = extractRange(this);\r\n\r\n    while (domSymbolTree.firstChild(newParent)) {\r\n      newParent.removeChild(domSymbolTree.firstChild(newParent));\r\n    }\r\n\r\n    insertNodeInRange(newParent, this);\r\n\r\n    newParent.appendChild(fragment);\r\n\r\n    selectNodeWithinRange(newParent, this);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-clonerange\r\n  cloneRange() {\r\n    const { _start, _end, _globalObject } = this;\r\n\r\n    return Range.createImpl(_globalObject, [], {\r\n      start: { node: _start.node, offset: _start.offset },\r\n      end: { node: _end.node, offset: _end.offset }\r\n    });\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-detach\r\n  detach() {\r\n    // Do nothing by spec!\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-ispointinrange\r\n  isPointInRange(node, offset) {\r\n    if (nodeRoot(node) !== this._root) {\r\n      return false;\r\n    }\r\n\r\n    validateSetBoundaryPoint(node, offset);\r\n\r\n    const bp = { node, offset };\r\n\r\n    if (\r\n      compareBoundaryPointsPosition(bp, this._start) === -1 ||\r\n      compareBoundaryPointsPosition(bp, this._end) === 1\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-comparepoint\r\n  comparePoint(node, offset) {\r\n    if (nodeRoot(node) !== this._root) {\r\n      throw DOMException.create(this._globalObject, [\r\n        \"The given Node and the Range are not in the same tree.\",\r\n        \"WrongDocumentError\"\r\n      ]);\r\n    }\r\n\r\n    validateSetBoundaryPoint(node, offset);\r\n\r\n    const bp = { node, offset };\r\n    if (compareBoundaryPointsPosition(bp, this._start) === -1) {\r\n      return -1;\r\n    } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {\r\n      return 1;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-intersectsnode\r\n  intersectsNode(node) {\r\n    if (nodeRoot(node) !== this._root) {\r\n      return false;\r\n    }\r\n\r\n    const parent = domSymbolTree.parent(node);\r\n    if (!parent) {\r\n      return true;\r\n    }\r\n\r\n    const offset = domSymbolTree.index(node);\r\n\r\n    return (\r\n      compareBoundaryPointsPosition({ node: parent, offset }, this._end) === -1 &&\r\n      compareBoundaryPointsPosition({ node: parent, offset: offset + 1 }, this._start) === 1\r\n    );\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#dom-range-stringifier\r\n  toString() {\r\n    let s = \"\";\r\n    const { _start, _end } = this;\r\n\r\n    if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {\r\n      return _start.node.data.slice(_start.offset, _end.offset);\r\n    }\r\n\r\n    if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {\r\n      s += _start.node.data.slice(_start.offset);\r\n    }\r\n\r\n    let currentNode = _start.node;\r\n    const endNode = nextNodeDescendant(_end.node);\r\n    while (currentNode && currentNode !== endNode) {\r\n      if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {\r\n        s += currentNode.data;\r\n      }\r\n\r\n      currentNode = domSymbolTree.following(currentNode);\r\n    }\r\n\r\n    if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {\r\n      s += _end.node.data.slice(0, _end.offset);\r\n    }\r\n\r\n    return s;\r\n  }\r\n\r\n  // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment\r\n  createContextualFragment(fragment) {\r\n    const { node } = this._start;\r\n\r\n    let element;\r\n    switch (node.nodeType) {\r\n      case NODE_TYPE.DOCUMENT_NODE:\r\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\r\n        element = null;\r\n        break;\r\n\r\n      case NODE_TYPE.ELEMENT_NODE:\r\n        element = node;\r\n        break;\r\n\r\n      case NODE_TYPE.TEXT_NODE:\r\n      case NODE_TYPE.COMMENT_NODE:\r\n        element = node.parentElement;\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"Internal error: Invalid range start node\");\r\n    }\r\n\r\n    if (\r\n      element === null || (\r\n        element._ownerDocument._parsingMode === \"html\" &&\r\n        element._localName === \"html\" &&\r\n        element._namespaceURI === HTML_NS\r\n      )\r\n    ) {\r\n      element = createElement(node._ownerDocument, \"body\", HTML_NS);\r\n    }\r\n\r\n    return parseFragment(fragment, element);\r\n  }\r\n\r\n  // https://dom.spec.whatwg.org/#concept-range-root\r\n  get _root() {\r\n    return nodeRoot(this._start.node);\r\n  }\r\n\r\n  _setLiveRangeStart(node, offset) {\r\n    if (this._start && this._start.node !== node) {\r\n      this._start.node._referencedRanges.delete(this);\r\n    }\r\n\r\n    if (!node._referencedRanges.has(this)) {\r\n      node._referencedRanges.add(this);\r\n    }\r\n\r\n    this._start = {\r\n      node,\r\n      offset\r\n    };\r\n  }\r\n\r\n  _setLiveRangeEnd(node, offset) {\r\n    if (this._end && this._end.node !== node) {\r\n      this._end.node._referencedRanges.delete(this);\r\n    }\r\n\r\n    if (!node._referencedRanges.has(this)) {\r\n      node._referencedRanges.add(this);\r\n    }\r\n\r\n    this._end = {\r\n      node,\r\n      offset\r\n    };\r\n  }\r\n}\r\n\r\n\r\nfunction nextNodeDescendant(node) {\r\n  while (node && !domSymbolTree.nextSibling(node)) {\r\n    node = domSymbolTree.parent(node);\r\n  }\r\n\r\n  if (!node) {\r\n    return null;\r\n  }\r\n\r\n  return domSymbolTree.nextSibling(node);\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-range-bp-set\r\nfunction validateSetBoundaryPoint(node, offset) {\r\n  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\r\n    throw DOMException.create(node._globalObject, [\r\n      \"DocumentType Node can't be used as boundary point.\",\r\n      \"InvalidNodeTypeError\"\r\n    ]);\r\n  }\r\n\r\n  if (offset > nodeLength(node)) {\r\n    throw DOMException.create(node._globalObject, [\"Offset out of bound.\", \"IndexSizeError\"]);\r\n  }\r\n}\r\nfunction setBoundaryPointStart(range, node, offset) {\r\n  validateSetBoundaryPoint(node, offset);\r\n\r\n  const bp = { node, offset };\r\n  if (\r\n    nodeRoot(node) !== range._root ||\r\n    compareBoundaryPointsPosition(bp, range._end) === 1\r\n  ) {\r\n    range._setLiveRangeEnd(node, offset);\r\n  }\r\n\r\n  range._setLiveRangeStart(node, offset);\r\n}\r\nfunction setBoundaryPointEnd(range, node, offset) {\r\n  validateSetBoundaryPoint(node, offset);\r\n\r\n  const bp = { node, offset };\r\n  if (\r\n    nodeRoot(node) !== range._root ||\r\n    compareBoundaryPointsPosition(bp, range._start) === -1\r\n  ) {\r\n    range._setLiveRangeStart(node, offset);\r\n  }\r\n\r\n  range._setLiveRangeEnd(node, offset);\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-range-select\r\nfunction selectNodeWithinRange(node, range) {\r\n  const parent = domSymbolTree.parent(node);\r\n\r\n  if (!parent) {\r\n    throw DOMException.create(node._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\r\n  }\r\n\r\n  const index = domSymbolTree.index(node);\r\n\r\n  range._setLiveRangeStart(parent, index);\r\n  range._setLiveRangeEnd(parent, index + 1);\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#contained\r\nfunction isContained(node, range) {\r\n  const { _start, _end } = range;\r\n  return (\r\n    compareBoundaryPointsPosition({ node, offset: 0 }, _start) === 1 &&\r\n    compareBoundaryPointsPosition({ node, offset: nodeLength(node) }, _end) === -1\r\n  );\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#partially-contained\r\nfunction isPartiallyContained(node, range) {\r\n  const { _start, _end } = range;\r\n  return (\r\n    (isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node)) ||\r\n    (!isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node))\r\n  );\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-range-insert\r\nfunction insertNodeInRange(node, range) {\r\n  const { node: startNode, offset: startOffset } = range._start;\r\n\r\n  if (\r\n    startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n    startNode.nodeType === NODE_TYPE.COMMENT_NODE ||\r\n    (startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode)) ||\r\n    node === startNode\r\n  ) {\r\n    throw DOMException.create(node._globalObject, [\"Invalid start node.\", \"HierarchyRequestError\"]);\r\n  }\r\n\r\n  let referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ?\r\n    startNode :\r\n    domSymbolTree.childrenToArray(startNode)[startOffset] || null;\r\n  const parent = !referenceNode ?\r\n    startNode :\r\n    domSymbolTree.parent(referenceNode);\r\n\r\n  parent._preInsertValidity(node, referenceNode);\r\n\r\n  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {\r\n    referenceNode = startNode.splitText(startOffset);\r\n  }\r\n\r\n  if (node === referenceNode) {\r\n    referenceNode = domSymbolTree.nextSibling(referenceNode);\r\n  }\r\n\r\n  const nodeParent = domSymbolTree.parent(node);\r\n  if (nodeParent) {\r\n    nodeParent.removeChild(node);\r\n  }\r\n\r\n  let newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);\r\n  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;\r\n\r\n  parent.insertBefore(node, referenceNode);\r\n\r\n  if (range.collapsed) {\r\n    range._setLiveRangeEnd(parent, newOffset);\r\n  }\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-range-clone\r\nfunction cloneRange(range) {\r\n  const { _start: originalStart, _end: originalEnd, _globalObject } = range;\r\n\r\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\r\n    ownerDocument: originalStart.node._ownerDocument\r\n  });\r\n\r\n  if (range.collapsed) {\r\n    return fragment;\r\n  }\r\n\r\n  if (\r\n    originalStart.node === originalEnd.node &&\r\n    (\r\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalStart.node);\r\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n\r\n    return fragment;\r\n  }\r\n\r\n  let commonAncestor = originalStart.node;\r\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\r\n    commonAncestor = domSymbolTree.parent(commonAncestor);\r\n  }\r\n\r\n  let firstPartialContainedChild = null;\r\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\r\n    let candidate = domSymbolTree.firstChild(commonAncestor);\r\n    while (!firstPartialContainedChild) {\r\n      if (isPartiallyContained(candidate, range)) {\r\n        firstPartialContainedChild = candidate;\r\n      }\r\n\r\n      candidate = domSymbolTree.nextSibling(candidate);\r\n    }\r\n  }\r\n\r\n  let lastPartiallyContainedChild = null;\r\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\r\n    let candidate = domSymbolTree.lastChild(commonAncestor);\r\n    while (!lastPartiallyContainedChild) {\r\n      if (isPartiallyContained(candidate, range)) {\r\n        lastPartiallyContainedChild = candidate;\r\n      }\r\n\r\n      candidate = domSymbolTree.previousSibling(candidate);\r\n    }\r\n  }\r\n\r\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)\r\n    .filter(node => isContained(node, range));\r\n\r\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\r\n  if (hasDoctypeChildren) {\r\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\r\n  }\r\n\r\n  if (\r\n    firstPartialContainedChild !== null &&\r\n    (\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalStart.node);\r\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n  } else if (firstPartialContainedChild !== null) {\r\n    const cloned = clone(firstPartialContainedChild);\r\n    fragment.appendChild(cloned);\r\n\r\n    const subrange = Range.createImpl(_globalObject, [], {\r\n      start: { node: originalStart.node, offset: originalStart.offset },\r\n      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }\r\n    });\r\n\r\n    const subfragment = cloneRange(subrange);\r\n    cloned.appendChild(subfragment);\r\n  }\r\n\r\n  for (const containedChild of containedChildren) {\r\n    const cloned = clone(containedChild, undefined, true);\r\n    fragment.appendChild(cloned);\r\n  }\r\n\r\n  if (\r\n    lastPartiallyContainedChild !== null &&\r\n    (\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalEnd.node);\r\n    cloned._data = cloned.substringData(0, originalEnd.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n  } else if (lastPartiallyContainedChild !== null) {\r\n    const cloned = clone(lastPartiallyContainedChild);\r\n    fragment.appendChild(cloned);\r\n\r\n    const subrange = Range.createImpl(_globalObject, [], {\r\n      start: { node: lastPartiallyContainedChild, offset: 0 },\r\n      end: { node: originalEnd.node, offset: originalEnd.offset }\r\n    });\r\n\r\n    const subfragment = cloneRange(subrange);\r\n    cloned.appendChild(subfragment);\r\n  }\r\n\r\n  return fragment;\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-range-extract\r\nfunction extractRange(range) {\r\n  const { _start: originalStart, _end: originalEnd, _globalObject } = range;\r\n\r\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\r\n    ownerDocument: originalStart.node._ownerDocument\r\n  });\r\n\r\n  if (range.collapsed) {\r\n    return fragment;\r\n  }\r\n\r\n  if (\r\n    originalStart.node === originalEnd.node &&\r\n    (\r\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalStart.node);\r\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\r\n\r\n    return fragment;\r\n  }\r\n\r\n  let commonAncestor = originalStart.node;\r\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\r\n    commonAncestor = domSymbolTree.parent(commonAncestor);\r\n  }\r\n\r\n  let firstPartialContainedChild = null;\r\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\r\n    let candidate = domSymbolTree.firstChild(commonAncestor);\r\n    while (!firstPartialContainedChild) {\r\n      if (isPartiallyContained(candidate, range)) {\r\n        firstPartialContainedChild = candidate;\r\n      }\r\n\r\n      candidate = domSymbolTree.nextSibling(candidate);\r\n    }\r\n  }\r\n\r\n  let lastPartiallyContainedChild = null;\r\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\r\n    let candidate = domSymbolTree.lastChild(commonAncestor);\r\n    while (!lastPartiallyContainedChild) {\r\n      if (isPartiallyContained(candidate, range)) {\r\n        lastPartiallyContainedChild = candidate;\r\n      }\r\n\r\n      candidate = domSymbolTree.previousSibling(candidate);\r\n    }\r\n  }\r\n\r\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)\r\n    .filter(node => isContained(node, range));\r\n\r\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\r\n  if (hasDoctypeChildren) {\r\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\r\n  }\r\n\r\n  let newNode, newOffset;\r\n  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\r\n    newNode = originalStart.node;\r\n    newOffset = originalStart.offset;\r\n  } else {\r\n    let referenceNode = originalStart.node;\r\n\r\n    while (\r\n      referenceNode &&\r\n      !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)\r\n    ) {\r\n      referenceNode = domSymbolTree.parent(referenceNode);\r\n    }\r\n\r\n    newNode = domSymbolTree.parent(referenceNode);\r\n    newOffset = domSymbolTree.index(referenceNode) + 1;\r\n  }\r\n\r\n  if (\r\n    firstPartialContainedChild !== null &&\r\n    (\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalStart.node);\r\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n\r\n    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\r\n  } else if (firstPartialContainedChild !== null) {\r\n    const cloned = clone(firstPartialContainedChild);\r\n    fragment.appendChild(cloned);\r\n\r\n    const subrange = Range.createImpl(_globalObject, [], {\r\n      start: { node: originalStart.node, offset: originalStart.offset },\r\n      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }\r\n    });\r\n\r\n    const subfragment = extractRange(subrange);\r\n    cloned.appendChild(subfragment);\r\n  }\r\n\r\n  for (const containedChild of containedChildren) {\r\n    fragment.appendChild(containedChild);\r\n  }\r\n\r\n  if (\r\n    lastPartiallyContainedChild !== null &&\r\n    (\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\r\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\r\n    )\r\n  ) {\r\n    const cloned = clone(originalEnd.node);\r\n    cloned._data = cloned.substringData(0, originalEnd.offset);\r\n\r\n    fragment.appendChild(cloned);\r\n\r\n    originalEnd.node.replaceData(0, originalEnd.offset, \"\");\r\n  } else if (lastPartiallyContainedChild !== null) {\r\n    const cloned = clone(lastPartiallyContainedChild);\r\n    fragment.appendChild(cloned);\r\n\r\n    const subrange = Range.createImpl(_globalObject, [], {\r\n      start: { node: lastPartiallyContainedChild, offset: 0 },\r\n      end: { node: originalEnd.node, offset: originalEnd.offset }\r\n    });\r\n\r\n    const subfragment = extractRange(subrange);\r\n    cloned.appendChild(subfragment);\r\n  }\r\n\r\n  range._setLiveRangeStart(newNode, newOffset);\r\n  range._setLiveRangeEnd(newNode, newOffset);\r\n\r\n  return fragment;\r\n}\r\n\r\nmodule.exports = {\r\n  implementation: RangeImpl,\r\n\r\n  setBoundaryPointStart,\r\n  setBoundaryPointEnd\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}