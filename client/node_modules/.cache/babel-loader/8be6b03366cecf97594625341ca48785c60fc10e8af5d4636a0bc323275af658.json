{"ast":null,"code":"\"use strict\";\n\nconst NODE_TYPE = require(\"../node-type\");\nconst {\n  nodeRoot\n} = require(\"./node\");\nconst {\n  HTML_NS\n} = require(\"./namespaces\");\nconst {\n  domSymbolTree\n} = require(\"./internal-constants\");\nconst {\n  signalSlotList,\n  queueMutationObserverMicrotask\n} = require(\"./mutation-observers\");\n\n// Valid host element for ShadowRoot.\n// Defined in: https://dom.spec.whatwg.org/#dom-element-attachshadow\nconst VALID_HOST_ELEMENT_NAME = new Set([\"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\"]);\nfunction isValidHostElementName(name) {\n  return VALID_HOST_ELEMENT_NAME.has(name);\n}\n\n// Use an approximation by checking the presence of nodeType instead of instead of using the isImpl from\n// \"../generated/Node\" to avoid introduction of circular dependencies.\nfunction isNode(nodeImpl) {\n  return Boolean(nodeImpl && \"nodeType\" in nodeImpl);\n}\n\n// Use an approximation by checking the value of nodeType and presence of nodeType host instead of instead\n// of using the isImpl from \"../generated/ShadowRoot\" to avoid introduction of circular dependencies.\nfunction isShadowRoot(nodeImpl) {\n  return Boolean(nodeImpl && nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE && \"host\" in nodeImpl);\n}\n\n// https://dom.spec.whatwg.org/#concept-slotable\nfunction isSlotable(nodeImpl) {\n  return nodeImpl && (nodeImpl.nodeType === NODE_TYPE.ELEMENT_NODE || nodeImpl.nodeType === NODE_TYPE.TEXT_NODE);\n}\nfunction isSlot(nodeImpl) {\n  return nodeImpl && nodeImpl.localName === \"slot\" && nodeImpl._namespaceURI === HTML_NS;\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-ancestor\nfunction isShadowInclusiveAncestor(ancestor, node) {\n  while (isNode(node)) {\n    if (node === ancestor) {\n      return true;\n    }\n    if (isShadowRoot(node)) {\n      node = node.host;\n    } else {\n      node = domSymbolTree.parent(node);\n    }\n  }\n  return false;\n}\n\n// https://dom.spec.whatwg.org/#retarget\nfunction retarget(a, b) {\n  while (true) {\n    if (!isNode(a)) {\n      return a;\n    }\n    const aRoot = nodeRoot(a);\n    if (!isShadowRoot(aRoot) || isNode(b) && isShadowInclusiveAncestor(aRoot, b)) {\n      return a;\n    }\n    a = nodeRoot(a).host;\n  }\n}\n\n// https://dom.spec.whatwg.org/#get-the-parent\nfunction getEventTargetParent(eventTarget, event) {\n  // _getTheParent will be missing for Window, since it doesn't have an impl class and we don't want to pollute the\n  // user-visible global scope with a _getTheParent value. TODO: remove this entire function and use _getTheParent\n  // directly, once Window gets split into impl/wrapper.\n  return eventTarget._getTheParent ? eventTarget._getTheParent(event) : null;\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-root\nfunction shadowIncludingRoot(node) {\n  const root = nodeRoot(node);\n  return isShadowRoot(root) ? shadowIncludingRoot(root.host) : root;\n}\n\n// https://dom.spec.whatwg.org/#assign-a-slot\nfunction assignSlot(slotable) {\n  const slot = findSlot(slotable);\n  if (slot) {\n    assignSlotable(slot);\n  }\n}\n\n// https://dom.spec.whatwg.org/#assign-slotables\nfunction assignSlotable(slot) {\n  const slotables = findSlotable(slot);\n  let shouldFireSlotChange = false;\n  if (slotables.length !== slot._assignedNodes.length) {\n    shouldFireSlotChange = true;\n  } else {\n    for (let i = 0; i < slotables.length; i++) {\n      if (slotables[i] !== slot._assignedNodes[i]) {\n        shouldFireSlotChange = true;\n        break;\n      }\n    }\n  }\n  if (shouldFireSlotChange) {\n    signalSlotChange(slot);\n  }\n  slot._assignedNodes = slotables;\n  for (const slotable of slotables) {\n    slotable._assignedSlot = slot;\n  }\n}\n\n// https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\nfunction assignSlotableForTree(root) {\n  for (const slot of domSymbolTree.treeIterator(root)) {\n    if (isSlot(slot)) {\n      assignSlotable(slot);\n    }\n  }\n}\n\n// https://dom.spec.whatwg.org/#find-slotables\nfunction findSlotable(slot) {\n  const result = [];\n  const root = nodeRoot(slot);\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n  for (const slotable of domSymbolTree.treeIterator(root.host)) {\n    const foundSlot = findSlot(slotable);\n    if (foundSlot === slot) {\n      result.push(slotable);\n    }\n  }\n  return result;\n}\n\n// https://dom.spec.whatwg.org/#find-flattened-slotables\nfunction findFlattenedSlotables(slot) {\n  const result = [];\n  const root = nodeRoot(slot);\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n  const slotables = findSlotable(slot);\n  if (slotables.length === 0) {\n    for (const child of domSymbolTree.childrenIterator(slot)) {\n      if (isSlotable(child)) {\n        slotables.push(child);\n      }\n    }\n  }\n  for (const node of slotables) {\n    if (isSlot(node) && isShadowRoot(nodeRoot(node))) {\n      const temporaryResult = findFlattenedSlotables(node);\n      result.push(...temporaryResult);\n    } else {\n      result.push(node);\n    }\n  }\n  return result;\n}\n\n// https://dom.spec.whatwg.org/#find-a-slot\nfunction findSlot(slotable, openFlag) {\n  const {\n    parentNode: parent\n  } = slotable;\n  if (!parent) {\n    return null;\n  }\n  const shadow = parent._shadowRoot;\n  if (!shadow || openFlag && shadow.mode !== \"open\") {\n    return null;\n  }\n  for (const child of domSymbolTree.treeIterator(shadow)) {\n    if (isSlot(child) && child.name === slotable._slotableName) {\n      return child;\n    }\n  }\n  return null;\n}\n\n// https://dom.spec.whatwg.org/#signal-a-slot-change\nfunction signalSlotChange(slot) {\n  if (!signalSlotList.some(entry => entry === slot)) {\n    signalSlotList.push(slot);\n  }\n  queueMutationObserverMicrotask();\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-descendant\nfunction* shadowIncludingInclusiveDescendantsIterator(node) {\n  yield node;\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-descendant\nfunction* shadowIncludingDescendantsIterator(node) {\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n}\nmodule.exports = {\n  isValidHostElementName,\n  isNode,\n  isSlotable,\n  isSlot,\n  isShadowRoot,\n  isShadowInclusiveAncestor,\n  retarget,\n  getEventTargetParent,\n  shadowIncludingRoot,\n  assignSlot,\n  assignSlotable,\n  assignSlotableForTree,\n  findSlot,\n  findFlattenedSlotables,\n  signalSlotChange,\n  shadowIncludingInclusiveDescendantsIterator,\n  shadowIncludingDescendantsIterator\n};","map":{"version":3,"names":["NODE_TYPE","require","nodeRoot","HTML_NS","domSymbolTree","signalSlotList","queueMutationObserverMicrotask","VALID_HOST_ELEMENT_NAME","Set","isValidHostElementName","name","has","isNode","nodeImpl","Boolean","isShadowRoot","nodeType","DOCUMENT_FRAGMENT_NODE","isSlotable","ELEMENT_NODE","TEXT_NODE","isSlot","localName","_namespaceURI","isShadowInclusiveAncestor","ancestor","node","host","parent","retarget","a","b","aRoot","getEventTargetParent","eventTarget","event","_getTheParent","shadowIncludingRoot","root","assignSlot","slotable","slot","findSlot","assignSlotable","slotables","findSlotable","shouldFireSlotChange","length","_assignedNodes","i","signalSlotChange","_assignedSlot","assignSlotableForTree","treeIterator","result","foundSlot","push","findFlattenedSlotables","child","childrenIterator","temporaryResult","openFlag","parentNode","shadow","_shadowRoot","mode","_slotableName","some","entry","shadowIncludingInclusiveDescendantsIterator","shadowIncludingDescendantsIterator","module","exports"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/jsdom/living/helpers/shadow-dom.js"],"sourcesContent":["\"use strict\";\r\n\r\nconst NODE_TYPE = require(\"../node-type\");\r\n\r\nconst { nodeRoot } = require(\"./node\");\r\nconst { HTML_NS } = require(\"./namespaces\");\r\nconst { domSymbolTree } = require(\"./internal-constants\");\r\nconst { signalSlotList, queueMutationObserverMicrotask } = require(\"./mutation-observers\");\r\n\r\n// Valid host element for ShadowRoot.\r\n// Defined in: https://dom.spec.whatwg.org/#dom-element-attachshadow\r\nconst VALID_HOST_ELEMENT_NAME = new Set([\r\n  \"article\",\r\n  \"aside\",\r\n  \"blockquote\",\r\n  \"body\",\r\n  \"div\",\r\n  \"footer\",\r\n  \"h1\",\r\n  \"h2\",\r\n  \"h3\",\r\n  \"h4\",\r\n  \"h5\",\r\n  \"h6\",\r\n  \"header\",\r\n  \"main\",\r\n  \"nav\",\r\n  \"p\",\r\n  \"section\",\r\n  \"span\"\r\n]);\r\n\r\nfunction isValidHostElementName(name) {\r\n  return VALID_HOST_ELEMENT_NAME.has(name);\r\n}\r\n\r\n// Use an approximation by checking the presence of nodeType instead of instead of using the isImpl from\r\n// \"../generated/Node\" to avoid introduction of circular dependencies.\r\nfunction isNode(nodeImpl) {\r\n  return Boolean(nodeImpl && \"nodeType\" in nodeImpl);\r\n}\r\n\r\n// Use an approximation by checking the value of nodeType and presence of nodeType host instead of instead\r\n// of using the isImpl from \"../generated/ShadowRoot\" to avoid introduction of circular dependencies.\r\nfunction isShadowRoot(nodeImpl) {\r\n  return Boolean(nodeImpl && nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE && \"host\" in nodeImpl);\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-slotable\r\nfunction isSlotable(nodeImpl) {\r\n  return nodeImpl && (nodeImpl.nodeType === NODE_TYPE.ELEMENT_NODE || nodeImpl.nodeType === NODE_TYPE.TEXT_NODE);\r\n}\r\n\r\nfunction isSlot(nodeImpl) {\r\n  return nodeImpl && nodeImpl.localName === \"slot\" && nodeImpl._namespaceURI === HTML_NS;\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-ancestor\r\nfunction isShadowInclusiveAncestor(ancestor, node) {\r\n  while (isNode(node)) {\r\n    if (node === ancestor) {\r\n      return true;\r\n    }\r\n\r\n    if (isShadowRoot(node)) {\r\n      node = node.host;\r\n    } else {\r\n      node = domSymbolTree.parent(node);\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#retarget\r\nfunction retarget(a, b) {\r\n  while (true) {\r\n    if (!isNode(a)) {\r\n      return a;\r\n    }\r\n\r\n    const aRoot = nodeRoot(a);\r\n    if (\r\n      !isShadowRoot(aRoot) ||\r\n      (isNode(b) && isShadowInclusiveAncestor(aRoot, b))\r\n    ) {\r\n      return a;\r\n    }\r\n\r\n    a = nodeRoot(a).host;\r\n  }\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#get-the-parent\r\nfunction getEventTargetParent(eventTarget, event) {\r\n  // _getTheParent will be missing for Window, since it doesn't have an impl class and we don't want to pollute the\r\n  // user-visible global scope with a _getTheParent value. TODO: remove this entire function and use _getTheParent\r\n  // directly, once Window gets split into impl/wrapper.\r\n  return eventTarget._getTheParent ? eventTarget._getTheParent(event) : null;\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-shadow-including-root\r\nfunction shadowIncludingRoot(node) {\r\n  const root = nodeRoot(node);\r\n  return isShadowRoot(root) ? shadowIncludingRoot(root.host) : root;\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#assign-a-slot\r\nfunction assignSlot(slotable) {\r\n  const slot = findSlot(slotable);\r\n\r\n  if (slot) {\r\n    assignSlotable(slot);\r\n  }\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#assign-slotables\r\nfunction assignSlotable(slot) {\r\n  const slotables = findSlotable(slot);\r\n\r\n  let shouldFireSlotChange = false;\r\n\r\n  if (slotables.length !== slot._assignedNodes.length) {\r\n    shouldFireSlotChange = true;\r\n  } else {\r\n    for (let i = 0; i < slotables.length; i++) {\r\n      if (slotables[i] !== slot._assignedNodes[i]) {\r\n        shouldFireSlotChange = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (shouldFireSlotChange) {\r\n    signalSlotChange(slot);\r\n  }\r\n\r\n  slot._assignedNodes = slotables;\r\n\r\n  for (const slotable of slotables) {\r\n    slotable._assignedSlot = slot;\r\n  }\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\r\nfunction assignSlotableForTree(root) {\r\n  for (const slot of domSymbolTree.treeIterator(root)) {\r\n    if (isSlot(slot)) {\r\n      assignSlotable(slot);\r\n    }\r\n  }\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#find-slotables\r\nfunction findSlotable(slot) {\r\n  const result = [];\r\n\r\n  const root = nodeRoot(slot);\r\n  if (!isShadowRoot(root)) {\r\n    return result;\r\n  }\r\n\r\n  for (const slotable of domSymbolTree.treeIterator(root.host)) {\r\n    const foundSlot = findSlot(slotable);\r\n\r\n    if (foundSlot === slot) {\r\n      result.push(slotable);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#find-flattened-slotables\r\nfunction findFlattenedSlotables(slot) {\r\n  const result = [];\r\n\r\n  const root = nodeRoot(slot);\r\n  if (!isShadowRoot(root)) {\r\n    return result;\r\n  }\r\n\r\n  const slotables = findSlotable(slot);\r\n\r\n  if (slotables.length === 0) {\r\n    for (const child of domSymbolTree.childrenIterator(slot)) {\r\n      if (isSlotable(child)) {\r\n        slotables.push(child);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const node of slotables) {\r\n    if (isSlot(node) && isShadowRoot(nodeRoot(node))) {\r\n      const temporaryResult = findFlattenedSlotables(node);\r\n      result.push(...temporaryResult);\r\n    } else {\r\n      result.push(node);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#find-a-slot\r\nfunction findSlot(slotable, openFlag) {\r\n  const { parentNode: parent } = slotable;\r\n\r\n  if (!parent) {\r\n    return null;\r\n  }\r\n\r\n  const shadow = parent._shadowRoot;\r\n\r\n  if (!shadow || (openFlag && shadow.mode !== \"open\")) {\r\n    return null;\r\n  }\r\n\r\n  for (const child of domSymbolTree.treeIterator(shadow)) {\r\n    if (isSlot(child) && child.name === slotable._slotableName) {\r\n      return child;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#signal-a-slot-change\r\nfunction signalSlotChange(slot) {\r\n  if (!signalSlotList.some(entry => entry === slot)) {\r\n    signalSlotList.push(slot);\r\n  }\r\n\r\n  queueMutationObserverMicrotask();\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-shadow-including-descendant\r\nfunction* shadowIncludingInclusiveDescendantsIterator(node) {\r\n  yield node;\r\n\r\n  if (node._shadowRoot) {\r\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\r\n  }\r\n\r\n  for (const child of domSymbolTree.childrenIterator(node)) {\r\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\r\n  }\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#concept-shadow-including-descendant\r\nfunction* shadowIncludingDescendantsIterator(node) {\r\n  if (node._shadowRoot) {\r\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\r\n  }\r\n\r\n  for (const child of domSymbolTree.childrenIterator(node)) {\r\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  isValidHostElementName,\r\n\r\n  isNode,\r\n  isSlotable,\r\n  isSlot,\r\n  isShadowRoot,\r\n\r\n  isShadowInclusiveAncestor,\r\n  retarget,\r\n  getEventTargetParent,\r\n  shadowIncludingRoot,\r\n\r\n  assignSlot,\r\n  assignSlotable,\r\n  assignSlotableForTree,\r\n\r\n  findSlot,\r\n  findFlattenedSlotables,\r\n\r\n  signalSlotChange,\r\n\r\n  shadowIncludingInclusiveDescendantsIterator,\r\n  shadowIncludingDescendantsIterator\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}