{"ast":null,"code":"'use strict';\n\nvar acorn = require('acorn');\nvar walk = require('acorn-walk');\nfunction isScope(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'ArrowFunctionExpression' || node.type === 'Program';\n}\nfunction isBlockScope(node) {\n  return node.type === 'BlockStatement' || isScope(node);\n}\nfunction declaresArguments(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\nfunction declaresThis(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\nfunction reallyParse(source, options) {\n  var parseOptions = Object.assign({}, options, {\n    allowReturnOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowHashBang: true\n  });\n  return acorn.parse(source, parseOptions);\n}\nmodule.exports = findGlobals;\nmodule.exports.parse = reallyParse;\nfunction findGlobals(source, options) {\n  options = options || {};\n  var globals = [];\n  var ast;\n  // istanbul ignore else\n  if (typeof source === 'string') {\n    ast = reallyParse(source, options);\n  } else {\n    ast = source;\n  }\n  // istanbul ignore if\n  if (!(ast && typeof ast === 'object' && ast.type === 'Program')) {\n    throw new TypeError('Source must be either a string of JavaScript or an acorn AST');\n  }\n  var declareFunction = function (node) {\n    var fn = node;\n    fn.locals = fn.locals || Object.create(null);\n    node.params.forEach(function (node) {\n      declarePattern(node, fn);\n    });\n    if (node.id) {\n      fn.locals[node.id.name] = true;\n    }\n  };\n  var declareClass = function (node) {\n    node.locals = node.locals || Object.create(null);\n    if (node.id) {\n      node.locals[node.id.name] = true;\n    }\n  };\n  var declarePattern = function (node, parent) {\n    switch (node.type) {\n      case 'Identifier':\n        parent.locals[node.name] = true;\n        break;\n      case 'ObjectPattern':\n        node.properties.forEach(function (node) {\n          declarePattern(node.value || node.argument, parent);\n        });\n        break;\n      case 'ArrayPattern':\n        node.elements.forEach(function (node) {\n          if (node) declarePattern(node, parent);\n        });\n        break;\n      case 'RestElement':\n        declarePattern(node.argument, parent);\n        break;\n      case 'AssignmentPattern':\n        declarePattern(node.left, parent);\n        break;\n      // istanbul ignore next\n      default:\n        throw new Error('Unrecognized pattern type: ' + node.type);\n    }\n  };\n  var declareModuleSpecifier = function (node, parents) {\n    ast.locals = ast.locals || Object.create(null);\n    ast.locals[node.local.name] = true;\n  };\n  walk.ancestor(ast, {\n    'VariableDeclaration': function (node, parents) {\n      var parent = null;\n      for (var i = parents.length - 1; i >= 0 && parent === null; i--) {\n        if (node.kind === 'var' ? isScope(parents[i]) : isBlockScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n      parent.locals = parent.locals || Object.create(null);\n      node.declarations.forEach(function (declaration) {\n        declarePattern(declaration.id, parent);\n      });\n    },\n    'FunctionDeclaration': function (node, parents) {\n      var parent = null;\n      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {\n        if (isScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n      parent.locals = parent.locals || Object.create(null);\n      if (node.id) {\n        parent.locals[node.id.name] = true;\n      }\n      declareFunction(node);\n    },\n    'Function': declareFunction,\n    'ClassDeclaration': function (node, parents) {\n      var parent = null;\n      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {\n        if (isBlockScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n      parent.locals = parent.locals || Object.create(null);\n      if (node.id) {\n        parent.locals[node.id.name] = true;\n      }\n      declareClass(node);\n    },\n    'Class': declareClass,\n    'TryStatement': function (node) {\n      if (node.handler === null) return;\n      node.handler.locals = node.handler.locals || Object.create(null);\n      declarePattern(node.handler.param, node.handler);\n    },\n    'ImportDefaultSpecifier': declareModuleSpecifier,\n    'ImportSpecifier': declareModuleSpecifier,\n    'ImportNamespaceSpecifier': declareModuleSpecifier\n  });\n  function identifier(node, parents) {\n    var name = node.name;\n    if (name === 'undefined') return;\n    for (var i = 0; i < parents.length; i++) {\n      if (name === 'arguments' && declaresArguments(parents[i])) {\n        return;\n      }\n      if (parents[i].locals && name in parents[i].locals) {\n        return;\n      }\n    }\n    node.parents = parents.slice();\n    globals.push(node);\n  }\n  walk.ancestor(ast, {\n    'VariablePattern': identifier,\n    'Identifier': identifier,\n    'ThisExpression': function (node, parents) {\n      for (var i = 0; i < parents.length; i++) {\n        if (declaresThis(parents[i])) {\n          return;\n        }\n      }\n      node.parents = parents.slice();\n      globals.push(node);\n    }\n  });\n  var groupedGlobals = Object.create(null);\n  globals.forEach(function (node) {\n    var name = node.type === 'ThisExpression' ? 'this' : node.name;\n    groupedGlobals[name] = groupedGlobals[name] || [];\n    groupedGlobals[name].push(node);\n  });\n  return Object.keys(groupedGlobals).sort().map(function (name) {\n    return {\n      name: name,\n      nodes: groupedGlobals[name]\n    };\n  });\n}","map":{"version":3,"names":["acorn","require","walk","isScope","node","type","isBlockScope","declaresArguments","declaresThis","reallyParse","source","options","parseOptions","Object","assign","allowReturnOutsideFunction","allowImportExportEverywhere","allowHashBang","parse","module","exports","findGlobals","globals","ast","TypeError","declareFunction","fn","locals","create","params","forEach","declarePattern","id","name","declareClass","parent","properties","value","argument","elements","left","Error","declareModuleSpecifier","parents","local","ancestor","VariableDeclaration","i","length","kind","declarations","declaration","FunctionDeclaration","ClassDeclaration","TryStatement","handler","param","identifier","slice","push","ThisExpression","groupedGlobals","keys","sort","map","nodes"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/acorn-globals/index.js"],"sourcesContent":["'use strict';\r\n\r\nvar acorn = require('acorn');\r\nvar walk = require('acorn-walk');\r\n\r\nfunction isScope(node) {\r\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'ArrowFunctionExpression' || node.type === 'Program';\r\n}\r\nfunction isBlockScope(node) {\r\n  return node.type === 'BlockStatement' || isScope(node);\r\n}\r\n\r\nfunction declaresArguments(node) {\r\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\r\n}\r\n\r\nfunction declaresThis(node) {\r\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\r\n}\r\n\r\nfunction reallyParse(source, options) {\r\n  var parseOptions = Object.assign({}, options,\r\n    {\r\n      allowReturnOutsideFunction: true,\r\n      allowImportExportEverywhere: true,\r\n      allowHashBang: true\r\n    }\r\n  );\r\n  return acorn.parse(source, parseOptions);\r\n}\r\nmodule.exports = findGlobals;\r\nmodule.exports.parse = reallyParse;\r\nfunction findGlobals(source, options) {\r\n  options = options || {};\r\n  var globals = [];\r\n  var ast;\r\n  // istanbul ignore else\r\n  if (typeof source === 'string') {\r\n    ast = reallyParse(source, options);\r\n  } else {\r\n    ast = source;\r\n  }\r\n  // istanbul ignore if\r\n  if (!(ast && typeof ast === 'object' && ast.type === 'Program')) {\r\n    throw new TypeError('Source must be either a string of JavaScript or an acorn AST');\r\n  }\r\n  var declareFunction = function (node) {\r\n    var fn = node;\r\n    fn.locals = fn.locals || Object.create(null);\r\n    node.params.forEach(function (node) {\r\n      declarePattern(node, fn);\r\n    });\r\n    if (node.id) {\r\n      fn.locals[node.id.name] = true;\r\n    }\r\n  };\r\n  var declareClass = function (node) {\r\n    node.locals = node.locals || Object.create(null);\r\n    if (node.id) {\r\n      node.locals[node.id.name] = true;\r\n    }\r\n  };\r\n  var declarePattern = function (node, parent) {\r\n    switch (node.type) {\r\n      case 'Identifier':\r\n        parent.locals[node.name] = true;\r\n        break;\r\n      case 'ObjectPattern':\r\n        node.properties.forEach(function (node) {\r\n          declarePattern(node.value || node.argument, parent);\r\n        });\r\n        break;\r\n      case 'ArrayPattern':\r\n        node.elements.forEach(function (node) {\r\n          if (node) declarePattern(node, parent);\r\n        });\r\n        break;\r\n      case 'RestElement':\r\n        declarePattern(node.argument, parent);\r\n        break;\r\n      case 'AssignmentPattern':\r\n        declarePattern(node.left, parent);\r\n        break;\r\n      // istanbul ignore next\r\n      default:\r\n        throw new Error('Unrecognized pattern type: ' + node.type);\r\n    }\r\n  };\r\n  var declareModuleSpecifier = function (node, parents) {\r\n    ast.locals = ast.locals || Object.create(null);\r\n    ast.locals[node.local.name] = true;\r\n  };\r\n  walk.ancestor(ast, {\r\n    'VariableDeclaration': function (node, parents) {\r\n      var parent = null;\r\n      for (var i = parents.length - 1; i >= 0 && parent === null; i--) {\r\n        if (node.kind === 'var' ? isScope(parents[i]) : isBlockScope(parents[i])) {\r\n          parent = parents[i];\r\n        }\r\n      }\r\n      parent.locals = parent.locals || Object.create(null);\r\n      node.declarations.forEach(function (declaration) {\r\n        declarePattern(declaration.id, parent);\r\n      });\r\n    },\r\n    'FunctionDeclaration': function (node, parents) {\r\n      var parent = null;\r\n      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {\r\n        if (isScope(parents[i])) {\r\n          parent = parents[i];\r\n        }\r\n      }\r\n      parent.locals = parent.locals || Object.create(null);\r\n      if (node.id) {\r\n        parent.locals[node.id.name] = true;\r\n      }\r\n      declareFunction(node);\r\n    },\r\n    'Function': declareFunction,\r\n    'ClassDeclaration': function (node, parents) {\r\n      var parent = null;\r\n      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {\r\n        if (isBlockScope(parents[i])) {\r\n          parent = parents[i];\r\n        }\r\n      }\r\n      parent.locals = parent.locals || Object.create(null);\r\n      if (node.id) {\r\n        parent.locals[node.id.name] = true;\r\n      }\r\n      declareClass(node);\r\n    },\r\n    'Class': declareClass,\r\n    'TryStatement': function (node) {\r\n      if (node.handler === null) return;\r\n      node.handler.locals = node.handler.locals || Object.create(null);\r\n      declarePattern(node.handler.param, node.handler);\r\n    },\r\n    'ImportDefaultSpecifier': declareModuleSpecifier,\r\n    'ImportSpecifier': declareModuleSpecifier,\r\n    'ImportNamespaceSpecifier': declareModuleSpecifier\r\n  });\r\n  function identifier(node, parents) {\r\n    var name = node.name;\r\n    if (name === 'undefined') return;\r\n    for (var i = 0; i < parents.length; i++) {\r\n      if (name === 'arguments' && declaresArguments(parents[i])) {\r\n        return;\r\n      }\r\n      if (parents[i].locals && name in parents[i].locals) {\r\n        return;\r\n      }\r\n    }\r\n    node.parents = parents.slice();\r\n    globals.push(node);\r\n  }\r\n  walk.ancestor(ast, {\r\n    'VariablePattern': identifier,\r\n    'Identifier': identifier,\r\n    'ThisExpression': function (node, parents) {\r\n      for (var i = 0; i < parents.length; i++) {\r\n        if (declaresThis(parents[i])) {\r\n          return;\r\n        }\r\n      }\r\n      node.parents = parents.slice();\r\n      globals.push(node);\r\n    }\r\n  });\r\n  var groupedGlobals = Object.create(null);\r\n  globals.forEach(function (node) {\r\n    var name = node.type === 'ThisExpression' ? 'this' : node.name;\r\n    groupedGlobals[name] = (groupedGlobals[name] || []);\r\n    groupedGlobals[name].push(node);\r\n  });\r\n  return Object.keys(groupedGlobals).sort().map(function (name) {\r\n    return {name: name, nodes: groupedGlobals[name]};\r\n  });\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}