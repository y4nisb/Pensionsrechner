{"ast":null,"code":"'use strict';\n\nmodule.exports = class SymbolTreeNode {\n  constructor() {\n    this.parent = null;\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.firstChild = null;\n    this.lastChild = null;\n\n    /** This value is incremented anytime a children is added or removed */\n    this.childrenVersion = 0;\n    /** The last child object which has a cached index */\n    this.childIndexCachedUpTo = null;\n\n    /** This value represents the cached node index, as long as\r\n     * cachedIndexVersion matches with the childrenVersion of the parent */\n    this.cachedIndex = -1;\n    this.cachedIndexVersion = NaN; // NaN is never equal to anything\n  }\n\n  get isAttached() {\n    return Boolean(this.parent || this.previousSibling || this.nextSibling);\n  }\n  get hasChildren() {\n    return Boolean(this.firstChild);\n  }\n  childrenChanged() {\n    /* jshint -W016 */\n    // integer wrap around\n    this.childrenVersion = this.childrenVersion + 1 & 0xFFFFFFFF;\n    this.childIndexCachedUpTo = null;\n  }\n  getCachedIndex(parentNode) {\n    // (assumes parentNode is actually the parent)\n    if (this.cachedIndexVersion !== parentNode.childrenVersion) {\n      this.cachedIndexVersion = NaN;\n      // cachedIndex is no longer valid\n      return -1;\n    }\n    return this.cachedIndex; // -1 if not cached\n  }\n\n  setCachedIndex(parentNode, index) {\n    // (assumes parentNode is actually the parent)\n    this.cachedIndexVersion = parentNode.childrenVersion;\n    this.cachedIndex = index;\n  }\n};","map":{"version":3,"names":["module","exports","SymbolTreeNode","constructor","parent","previousSibling","nextSibling","firstChild","lastChild","childrenVersion","childIndexCachedUpTo","cachedIndex","cachedIndexVersion","NaN","isAttached","Boolean","hasChildren","childrenChanged","getCachedIndex","parentNode","setCachedIndex","index"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/symbol-tree/lib/SymbolTreeNode.js"],"sourcesContent":["'use strict';\r\n\r\nmodule.exports = class SymbolTreeNode {\r\n        constructor() {\r\n                this.parent = null;\r\n                this.previousSibling = null;\r\n                this.nextSibling = null;\r\n\r\n                this.firstChild = null;\r\n                this.lastChild = null;\r\n\r\n                /** This value is incremented anytime a children is added or removed */\r\n                this.childrenVersion = 0;\r\n                /** The last child object which has a cached index */\r\n                this.childIndexCachedUpTo = null;\r\n\r\n                /** This value represents the cached node index, as long as\r\n                 * cachedIndexVersion matches with the childrenVersion of the parent */\r\n                this.cachedIndex = -1;\r\n                this.cachedIndexVersion = NaN; // NaN is never equal to anything\r\n        }\r\n\r\n        get isAttached() {\r\n                return Boolean(this.parent || this.previousSibling || this.nextSibling);\r\n        }\r\n\r\n        get hasChildren() {\r\n                return Boolean(this.firstChild);\r\n        }\r\n\r\n        childrenChanged() {\r\n                /* jshint -W016 */\r\n                // integer wrap around\r\n                this.childrenVersion = (this.childrenVersion + 1) & 0xFFFFFFFF;\r\n                this.childIndexCachedUpTo = null;\r\n        }\r\n\r\n        getCachedIndex(parentNode) {\r\n                // (assumes parentNode is actually the parent)\r\n                if (this.cachedIndexVersion !== parentNode.childrenVersion) {\r\n                        this.cachedIndexVersion = NaN;\r\n                        // cachedIndex is no longer valid\r\n                        return -1;\r\n                }\r\n\r\n                return this.cachedIndex; // -1 if not cached\r\n        }\r\n\r\n        setCachedIndex(parentNode, index) {\r\n                // (assumes parentNode is actually the parent)\r\n                this.cachedIndexVersion = parentNode.childrenVersion;\r\n                this.cachedIndex = index;\r\n        }\r\n};\r\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAG,MAAMC,cAAc,CAAC;EAC9BC,WAAWA,CAAA,EAAG;IACN,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACC,WAAW,GAAG,IAAI;IAEvB,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,SAAS,GAAG,IAAI;;IAErB;IACA,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB;IACA,IAAI,CAACC,oBAAoB,GAAG,IAAI;;IAEhC;AAChB;IACgB,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;IACrB,IAAI,CAACC,kBAAkB,GAAGC,GAAG,CAAC,CAAC;EACvC;;EAEA,IAAIC,UAAUA,CAAA,EAAG;IACT,OAAOC,OAAO,CAAC,IAAI,CAACX,MAAM,IAAI,IAAI,CAACC,eAAe,IAAI,IAAI,CAACC,WAAW,CAAC;EAC/E;EAEA,IAAIU,WAAWA,CAAA,EAAG;IACV,OAAOD,OAAO,CAAC,IAAI,CAACR,UAAU,CAAC;EACvC;EAEAU,eAAeA,CAAA,EAAG;IACV;IACA;IACA,IAAI,CAACR,eAAe,GAAI,IAAI,CAACA,eAAe,GAAG,CAAC,GAAI,UAAU;IAC9D,IAAI,CAACC,oBAAoB,GAAG,IAAI;EACxC;EAEAQ,cAAcA,CAACC,UAAU,EAAE;IACnB;IACA,IAAI,IAAI,CAACP,kBAAkB,KAAKO,UAAU,CAACV,eAAe,EAAE;MACpD,IAAI,CAACG,kBAAkB,GAAGC,GAAG;MAC7B;MACA,OAAO,CAAC,CAAC;IACjB;IAEA,OAAO,IAAI,CAACF,WAAW,CAAC,CAAC;EACjC;;EAEAS,cAAcA,CAACD,UAAU,EAAEE,KAAK,EAAE;IAC1B;IACA,IAAI,CAACT,kBAAkB,GAAGO,UAAU,CAACV,eAAe;IACpD,IAAI,CAACE,WAAW,GAAGU,KAAK;EAChC;AACR,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}