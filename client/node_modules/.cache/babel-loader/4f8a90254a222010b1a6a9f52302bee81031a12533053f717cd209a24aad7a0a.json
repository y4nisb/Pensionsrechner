{"ast":null,"code":"\"use strict\";\n\nconst {\n  convertNodesIntoNode\n} = require(\"../node\");\nclass ChildNodeImpl {\n  remove() {\n    if (!this.parentNode) {\n      return;\n    }\n    this.parentNode._remove(this);\n  }\n  after() {\n    const parent = this.parentNode;\n    if (parent) {\n      let viableNextSibling = this.nextSibling;\n      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n        nodes[_key] = arguments[_key];\n      }\n      let idx = viableNextSibling ? nodes.indexOf(viableNextSibling) : -1;\n      while (idx !== -1) {\n        viableNextSibling = viableNextSibling.nextSibling;\n        if (!viableNextSibling) {\n          break;\n        }\n        idx = nodes.indexOf(viableNextSibling);\n      }\n      parent._preInsert(convertNodesIntoNode(this._ownerDocument, nodes), viableNextSibling);\n    }\n  }\n  before() {\n    const parent = this.parentNode;\n    if (parent) {\n      let viablePreviousSibling = this.previousSibling;\n      for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        nodes[_key2] = arguments[_key2];\n      }\n      let idx = viablePreviousSibling ? nodes.indexOf(viablePreviousSibling) : -1;\n      while (idx !== -1) {\n        viablePreviousSibling = viablePreviousSibling.previousSibling;\n        if (!viablePreviousSibling) {\n          break;\n        }\n        idx = nodes.indexOf(viablePreviousSibling);\n      }\n      parent._preInsert(convertNodesIntoNode(this._ownerDocument, nodes), viablePreviousSibling ? viablePreviousSibling.nextSibling : parent.firstChild);\n    }\n  }\n  replaceWith() {\n    const parent = this.parentNode;\n    if (parent) {\n      let viableNextSibling = this.nextSibling;\n      for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        nodes[_key3] = arguments[_key3];\n      }\n      let idx = viableNextSibling ? nodes.indexOf(viableNextSibling) : -1;\n      while (idx !== -1) {\n        viableNextSibling = viableNextSibling.nextSibling;\n        if (!viableNextSibling) {\n          break;\n        }\n        idx = nodes.indexOf(viableNextSibling);\n      }\n      const node = convertNodesIntoNode(this._ownerDocument, nodes);\n      if (this.parentNode === parent) {\n        parent._replace(node, this);\n      } else {\n        parent._preInsert(node, viableNextSibling);\n      }\n    }\n  }\n}\nmodule.exports = {\n  implementation: ChildNodeImpl\n};","map":{"version":3,"names":["convertNodesIntoNode","require","ChildNodeImpl","remove","parentNode","_remove","after","parent","viableNextSibling","nextSibling","_len","arguments","length","nodes","Array","_key","idx","indexOf","_preInsert","_ownerDocument","before","viablePreviousSibling","previousSibling","_len2","_key2","firstChild","replaceWith","_len3","_key3","node","_replace","module","exports","implementation"],"sources":["C:/Users/noodp/Documents/GitHub/Pensionsrechner/client/node_modules/jsdom/lib/jsdom/living/nodes/ChildNode-impl.js"],"sourcesContent":["\"use strict\";\r\n\r\nconst { convertNodesIntoNode } = require(\"../node\");\r\n\r\nclass ChildNodeImpl {\r\n  remove() {\r\n    if (!this.parentNode) {\r\n      return;\r\n    }\r\n\r\n    this.parentNode._remove(this);\r\n  }\r\n\r\n  after(...nodes) {\r\n    const parent = this.parentNode;\r\n    if (parent) {\r\n      let viableNextSibling = this.nextSibling;\r\n      let idx = viableNextSibling ? nodes.indexOf(viableNextSibling) : -1;\r\n\r\n      while (idx !== -1) {\r\n        viableNextSibling = viableNextSibling.nextSibling;\r\n        if (!viableNextSibling) {\r\n          break;\r\n        }\r\n        idx = nodes.indexOf(viableNextSibling);\r\n      }\r\n\r\n      parent._preInsert(convertNodesIntoNode(this._ownerDocument, nodes), viableNextSibling);\r\n    }\r\n  }\r\n\r\n  before(...nodes) {\r\n    const parent = this.parentNode;\r\n    if (parent) {\r\n      let viablePreviousSibling = this.previousSibling;\r\n      let idx = viablePreviousSibling ? nodes.indexOf(viablePreviousSibling) : -1;\r\n\r\n      while (idx !== -1) {\r\n        viablePreviousSibling = viablePreviousSibling.previousSibling;\r\n        if (!viablePreviousSibling) {\r\n          break;\r\n        }\r\n        idx = nodes.indexOf(viablePreviousSibling);\r\n      }\r\n\r\n      parent._preInsert(\r\n        convertNodesIntoNode(this._ownerDocument, nodes),\r\n        viablePreviousSibling ? viablePreviousSibling.nextSibling : parent.firstChild\r\n      );\r\n    }\r\n  }\r\n\r\n  replaceWith(...nodes) {\r\n    const parent = this.parentNode;\r\n    if (parent) {\r\n      let viableNextSibling = this.nextSibling;\r\n      let idx = viableNextSibling ? nodes.indexOf(viableNextSibling) : -1;\r\n\r\n      while (idx !== -1) {\r\n        viableNextSibling = viableNextSibling.nextSibling;\r\n        if (!viableNextSibling) {\r\n          break;\r\n        }\r\n        idx = nodes.indexOf(viableNextSibling);\r\n      }\r\n\r\n      const node = convertNodesIntoNode(this._ownerDocument, nodes);\r\n\r\n      if (this.parentNode === parent) {\r\n        parent._replace(node, this);\r\n      } else {\r\n        parent._preInsert(node, viableNextSibling);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  implementation: ChildNodeImpl\r\n};\r\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA;AAAqB,CAAC,GAAGC,OAAO,CAAC,SAAS,CAAC;AAEnD,MAAMC,aAAa,CAAC;EAClBC,MAAMA,CAAA,EAAG;IACP,IAAI,CAAC,IAAI,CAACC,UAAU,EAAE;MACpB;IACF;IAEA,IAAI,CAACA,UAAU,CAACC,OAAO,CAAC,IAAI,CAAC;EAC/B;EAEAC,KAAKA,CAAA,EAAW;IACd,MAAMC,MAAM,GAAG,IAAI,CAACH,UAAU;IAC9B,IAAIG,MAAM,EAAE;MACV,IAAIC,iBAAiB,GAAG,IAAI,CAACC,WAAW;MAAC,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAHpCC,KAAK,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;QAALF,KAAK,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;MAAA;MAIV,IAAIC,GAAG,GAAGR,iBAAiB,GAAGK,KAAK,CAACI,OAAO,CAACT,iBAAiB,CAAC,GAAG,CAAC,CAAC;MAEnE,OAAOQ,GAAG,KAAK,CAAC,CAAC,EAAE;QACjBR,iBAAiB,GAAGA,iBAAiB,CAACC,WAAW;QACjD,IAAI,CAACD,iBAAiB,EAAE;UACtB;QACF;QACAQ,GAAG,GAAGH,KAAK,CAACI,OAAO,CAACT,iBAAiB,CAAC;MACxC;MAEAD,MAAM,CAACW,UAAU,CAAClB,oBAAoB,CAAC,IAAI,CAACmB,cAAc,EAAEN,KAAK,CAAC,EAAEL,iBAAiB,CAAC;IACxF;EACF;EAEAY,MAAMA,CAAA,EAAW;IACf,MAAMb,MAAM,GAAG,IAAI,CAACH,UAAU;IAC9B,IAAIG,MAAM,EAAE;MACV,IAAIc,qBAAqB,GAAG,IAAI,CAACC,eAAe;MAAC,SAAAC,KAAA,GAAAZ,SAAA,CAAAC,MAAA,EAH3CC,KAAK,OAAAC,KAAA,CAAAS,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAALX,KAAK,CAAAW,KAAA,IAAAb,SAAA,CAAAa,KAAA;MAAA;MAIX,IAAIR,GAAG,GAAGK,qBAAqB,GAAGR,KAAK,CAACI,OAAO,CAACI,qBAAqB,CAAC,GAAG,CAAC,CAAC;MAE3E,OAAOL,GAAG,KAAK,CAAC,CAAC,EAAE;QACjBK,qBAAqB,GAAGA,qBAAqB,CAACC,eAAe;QAC7D,IAAI,CAACD,qBAAqB,EAAE;UAC1B;QACF;QACAL,GAAG,GAAGH,KAAK,CAACI,OAAO,CAACI,qBAAqB,CAAC;MAC5C;MAEAd,MAAM,CAACW,UAAU,CACflB,oBAAoB,CAAC,IAAI,CAACmB,cAAc,EAAEN,KAAK,CAAC,EAChDQ,qBAAqB,GAAGA,qBAAqB,CAACZ,WAAW,GAAGF,MAAM,CAACkB,UAAU,CAC9E;IACH;EACF;EAEAC,WAAWA,CAAA,EAAW;IACpB,MAAMnB,MAAM,GAAG,IAAI,CAACH,UAAU;IAC9B,IAAIG,MAAM,EAAE;MACV,IAAIC,iBAAiB,GAAG,IAAI,CAACC,WAAW;MAAC,SAAAkB,KAAA,GAAAhB,SAAA,CAAAC,MAAA,EAH9BC,KAAK,OAAAC,KAAA,CAAAa,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAALf,KAAK,CAAAe,KAAA,IAAAjB,SAAA,CAAAiB,KAAA;MAAA;MAIhB,IAAIZ,GAAG,GAAGR,iBAAiB,GAAGK,KAAK,CAACI,OAAO,CAACT,iBAAiB,CAAC,GAAG,CAAC,CAAC;MAEnE,OAAOQ,GAAG,KAAK,CAAC,CAAC,EAAE;QACjBR,iBAAiB,GAAGA,iBAAiB,CAACC,WAAW;QACjD,IAAI,CAACD,iBAAiB,EAAE;UACtB;QACF;QACAQ,GAAG,GAAGH,KAAK,CAACI,OAAO,CAACT,iBAAiB,CAAC;MACxC;MAEA,MAAMqB,IAAI,GAAG7B,oBAAoB,CAAC,IAAI,CAACmB,cAAc,EAAEN,KAAK,CAAC;MAE7D,IAAI,IAAI,CAACT,UAAU,KAAKG,MAAM,EAAE;QAC9BA,MAAM,CAACuB,QAAQ,CAACD,IAAI,EAAE,IAAI,CAAC;MAC7B,CAAC,MAAM;QACLtB,MAAM,CAACW,UAAU,CAACW,IAAI,EAAErB,iBAAiB,CAAC;MAC5C;IACF;EACF;AACF;AAEAuB,MAAM,CAACC,OAAO,GAAG;EACfC,cAAc,EAAE/B;AAClB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}